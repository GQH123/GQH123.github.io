<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】黑科技汇总]]></title>
    <url>%2F2025%2F09%2F09%2F%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E9%BB%91%E7%A7%91%E6%8A%80%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[引言在这神秘的光芒背后，有着怎样的奥秘？（纯胡扯黑科技大概指的就是我们编程中的一些技巧，无法单独开一篇文章进行记录，于是汇总到这里 这篇文章很早以前就开了，只是一直没有内容，下面我就来填充一下 数学数论下面的黑科技先只写描述，代码留坑待补 质因数分解法Pollard-Rho 因数分解法我们使用一个随机函数$F(x)$生成随机数列$a_1, a_2, \cdots, a_n$，其中，$F(x) = (ax^2 + c) \bmod n$ 然后，我们使用两个对于这个数列而言的指针（由于数列项的数量过大无法保存），其中一个的迭代速度是另一个的二倍，即$a = F(a), b = F(F(b))$ 然后，我们求出$d = gcd(\mid a - b \mid, n)$，如果$d &gt; 1$，那么我们就找到了一个$n$的因子$d$ 如果发现$b == a$，这说明数列出现循环，而我们此时发现了这一点，我们重新随机随机函数的那两个系数，然后重新随机进行分解 这样，我们可以在$O(n^{\frac{1}{4}})$实现对大数的质因数分解 线性筛质因数分解法首先我们先跑一遍线性筛，以$son[i]$记录把$i$筛掉的最小的质数 分解质因数的时候，不停地$n=n/son[n]$来分解 可以证明复杂度是单次$O(logn)$：每迭代一次，$n$被除以$son[n]$，而$son[n]$最小为$2$，故时间复杂度不超过$O(logn)$ 变上界质因数分解法众所周知，我们正常人在因数分解的时候，我们都是采用$O(\sqrt{n})$的算法进行暴力分解的，我们从小到大枚举质因数，判断能否整除$n$，然后再进行相应分解即可，直到枚举的质因数大于了$\sqrt{n}$，就停止，如果此时$n$不为$1$，那么它一定是一个质数（这应该很显然） 但是，我们发现，随着分解的进行，$n$在不断地减小，这就是说，$\sqrt{n}$这个上界也是不断地减小的，我们每次做完一个质因数的分解，直接更新上界，用当前的$\sqrt{n}$作为上界，然后继续上面的操作即可 经实测这个方法优化的效果十分明显，具体证明则是玄学 素数判定法Miller-Robin判素法具体操作方法的讲解网上应该已经很多了，本处暂略，时间复杂度：$O( \log n)$，适合大数判素或多组询问 黑科技公式下取整累积公式\frac{\left\lfloor\frac{x}{n}\right\rfloor}{k} = \left\lfloor\frac{x}{nk}\right\rfloor可以用下文的下取整不等式证明 取模公式k \bmod n = k - n * \left\lfloor\frac{k}{n}\right\rfloor这个公式很重要，在许多只有取模存在的式子中，这个公式往往是解题的关键 调和级数定理\sum_{d=1}^{N}\frac{N}{d}=N\log N\sum_{d=1}^{N}\sqrt{\frac{N}{d}}=N可以用微积分证明 异或不等式\left | a - b \right | \leq a \oplus b \leq a + b把异或运算转化为代数表达 分块公式我们现在已知$x$和$n$，要求最大的$y$满足 \left\lfloor\frac{n}{x}\right\rfloor = \left\lfloor\frac{n}{y}\right\rfloor那么 y = \left\lfloor\frac{n}{ \left\lfloor\frac{n}{x}\right\rfloor }\right\rfloor上/下取整不等式\left\lfloor\frac{n}{x}\right\rfloor = t \Leftrightarrow t * x \leq n < (t + 1) * x\left\lceil\frac{n}{x}\right\rceil = t \Leftrightarrow (t - 1) * x < n \leq t * x还有什么呢？到时候再说吧。。。 数据结构ST表计算极值覆盖区极值覆盖区，就是一个元素作为一个区间里的极值时，这个满足条件的区间的范围，或者是对于一个元素来说，如果它是作为最大值出现的，那么我们需要找到它左端第一个大于它的元素的位置以及右端第一个大于它的元素的位置 我们可以这样表示这个范围，对于第$i$个元素，我们用$l[i]$表示$i$能覆盖的最左端，$r[i]$表示$i$能覆盖的最右端 那么，对于所有满足$l[i] \leq l \leq i$并且$i \leq r \leq r[i]$的区间$[l, r]$来说，第$i$个元素的值都是这个区间里的极值 我们对于这个问题，可以使用二分+线段树在$O(log^2n)$的时间内处理每一个元素的覆盖区间，但是这显然太弱了是不是？ 我们可以考虑使用ST表来优化这个问题的复杂度，我们可以用$O(n \log n)$的复杂度预处理ST表，然后对于每个元素使用$O(\log n)$的复杂度求出边界，这样总共的复杂度就是$O(n \log n)$的，编程复杂度远低于上面的那个方法 其实这个问题还有一个$O(n)$的方法，然而我刚想到。。。所以就在下面说吧 代码如下：123456789101112131415161718192021222324int le[maxn][bit];int ri[maxn][bit];int line[maxn];int n;int main()&#123; rep(i, 1, n) le[i][0] = line[i], ri[i][0] = line[i]; rep(i, 1, n) rep(j, 1, bit - 1) &#123; if (i - two[j - 1] &gt;= 1) le[i][j] = min(le[i - two[j - 1]][j - 1], le[i][j - 1]); else le[i][j] = -INF; if (i + two[j - 1] &lt;= n) ri[i][j] = min(ri[i + two[j - 1]][j - 1], ri[i][j - 1]); else ri[i][j] = -INF; &#125;//初始化ST表 rep(i, 1, n)&#123; int x = i; int y = i; int op = line[i]; per(j, bit - 1, 0)&#123; if (le[x][j] &gt;= op) x -= two[j]; if (ri[y][j] &gt;= op) y += two[j]; &#125; l[i] = x + 1, r[i] = y - 1; &#125;//通过ST表不断跳跃寻找边界 return 0;&#125; 代码还是十分简单的 单调栈计算极值覆盖区接着ST表那里的讲解，这里有一个利用单调栈进行$O(n)$处理的玩法 假设每个元素是作为最大值出现的，我们先考虑求出每个位置的$i$的$r[i]$，我们维护一个单调递减的单调栈，从左扫到右，每次扫到一个元素，把所有小于这个元素的元素弹出，并把它们的$r[i]$记录为当前扫到的位置减一，然后我们把扫到的这个元素加入栈中，继续上述扫描，然后就可以求出所有的$r[i]$啦 关于正确性的证明，显然是对的啊。。。于是复杂度就都是$O(n)$了，又明显优于ST表的做法，而且达到了理论下界 不要和我说可以用一些已经推出的元素推导未知的来达到更优的复杂度，那样没什么意义。。。至少对于这个问题来说是这样，因为这个问题本身往往只是一个子问题，不值得使用过于复杂的处理 果然还是这样探究问题的未知的更优答案，能使人有更大的成就感啊 代码如下：123456789101112131415161718stack&lt;int&gt; s;int line[maxn];int n;int main()&#123; rep(i, 1, n)&#123; int op = line[i]; while (!s.empty() &amp;&amp; line[s.top()] &gt; op) r[s.top()] = i - 1, s.pop(); s.push(i); &#125; while (!s.empty()) r[s.top()] = n, s.pop(); per(i, n, 1)&#123; int op = line[i]; while (!s.empty() &amp;&amp; line[s.top()] &gt; op) l[s.top()] = i + 1, s.pop(); s.push(i); &#125; while (!s.empty()) l[s.top()] = 1, s.pop(); return 0;&#125; 代码又简单了一些。。。 枚举枚举子集这里有一个十分简洁高上的写法: 123for (int x = S; x; x = (x - 1) &amp; S)&#123; //do something...&#125; 感觉证明非常简单，首先，我们可以考虑$S$的二进制没有零的特殊情况，这样我们就相当于从$S$不断地减一，一直减到零，那么中间经过的这些数值很显然肯定是$S$的子集，如果$S$的二进制表示中有零存在，那么我们每次进行一个与操作，相当于是直接跳过了$S$的某一位为零，而$x$的那一位却为$1$的不合法情况，由于跳过的这些情况都是比剩下的所有合法情况数值要大的（看成十进制的数值），所以我们不会跳过合法情况 这样，就相当于我们的$x$经过且仅经过了所有合法的情况，这样就是对$S$的子集枚举啦 编程相关常数优化适当运用register关键字register关键字的作用是将后面声明的变量放入系统CPU的寄存器中，使得变量的操作速度快得飞起，但是我们只能将int类型的单个变量用这种方法声明，由于系统寄存器很小，所以建议不要同时对超过三个int变量进行register声明，否则反而会降低运行速度 所以，我们采取用完回收的原则，可以宏定义一种优化的for循环语句：1#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) 然后以后用rep(i, l, r)代替for循环就行了，实测可以大幅提高程序运行速度 内存优化减少额外占用实测发现，在使用较多的#include语句以及使用这个语句using namespace std;时，我们的程序会产生许多的额外内存开销，这对于卡内存的题目而言是非常不利的]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】编程错误汇总]]></title>
    <url>%2F2025%2F09%2F09%2F%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[引言妙妙妙妙不可言&lt;（￣︶￣）/ 前言大概就是许多常见错误的汇总，每次考试前仔细的看一看，认真地记一记，应该会有很大的好处 注意，下面的每个错误都很重要，时间允许的话一定要一字一字地看！ 语法类数据范围 随时都要注意是否应该使用更大的数据类型以防止溢出，这一点至关重要 常见的需要用到long long int的地方 算术表达式里面的计算中间结果 与取模有关的几乎所有题目 对程序计算答案的累计（即最终结果） 对于满足条件的n元组个数的统计 组合数学相关题目 一些数据范围很大的数论题以及需要用到杜教筛的数论题 总之每次都仔细的判断一下，程序完成后特别考虑一下这个问题，应该就没问题了 随时都要注意是否由于使用了较大的数据类型导致内存超限 注意输入输出是否使用了正确的类型表标识符 基本语句循环语句 注意内外层循环变量的冲突 注意内部语句循环变量的正确使用 注意循环变量与全局变量（循环外部变量）的冲突 条件语句 注意if…else的对应性，不要把内层的if对应到外层的else上，为避免这一错误可多使用’{}’ 注意运算符的优先级 分支语句 保险起见，在每个分支后面加上break; 宏定义 严重问题:注意宏定义的不安全性，代码示例如下： 我们想计算$(a + b) * c$12345678#include &lt;cstdio&gt;#define A a + bint main()&#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); printf("%d", A * c); return 0;&#125; 但这样做的结果是$a + b * c$要想得到正确结果，多使用’()’：12345678#include &lt;cstdio&gt;#define A (a + b)int main()&#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); printf("%d", A * c); return 0;&#125; 排序相关 严重问题：绝对不要使比较方法出现循环比较现象，必须保证排序结果唯一，相关链接：BZOJ 3712: [PA2014]Fiolki 在priority_queue的自定义比较用结构体中，注意运算符()的比较方法是：(a, b)在a的优先级小于b时返回True，即相当于重载大于运算符 STL 尽可能避免在任何STL中存放比较方法定义与外部数组存在关联的元素，否则会导致排序紊乱产生错误 set 严重问题：绝对不要使用STL的二分查找功能来查找set中的元素，只能使用set自带的二分查找成员函数，否则会导致严重的TLE问题 map 不要在未对要访问的map键值赋值的情况下访问它，否则会RE priority_queue 注意cmp的定义方法：当$a$比$b$优先级小的时候返回true 123456struct cmp&#123; bool operator () (int a, int b)&#123; return a &lt; b; &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p; $p$是一个大根堆 lower_bound/upper_bound 严重问题：绝对不要使用这两个函数来查找set中的元素，只能使用set自带的二分查找成员函数，否则会导致严重的TLE问题，本处再强调一遍 注意这两个二分查找函数只能作用于一个有序数组，即已经排好序的数组，而不能是任意数组（二分算法本身也要求有序...） 结构体构造函数 注意构造函数前面简化赋值语句的正确使用方法，相关链接：BZOJ 4502: 串 初始化 即使是定义在全局的结构体，内部变量初始时也不一定都为$0$，需要在构造函数中手动初始化 算法类前缀和/积 不要使最开头累加/乘的操作访问不该访问的内存 如果是求前缀积，一定不要忘记第一个元素应该手动设为$1$ 快速幂 注意不要忘记每次对幂数进行的右移操作，否则会TLE（当然，这个本地也是很容易测试出来的，但可能会不知道问题出在哪里） 严重问题：注意绝对不要使幂数为一个负数，如果容易出现此错误，最好提前判断一下 在取模的题目中，不要忘记每次乘法都是需要取模的 动态规划（DP） 在边界值问题上要特别注意，边界值需要经过计算与论证方可确定 注意情况讨论的不充分或是相互重叠的问题 在取模的问题中时刻记住对结果及时进行取模处理 严重问题：在记忆化搜索时，时刻记住在跳出当前计算层之前把vis数组设置为$true$，否则会导致严重的TLE问题 DP的状态转移不能存在环，否则需要使用最短路式更新法 注意：在题目卡常时，要将递归形式的DP改造为迭代形式，以大幅提高运行速度 图论 注意有些时候边与点数目的差异会很大，不要直接对存储点与边的数组直接使用相同大小的宏定义进行声明 数据结构树链剖分 注意题目的要求，仔细严谨地设置链上操作方法，相关链接：BZOJ 3319: 黑白树 Link-Cut-Tree 相关链接：Link-Cut-Tree完全解析 字典树(Trie) 严重问题：时刻注意Trie的空间占用大小并非$O(n)$而是$O(n\log n)$，要计算后声明足够的内存空间，同时防止内存超过限制 线段树 严重问题：注意不要让查询的区间为不合法区间，否则会RE，这种错误往往比较隐蔽，所以可能出现此情况时最好提前判断一下 注意线段树的基本架构不要写错： 12345678910void Operate (int l, int r, int o)&#123; //pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; //do something return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) Operate(l, mid, o &lt;&lt; 1); if (qy &gt; mid) Operate(mid + 1, r, o &lt;&lt; 1 | 1);&#125; 有的时候，当题目卡常数时，我们需要把线段树改写为迭代形式，以加快运行速度 可持久化线段树/主席树 严重问题：时刻注意可持久化线段树/主席树的空间占用大小并非$O(n)$而是$O(n\log n)$，要计算后声明足够的内存空间，同时防止内存超过限制]]></content>
      <tags>
        <tag>编程错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oier的知识]]></title>
    <url>%2F2019%2F06%2F28%2FOier%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[引言Oier的知识，以思维导图的方式呈现]]></content>
      <tags>
        <tag>Oier的知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4502: 串]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-4502-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[引言BZOJ 4502: 串 题解 BZOJ 4502: 串 Time Limit: 30 Sec Memory Limit: 512 MB Description兔子们在玩字符串的游戏。首先，它们拿出了一个字符串集合S，然后它们定义一个字符串为“好”的，当且仅当它可以被分成非空的两段，其中每一段都是字符串集合S中某个字符串的前缀。比如对于字符串集合{“abc”,”bca”}，字符串”abb”，”abab”是“好”的（”abb”=”ab”+”b”,abab=”ab”+”ab”），而字符串“bc”不是“好”的。兔子们想知道，一共有多少不同的“好”的字符串。 Input第一行一个整数n，表示字符串集合中字符串的个数接下来每行一个字符串 Output一个整数，表示有多少不同的“好”的字符串 Sample Input2 ab ac Sample Output9 HINT1&lt;=n&lt;=10000，每个字符串非空且长度不超过30，均为小写字母组成。 题目分析字符串好题 对于这样的一些多串问题，我们第一反应就是建出Trie树 然后，有了Trie树，我们继续观察题目性质 我们首先可以把所有的前缀两两有序组合，这样现在一共有$n ^ 2$个组合，我们考虑如何舍去其中重复的那些 我们规定，对于所有重复的组合，我们只保留第二个前缀长度最大的那个 这样，如果一个组合被舍弃了，我们能够知道，这是因为，这个组合的后一个前缀被真包含于一个更长的前缀，而且这个前缀可以和其他的前缀重新形成一样的组合 我们现在就要对每个前缀统计它能够舍掉多少个组合数量，我们定义一个组合被它所舍弃掉，当且仅当这个组合的第二个前缀是它的真后缀（如上面所说）并且能形成原来的组合，而且不存在另外一个满足前述条件的前缀真包含这个前缀，因为更短的前缀形成的组合会被其他的串舍弃掉 注意上面讨论的前缀都是作为第二个前缀存在于组合中的，而且其实上面的定义是为了更好的适用于AC自动机的失配边（就是说，其实是先想到了AC自动机，才要这样做的…..） 我们发现，对于一个前缀，我们需要找到它的最大的后缀，满足这个后缀在前缀集合中出现，所以我们需要建出AC自动机，然后沿着它的失配边走一次就能得到我们想要的这个前缀 我们知道，这会带来一个长度上的差值$d$，这告诉我们，所有长度大于$d$的前缀作为第一个前缀与这个较短的前缀组合的话，都是会被原前缀舍弃掉的，原因请自行思考 其实是这样的，你可以把第二个前缀加长到原前缀，然后前面的缩减$d$的长度，这样一定也是一种已经存在的组合 所以，我们只要对每个前缀都统计出需要舍掉多少，然后直接用$n ^ 2$减掉，就是最终答案了 好像比网上的DP快了6000多ms？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/************************************************************** Problem: 4502 User: Renatus Language: C++ Result: Accepted Time:4452 ms Memory:481016 kb****************************************************************/ #include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cassert&gt;#define maxs 105#define maxn 405005#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)using namespace std; int n, len;char s[maxs]; namespace Trie&#123; #define sigma 26 struct node&#123; node* ch[sigma]; int siz, tsiz; node(int siz = 0, int tsiz = 0) &#123;rep(i, 0, sigma - 1) ch[i] = NULL;&#125;//注意即使预先留了0的空位值，但是如果不赋上去的话也是没有用的 &#125;*root; void insert(node*&amp; now, int pos)&#123; if (!now) now = new node(), now -&gt; siz = now -&gt; tsiz = 0; now -&gt; siz++; if (pos &lt; 0) &#123;now -&gt; tsiz++; return;&#125; if (s[pos] - 'a' &gt;= sigma) assert(false); insert(now -&gt; ch[s[pos] - 'a'], pos - 1); &#125; int get_siz(node* now, int pos)&#123; if (!now) return 0; if (pos &lt; 0) return now -&gt; siz - now -&gt; tsiz; if (s[pos] - 'a' &gt;= sigma) assert(false); return get_siz(now -&gt; ch[s[pos] - 'a'], pos - 1); &#125;&#125;using namespace Trie; ll ans = 0; namespace AC_automaton&#123; #define sigma 26 int ch[maxn][sigma]; int d[maxn]; int f[maxn]; int ct = 0; queue&lt;int&gt; bfs; void insert()&#123; int now = 0; rep(i, 0, len - 1)&#123; int&amp; next = ch[now][s[i] - 'a']; if (!next) next = ++ct, d[next] = d[now] + 1; now = next; &#125; &#125; void get_AC()&#123; f[0] = 0; rep(i, 0, sigma - 1)&#123; if (ch[0][i]) bfs.push(ch[0][i]), f[ch[0][i]] = 0; &#125; while (!bfs.empty())&#123; int x = bfs.front(); bfs.pop(); rep(i, 0, sigma - 1)&#123; if (!ch[x][i]) continue; else&#123; int k = f[x]; while (k &amp;&amp; !ch[k][i]) k = f[k]; f[ch[x][i]] = ch[k][i]; bfs.push(ch[x][i]); &#125; &#125; &#125; &#125; void DFS(int x)&#123; insert(root, len - 1); rep(i, 0, sigma - 1)&#123; if (!ch[x][i]) continue; s[len++] = 'a' + i; DFS(ch[x][i]); len--; &#125; &#125; void DFS2(int x)&#123; int k = f[x]; if (k)&#123; len -= d[k]; ans -= get_siz(root, len - 1); len += d[k]; &#125; rep(i, 0, sigma - 1)&#123; if (!ch[x][i]) continue; s[len++] = 'a' + i; DFS2(ch[x][i]); len--; &#125; &#125;&#125;using namespace AC_automaton; int main()&#123; #ifndef ONLINE_JUDGE freopen("bunch.in", "r", stdin); #endif scanf("%d", &amp;n); rep(i, 1, n) &#123; scanf("%s", s); len = strlen(s); insert(); &#125; get_AC(); len = 0; DFS(0); ans = (ll)ct * ct; len = 0; DFS2(0); printf("%lld", ans); return 0;&#125; 细节：注意构造函数的正确使用方法]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>Trie</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3712: [PA2014]Fiolki]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-3712-PA2014-Fiolki%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3712: [PA2014]Fiolki 题解 BZOJ 3712: [PA2014]Fiolki Time Limit: 30 Sec Memory Limit: 128 MB Description化学家吉丽想要配置一种神奇的药水来拯救世界。吉丽有n种不同的液体物质，和n个药瓶（均从1到n编号）。初始时，第i个瓶内装着g[i]克的第i种物质。吉丽需要执行一定的步骤来配置药水，第i个步骤是将第a[i]个瓶子内的所有液体倒入第b[i]个瓶子，此后第a[i]个瓶子不会再被用到。瓶子的容量可以视作是无限的。吉丽知道某几对液体物质在一起时会发生反应产生沉淀，具体反应是1克c[i]物质和1克d[i]物质生成2克沉淀，一直进行直到某一反应物耗尽。生成的沉淀不会和任何物质反应。当有多于一对可以发生反应的物质在一起时，吉丽知道它们的反应顺序。每次倾倒完后，吉丽会等到反应结束后再执行下一步骤。吉丽想知道配置过程中总共产生多少沉淀。 Input第一行三个整数n,m,k(0&lt;=m&lt;n&lt;=200000,0&lt;=k&lt;=500000)，分别表示药瓶的个数（即物质的种数），操作步数，可以发生的反应数量。第二行有n个整数g[1],g[2],…,g[n]（1&lt;=g[i]&lt;=10^9)，表示初始时每个瓶内物质的质量。接下来m行，每行两个整数a[i],bi，表示第i个步骤。保证a[i]在以后的步骤中不再出现。接下来k行，每行是一对可以发生反应的物质c[i],di，按照反应的优先顺序给出。同一个反应不会重复出现。 Output所求答案 Sample Input3 2 1 2 3 4 1 2 3 2 2 3 Sample Output6 Source鸣谢Jcvb 题目分析一道思维好题 一开始我还用并查集+set+启发式合并，结果直接TLE……虽然卡卡常也许能过，但是没有必要了对吧 我们发现，整个实验过程可以看成一棵树的结构，一开始，每瓶药剂都是单独的点，我们做一次实验，就合并两个点，相当于新建一个点作为他们的父亲，然后这个父亲继续参与反应 这样，我们可以建出树 然后，两个反应最近的反应时间，就是它们的LCA，我们知道，每对药剂最多只会反应一次，因为不会只倒出部分药剂，所以我们把每对可能反应按照发生时间排序再做一遍，同时发现当前反应未发生就直接跳出即可 其实还是有一些细节 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define ll long long int#define maxn 600005 //注意开够内存#define bit 20#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m, k, ct = 0;int g[maxn];int now[maxn];struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int fa[maxn][bit + 1];int d[maxn];void DFS(int x)&#123; rep(i, 1, bit) fa[x][i] = fa[fa[x][i - 1]][i - 1]; erep(i, x)&#123; int op = e[i].to; if (op == fa[x][0]) continue; fa[op][0] = x; d[op] = d[x] + 1; DFS(op); &#125;&#125;int get_lca(int x, int y)&#123; if (x == y) return x; if (d[x] &lt; d[y]) swap(x, y); int k = d[x] - d[y], now = 0; while (k)&#123; if (k &amp; 1) x = fa[x][now]; now++, k &gt;&gt;= 1; &#125; if (x == y) return x; per(i, bit, 0) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0];&#125;struct ope&#123; int x, y, t, id; ope(int x = 0, int y = 0, int t = 0, int id = 0) : x(x), y(y), t(t), id(id)&#123;&#125; bool operator &lt; (const ope b) const&#123; return (t == b.t) ? id &lt; b.id : (d[t] == d[b.t]) ? t &lt; b.t : d[t] &gt; d[b.t]; //return (t == b.t) ? id &lt; b.id : d[t] &gt; d[b.t]; 这样写是不对的，因为有可能出现循环比较 &#125;&#125;line[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen("fiolki.in", "r", stdin); #endif int x, y; read(n), read(m), read(k); rep(i, 1, n) read(g[i]), now[i] = i; ct = n; rep(i, 1, m)&#123; read(x), read(y); ++ct; if (!now[x] || !now[y]) assert(false); Add_Edge(now[x], ct); Add_Edge(now[y], ct); now[x] = 0, now[y] = ct; &#125; ++ct; rep(i, 1, n) if (now[i]) Add_Edge(ct, now[i]); DFS(ct); rep(i, 1, k)&#123; read(x), read(y); int lca = get_lca(x, y); line[i] = ope(x, y, lca, i); &#125; sort(line + 1, line + 1 + k); ll ans = 0; rep(i, 1, k)&#123; if (line[i].t == ct) break; x = line[i].x, y = line[i].y; int mi = min(g[x], g[y]); g[x] -= mi, g[y] -= mi, ans += mi &lt;&lt; 1; &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4592: [Shoi2015]脑洞治疗仪]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-4592-Shoi2015-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[引言BZOJ 4592: [Shoi2015]脑洞治疗仪 题解 BZOJ 4592: [Shoi2015]脑洞治疗仪 Time Limit: 20 Sec Memory Limit: 256 MB Description曾经发明了自动刷题机的发明家SHTSC又公开了他的新发明：脑洞治疗仪—一种可以治疗他因为发明而日益增大的脑洞的神秘装置。为了简单起见，我们将大脑视作一个01序列。1代表这个位置的脑组织正常工作，0代表这是一块脑洞。1 0 1 0 0 0 1 1 1 0脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？）例如，用上面第8号位置到第10号位置去修补第1号位置到第4号位置的脑洞。我们就会得到：1 1 1 1 0 0 1 0 0 0如果再用第1号位置到第4号位置去修补第8号位置到第10号位置：0 0 0 0 0 0 1 1 1 1这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。如果再用第7号位置到第10号位置去填补第1号位置到第6号位置：1 1 1 1 0 0 0 0 0 0这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。假定初始时SHTSC并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答SHTSC的问题：在大脑某个区间中最大的连续脑洞区域有多大。 Input第一行两个整数n，m。表示SHTSC的大脑可分为从1到n编号的n个连续区域。有m个操作。以下m行每行是下列三种格式之一。0 l r ：SHTSC挖了一个从l到r的脑洞。1 l0 r0 l1 r2 ：SHTSC进行了一次脑洞治疗，用从l0到r0的脑组织修补l1到r1的脑洞。2 l r ：SHTSC询问l到r这段区间最大的脑洞有多大。n,m &lt;=200000，1&lt;=l&lt;=r&lt;=n Output对于每个询问，输出一行一个整数，表示询问区间内最大连续脑洞区域有多大。 Sample Input10 10 0 2 2 0 4 6 0 10 10 2 1 10 1 8 10 1 4 2 1 10 1 1 4 8 10 2 1 10 1 7 10 1 6 2 1 10 Sample Output3 3 6 6 SourceBy 佚名上传 题目分析线段树 我们发现，需要维护01序列的最长连续段，这部分使用经典的前中后法即可维护 然后我们还需要维护区间1的个数，即区间和，直接搞就好 对于最后一个填充操作，用区间覆盖实现，我们优先搞左边，如果左边搞完还剩下脑组织，就搞右边，如此即可 还可以结合区间和以及区间覆盖标记搞一些小的优化剪枝，比如如果已经全是1就直接跳出等等 所以还算是比较快的，rank7 还是1A，挺开心 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/************************************************************** Problem: 4592 User: Renatus Language: C++ Result: Accepted Time:2932 ms Memory:16840 kb****************************************************************/ #include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define maxn 400005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std; char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125; int n, m; int set[maxn &lt;&lt; 1];int le[maxn &lt;&lt; 1];int ri[maxn &lt;&lt; 1];int mi[maxn &lt;&lt; 1];int sum[maxn &lt;&lt; 1];int qx, qy, qd; void pushup(int l, int r, int o)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (!sum[o &lt;&lt; 1]) le[o] = mid - l + 1 + le[o &lt;&lt; 1 | 1]; else le[o] = le[o &lt;&lt; 1]; if (!sum[o &lt;&lt; 1 | 1]) ri[o] = r - mid + ri[o &lt;&lt; 1]; else ri[o] = ri[o &lt;&lt; 1 | 1]; mi[o] = max(ri[o &lt;&lt; 1] + le[o &lt;&lt; 1 | 1], max(mi[o &lt;&lt; 1], mi[o &lt;&lt; 1 | 1])); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125; void pushdown(int l, int r, int o)&#123; if (set[o] == -1 || l == r) return; if (set[o])&#123; int mid = ((r - l) &gt;&gt; 1) + l; int ls = o &lt;&lt; 1; le[ls] = ri[ls] = mi[ls] = 0, sum[ls] = mid - l + 1; set[ls] = 1; int rs = o &lt;&lt; 1 | 1; le[rs] = ri[rs] = mi[rs] = 0, sum[rs] = r - mid; set[rs] = 1; &#125; else&#123; int mid = ((r - l) &gt;&gt; 1) + l; int ls = o &lt;&lt; 1; le[ls] = ri[ls] = mi[ls] = mid - l + 1, sum[ls] = 0; set[ls] = 0; int rs = o &lt;&lt; 1 | 1; le[rs] = ri[rs] = mi[rs] = r - mid, sum[rs] = 0; set[rs] = 0; &#125; set[o] = -1;&#125; void init(int l, int r, int o)&#123; set[o] = -1; if (l == r) &#123;sum[o] = 1; return;&#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125; int get(int l, int r, int o)&#123; if (set[o] == 0) return 0; if (set[o] == 1) return min(qy, r) - max(qx, l) + 1; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l, ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125; void dig(int l, int r, int o)&#123; if (set[o] == 0) return; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) &#123; set[o] = sum[o] = 0; le[o] = ri[o] = mi[o] = r - l + 1; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) dig(l, mid, o &lt;&lt; 1); if (qy &gt; mid) dig(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125; void fill(int l, int r, int o)&#123; if (set[o] == 1 || !qd) return; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; int rest = r - l + 1 - sum[o]; if (rest &lt;= qd)&#123; qd -= rest; set[o] = 1; le[o] = ri[o] = mi[o] = 0; sum[o] = r - l + 1; &#125; else&#123; int mid = ((r - l) &gt;&gt; 1) + l; fill(l, mid, o &lt;&lt; 1); if (qd) fill(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o); &#125; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid &amp;&amp; qd) fill(l, mid, o &lt;&lt; 1); if (qy &gt; mid &amp;&amp; qd) fill(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125; struct ele&#123; int x, y, m; ele(int x = 0, int y = 0, int m = 0) : x(x), y(y), m(m)&#123;&#125; bool operator = (const ele b) &#123; x = b.x, y = b.y, m = b.m; &#125;&#125;; ele query(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return ele(le[o], ri[o], mi[o]); int mid = ((r - l) &gt;&gt; 1) + l; ele ans1 = ele(-1, -1, -1), ans2 = ele(-1, -1, -1), ans = ele(-1, -1, -1); if (qx &lt;= mid) ans1 = query(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans2 = query(mid + 1, r, o &lt;&lt; 1 | 1); if (ans1.x == -1) return ans2; if (ans2.x == -1) return ans1; if (ans1.x == mid - l + 1) ans.x = ans1.x + ans2.x; else ans.x = ans1.x; if (ans2.y == r - mid) ans.y = ans1.y + ans2.y; else ans.y = ans2.y; ans.m = max(ans1.y + ans2.x, max(ans1.m, ans2.m)); return ans;&#125; int main()&#123; #ifndef ONLINE_JUDGE freopen("cure.in", "r", stdin); #endif int op; read(n), read(m); init(1, n, 1); rep(i, 1, m)&#123; read(op); switch(op)&#123; case 0: read(qx), read(qy), dig(1, n, 1); break; case 1: read(qx), read(qy), qd = get(1, n, 1), dig(1, n, 1), read(qx), read(qy), fill(1, n, 1); break; case 2: read(qx), read(qy); ele ans = query(1, n, 1); printf("%d\n", max(ans.x, max(ans.y, ans.m))); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1334: [Baltic2008]Elect]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-1334-Baltic2008-Elect%2F</url>
    <content type="text"><![CDATA[引言BZOJ 1334: [Baltic2008]Elect 题解 BZOJ 1334: [Baltic2008]Elect Time Limit: 10 Sec Memory Limit: 162 MB DescriptionN个政党要组成一个联合内阁，每个党都有自己的席位数. 现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好. 对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的. Input第一行给出有多少个政党.其值小于等于300 下面给出每个政党的席位数.总席位数小于等于 100000 Output你的组阁方案中最多能占多少个席位. Sample Input4 1 3 2 4 Sample Output7 HINT选择第二个政党和第四个 题目分析十分简单的背包DP 每次只使用容量不超过一半的状态来转移 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define maxn 200005#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '0') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m = 0;bool dp[maxn];int g[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen("elect.in", "r", stdin); #endif ll sum = 0; read(n); rep(i, 1, n) read(g[i]), m += g[i]; sort(g + 1, g + 1 + n); dp[0] = 1; int mid = m &gt;&gt; 1; per(i, n, 1) per(j, min(g[i] + mid, m), g[i]) dp[j] |= dp[j - g[i]]; per(i, m, 0) if (dp[i]) &#123; printf("%d", i); return 0; &#125; assert(false); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1125: [POI2008]Poc]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-1125-POI2008-Poc%2F</url>
    <content type="text"><![CDATA[引言BZOJ 1125: [POI2008]Poc 题解 BZOJ 1125: [POI2008]Poc Time Limit: 10 Sec Memory Limit: 162 MB Descriptionn列火车，每条有l节车厢。每节车厢有一种颜色（用小写字母表示）。有m次车厢交换操作。求：对于每列火车，在交换车厢的某个时刻，与其颜色完全相同的火车最多有多少。 Inputn l m (2 ≤ n ≤ 1000, 1 ≤ l ≤ 100, 0 ≤ m ≤ 100000) n行字符串，长度为l m行，每行4个数a b c d,a车的第b个字符与c车第d个字符交换。 Outputn个数，在交换车厢的某个时刻，与该车颜色完全相同的火车最多数目。 Sample Input5 6 7 ababbd abbbbd aaabad caabbd cabaad 2 3 5 4 5 3 5 5 3 5 2 2 1 2 4 3 2 2 5 1 1 1 3 3 4 1 5 6 Sample Output3 3 3 2 3 题目分析好题 据说网上代码都是什么平衡树上打标记？虽然挺有道理，但还是跑不过我…… 现在好像还是rank3…… 这种差距就不是卡常数能解决的了…… 我们考虑这样做，我们发现，需要求完全相同的串的个数，这就是同构性判定，我们很容易想到Hash 我们可以$O(n)$求出所有会出现的Hash值，先把他们离散化一下 然后，我们发现，如果我们直接对每个Hash维护单调栈，那么是不行的，因为串的进入时间不一样，在查询的时候不能用已经操作过许多次的栈来更新答案，因为里面会包含许多本不该包含的信息 这样，难道我们就需要可持久化单调栈了吗？ 反正我没试过….但是我知道，由于后添加的栈内元素信息一定是会被包含的（但是元素本身不一定，仔细体会一下这里的含义），所以我们可以对每个元素记录一下它自己进入栈的时间 同时，在每个串被操作的时候，把它取出来更新答案，这时候，我们也对这个串记录一下它是什么时候进入它原来的那个单调栈的，然后直接栈内二分即可更新答案 这样，好像就行了？总之虽然总复杂度好像相同，但是我修改是$O(1)$的，这样也能优化很多？ 其实我还有好多优化没有使用…… 但是这样写会导致细节非常多，有什么串操作后不变，或是交换同一个串的两个字符，或是这两种情况合在一起，然后最开始和最后全都需要更新一次答案……自己写写吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/************************************************************** Problem: 1125 User: Renatus Language: C++ Result: Accepted Time:1756 ms Memory:14484 kb****************************************************************/ #include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define maxn 2005#define maxl 205 #define maxm 200005#define Hash 998244353#define M 1000000007 #define ll long long int#define fi first#define se second#define push push_back#define pop pop_back #define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std; char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125; int n, l, m; char k[maxn][maxl];void reads(int x)&#123; char ch = gc(); while (!('a' &lt;= ch &amp;&amp; ch &lt;= 'z')) ch = gc(); int now = 0; while ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') k[x][++now] = ch, ch = gc(); k[x][++now] = '\0';&#125; struct pii&#123; int fi, se; pii(int fi = 0, int se = 0) : fi(fi), se(se)&#123;&#125; bool operator &lt; (const pii b) const&#123; return (fi == b.fi) ? se &lt; b.se : fi &lt; b.fi; &#125;&#125;; int has[maxn], _has[maxn];int t[maxn];ll mi[maxl];void get_hash(int x)&#123; has[x] = 0; rep(i, 1, l) has[x] = ((ll)has[x] * Hash % M + k[x][i]) % M;&#125; struct query&#123; int x, y, z, w; query(int x = 0, int y = 0, int z = 0, int w = 0) : x(x), y(y), z(z), w(w)&#123;&#125;&#125;q[maxm]; int line[(maxm &lt;&lt; 1) + maxn];int cnt = 0; vector&lt;pii&gt; s[(maxm &lt;&lt; 1) + maxn];int siz[(maxm &lt;&lt; 1) + maxn]; //当前hash等于下标的串个数 int ans[maxn];void get_ans(int x)&#123; int h = has[x]; ans[x] = max(ans[x], lower_bound(s[h].begin(), s[h].end(), pii(t[x], 0)) -&gt; se); &#125; void remove(int x, int ti)&#123; int h = has[x]; siz[h]--; while (!s[h].empty() &amp;&amp; s[h].back().fi == ti) s[h].pop(); s[h].push(pii(ti, siz[h])); &#125; void modify(int x, int y, int ti)&#123; int h = has[x]; h = has[x] = y, siz[h]++, t[x] = ti; while (!s[h].empty() &amp;&amp; (s[h].back().se &lt;= siz[h] || s[h].back().fi == ti)) s[h].pop(); s[h].push(pii(ti, siz[h])); &#125;//remove和modify需要分离，具体原因自行思考 int main()&#123; #ifndef ONLINE_JUDGE freopen("poc.in", "r", stdin); freopen("poc.out", "w", stdout); #endif int x, y, z, w; read(n), read(l), read(m); //预处理模块 mi[0] = 1; rep(i, 1, l) mi[i] = mi[i - 1] * Hash % M; rep(i, 1, n) reads(i); rep(i, 1, n) get_hash(i), line[++cnt] = has[i], _has[i] = has[i]; rep(i, 1, m) &#123; read(x), read(y), read(z), read(w); int d = k[z][w] - k[x][y]; has[x] = (has[x] + M + mi[l - y] * d % M) % M; has[z] = (has[z] + M - mi[l - w] * d % M) % M; swap(k[x][y], k[z][w]); q[i] = query(x, z, has[x], has[z]); line[++cnt] = has[x], line[++cnt] = has[z]; &#125; //离散化模块 sort(line + 1, line + 1 + cnt); cnt = unique(line + 1, line + 1 + cnt) - line - 1; rep(i, 1, n) has[i] = _has[i]; rep(i, 1, n) has[i] = lower_bound(line + 1, line + 1 + cnt, has[i]) - line; rep(i, 1, m)&#123; q[i].z = lower_bound(line + 1, line + 1 + cnt, q[i].z) - line; q[i].w = lower_bound(line + 1, line + 1 + cnt, q[i].w) - line; &#125; //算法工作模块 rep(i, 1, n) siz[has[i]]++, t[i] = 0; rep(i, 1, n) if (s[has[i]].empty()) s[has[i]].push(pii(0, siz[has[i]])); rep(i, 1, n) get_ans(i); rep(i, 1, m)&#123; //注意更新答案与修改的顺序 get_ans(q[i].x), get_ans(q[i].y); if (q[i].x == q[i].y) &#123; remove(q[i].y, i), modify(q[i].y, q[i].w, i); continue; &#125;//注意特殊判断边界情况 remove(q[i].x, i), remove(q[i].y, i); modify(q[i].x, q[i].z, i), modify(q[i].y, q[i].w, i); //需要分离remove和modify，否则可能会弹出有用元素，包含无用信息 &#125; rep(i, 1, n) get_ans(i); rep(i, 1, n) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>离散化</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>单调栈</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3304: [Shoi2005]带限制的最长公共子序列]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-3304-Shoi2005-%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3304: [Shoi2005]带限制的最长公共子序列 题解 BZOJ 3304: [Shoi2005]带限制的最长公共子序列 Time Limit: 10 Sec Memory Limit: 128 MB Description Input输入共三行，每行为长度不超过500的，小写字母组成的非空字符串按顺序分别表示x,y,z Output如存在满足条件的N，输出W的长度，否则输出 NO SOLUTION Sample Inputhelloworld hellxebore xr Sample Output5 HINTw=hxeor 本题要求找出的W首先是X与Y的公共子序列并且包含Z，然后才是满足这些条件的 字符串里面找最长的。 题目分析MDZZ，吃饭的时候都在想这道题，结果一看题解，$O(n ^ 3)$可过？！ 真是f**k 直接记录三个串各自的匹配位置滚动一下就好 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 515#define INF 2000000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m, k;char a[maxn], b[maxn], c[maxn];int dp[maxn][maxn][2];int main()&#123; #ifndef ONLINE_JUDGE freopen("lcs.in", "r", stdin); #endif scanf("%s%s%s", a + 1, b + 1, c + 1); n = strlen(a + 1), m = strlen(b + 1), k = strlen(c + 1); int d = 0; per(l, k + 1, 1) &#123; if (l != k + 1)&#123; rep(i, 1, n + 1) dp[i][m + 1][d] = -INF; rep(i, 1, m + 1) dp[n + 1][i][d] = -INF; &#125; per(i, n, 1) per(j, m, 1) &#123; if (a[i] == b[j])&#123; if (a[i] == c[l]) dp[i][j][d] = max(dp[i + 1][j + 1][d ^ 1], dp[i + 1][j + 1][d]) + 1; else dp[i][j][d] = dp[i + 1][j + 1][d] + 1; &#125; else dp[i][j][d] = max(dp[i + 1][j][d], dp[i][j + 1][d]); &#125; d ^= 1; &#125; if (dp[1][1][d ^ 1] &gt; 0) printf("%d", dp[1][1][d ^ 1]); else printf("NO SOLUTION"); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>最长公共子序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4275: [ONTAK2015]Badania naukowe]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-4275-ONTAK2015-Badania-naukowe%2F</url>
    <content type="text"><![CDATA[引言BZOJ 4275: [ONTAK2015]Badania naukowe 题解 BZOJ 4275: [ONTAK2015]Badania naukowe Time Limit: 3 Sec Memory Limit: 256 MB Description给定三个数字串A,B,C，请找到一个A,B的最长公共子序列，满足C是该子序列的子串。 Input第一行包含一个正整数n(1&lt;=n&lt;=3000)，表示A串的长度。第二行包含n个正整数，其中第i个数表示Ai。第三行包含一个正整数m(1&lt;=m&lt;=3000)，表示B串的长度。第四行包含m个正整数，其中第i个数表示Bi。第五行包含一个整数k(0&lt;=k&lt;=3000)，表示C串的长度。第六行包含k个正整数，其中第i个数表示Ci。 Output输出一个整数，即满足条件的最长公共子序列的长度，如果无解输出-1。特别的，如果k为0且无解，请输出0。 Sample Input7 1 2 2 3 1 1 2 6 1 2 1 3 1 2 2 3 2 Sample Output4 HINT找到的最长个公共子序列为(1,2,3,2)。 题目分析就是一道ZZ的LCS上DP，一开始我还以为需要KMP…… 后来发现直接暴力枚举开头，然后贪心匹配，一旦匹配结束就退出并记录这个区间，然后DP一下前后缀LCS，再枚举两个串分别的匹配位置，更新一下答案就好…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 4005#define pii pair&lt;int, int&gt; #define fi first#define se second#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++) using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') ch = gc(), f = 0; while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m, k;int a[maxn];int b[maxn];int c[maxn];int ca = 0;pii sa[maxn];int cb = 0;pii sb[maxn];int pre[maxn][maxn];int suf[maxn][maxn];void init()&#123; rep(i, 1, n) &#123; if (a[i] != c[1]) continue; pii op = pii(i, 0); int now = 2; bool f = 0; rep(j, i + 1, n)&#123; if (now &gt; k) &#123; op.se = j - 1; sa[++ca] = op; f = 1; break; &#125; if (a[j] == c[now]) now++; &#125; if (!f &amp;&amp; now &gt; k) &#123; op.se = n; sa[++ca] = op; f = 1; &#125; if (!f) break; &#125; rep(i, 1, m) &#123; if (b[i] != c[1]) continue; pii op = pii(i, 0); int now = 2; bool f = 0; rep(j, i + 1, m)&#123; if (now &gt; k) &#123; op.se = j - 1; sb[++cb] = op; f = 1; break; &#125; if (b[j] == c[now]) now++; &#125; if (!f &amp;&amp; now &gt; k) &#123; op.se = m; sb[++cb] = op; f = 1; &#125; if (!f) break; &#125;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("bad.in", "r", stdin); #endif read(n); rep(i, 1, n) read(a[i]); read(m); rep(i, 1, m) read(b[i]); read(k); rep(i, 1, k) read(c[i]); rep(i, 1, n) rep(j, 1, m) pre[i][j] = (a[i] == b[j]) ? (pre[i - 1][j - 1] + 1) : max(pre[i - 1][j], pre[i][j - 1]); per(i, n, 1) per(j, m, 1) suf[i][j] = (a[i] == b[j]) ? (suf[i + 1][j + 1] + 1) : max(suf[i + 1][j], suf[i][j + 1]); if (!k)&#123; printf("%d", pre[n][m]); return 0; &#125; init(); int ans = -1; rep(i, 1, ca) rep(j, 1, cb) ans = max(ans, pre[sa[i].fi - 1][sb[j].fi - 1] + k + suf[sa[i].se + 1][sb[j].se + 1]); printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>最长公共子序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3319: 黑白树]]></title>
    <url>%2F2018%2F01%2F15%2FBZOJ-3319-%E9%BB%91%E7%99%BD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3319: 黑白树 题解 BZOJ 3319: 黑白树 Time Limit: 10 Sec Memory Limit: 512 MB Description给定一棵树，边的颜色为黑或白，初始时全部为白色。维护两个操作： 1.查询u到根路径上的第一条黑色边的标号。2.将u到v 路径上的所有边的颜色设为黑色。 Notice:这棵树的根节点为1 Input第一行两个数n,m分别表示点数和操作数。接下来n-? 1行，每行2个数u,v.表示一条u到v的边。接下来m行，每行为以下格式： 1 v 表示第一个操作 2 v u 表示第二种操作 Output对于每个询问，输出相应答案。如果不存在，输出0。 Sample Input5 4 1 2 1 3 2 4 2 5 1 2 2 2 3 1 3 1 4 Sample Output0 2 1 HINT对于 100% 的数据：n，m&lt;=10^6 题目分析显然是一道ZZ的树链剖分题……但是我TM居然WA了好几次，我们只需要记录一下每个点的父亲边编号，然后每次染黑的时候除了LCA以外都染黑就行了，所以需要特殊判一些东西…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define maxn 2000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') ch = gc(), f = 0; while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn];int cnt = 1, h[maxn];void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int fa[maxn];int son[maxn];int siz[maxn];int top[maxn];int dfs[maxn];int idfs[maxn];int d[maxn];int num[maxn];int t = 0;void DFS(int x)&#123; siz[x] = 1; erep(i, x)&#123; int op = e[i].to; if (op == fa[x]) &#123;num[x] = i &gt;&gt; 1; continue;&#125; fa[op] = x; d[op] = d[x] + 1; DFS(op); siz[x] += siz[op]; if (siz[op] &gt; siz[son[x]]) son[x] = op; &#125;&#125;void DFS(int x, int tp)&#123; top[x] = tp; dfs[x] = ++t; idfs[t] = x; if (son[x]) DFS(son[x], tp); erep(i, x)&#123; int op = e[i].to; if (op == fa[x] || op == son[x]) continue; DFS(op, op); &#125;&#125;void init()&#123; DFS(1); DFS(1, 1);&#125;int sum[maxn &lt;&lt; 1];int qx, qy, qd;void set(int l, int r, int o)&#123; if (sum[o] == r - l + 1) return; if (l == r) &#123;sum[o] = 1; return;&#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) set(l, mid, o &lt;&lt; 1); if (qy &gt; mid) set(mid + 1, r, o &lt;&lt; 1 | 1); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;int find(int l, int r, int o)&#123; if (l == r) return (sum[o]) ? num[idfs[l]] : 0; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (sum[o &lt;&lt; 1 | 1]) return find(mid + 1, r, o &lt;&lt; 1 | 1); return find(l, mid, o &lt;&lt; 1); &#125; int mid = ((r - l) &gt;&gt; 1) + l; int d = 0; if (qy &gt; mid) d = find(mid + 1, r, o &lt;&lt; 1 | 1); if (d) return d; return (qx &lt;= mid) ? find(l, mid, o &lt;&lt; 1) : 0;&#125;void set(int x, int y)&#123; int a = top[x], b = top[y]; while (a != b)&#123; if (d[a] &lt; d[b]) swap(x, y), swap(a, b); qx = dfs[a], qy = dfs[x]; set(1, n, 1); x = fa[a], a = top[x]; &#125; if (d[x] &lt; d[y]) swap(x, y); qx = dfs[y] + 1, qy = dfs[x]; if (qx &lt;= qy) set(1, n, 1);&#125;int get(int x)&#123; int a = top[x]; while (x)&#123; qx = dfs[a], qy = dfs[x]; int d = find(1, n, 1); if (d) return d; else x = fa[a], a = top[x]; &#125; return 0;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("bw.in", "r", stdin); #endif int x, y, op; read(n), read(m); rep(i, 1, n - 1) read(x), read(y), Add_Edge(x, y); init(); rep(i, 1, m)&#123; read(op); if (op == 1) read(x), printf("%d\n", get(x)); else if (op == 2) read(x), read(y), set(x, y); else assert(false); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link-Cut-Tree完全解析]]></title>
    <url>%2F2018%2F01%2F13%2FLink-Cut-Tree%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[引言终于迎来这一刻啦O(∩_∩)O~，可以专心致志地写一篇完全解析了 先理一下先修知识 先修知识： 树链剖分 Splay平衡树 Splay翻转树 再介绍一下本文的目录 目录 Link-Cut-Tree基础 讲解 模板 例题 易错点 Link-Cut-Tree维护边信息 讲解 模板 例题 易错点 Link-Cut-Tree维护子树信息 讲解 模板 例题 易错点 Link-Cut-Tree高级应用 前言 例题 易错点 当然，这只是期望的样子，要真的完成这么多恐怕要好长时间吧 讲解那么，讲解就正式开始啦！ Link-Cut-Tree基础讲解首先，大家应该都学习过树链剖分对吧，我们知道，树链剖分维护的是一个固定的树剖分，我们通常采用轻重树链剖分法来实现这一点，但是，当树的形态可以发生改变的时候，这么做显然就不行了，因为如果我们继续使用当前的链剖分形式，就无法保证时间复杂度，而如果动态地去维护树剖分，听起来又好像是一件挺困难的事情 实际上，我们正是采用后者进行维护的，这个东西，就是传说中的动态树了，而维护树的形态改变以后的新的树剖分的算法，就是这次的主要内容Link-Cut-Tree 我们知道，一个树剖分是由链组成的，而对于每一条链来说，这就是一个序列，而对于序列上的问题，我们可以采用许多方法进行解决，比如使用数据结构 在树链剖分里面，我们正是这样做的，我们先求出一个树剖分，然后把它们放到线段树上进行统一的维护，这样就大大地降低了算法的复杂度和维护的难度。但是，对于动态树来说，它的形态在不断的发生变化，这样，我们很难记录每条链的顶端等信息，然后使用线段树维护 这样，由于有了序列的动态操作，所以我们需要一种支持快速的序列分裂与合并操作的数据结构，这让我们想到Splay 而Link-Cut-Tree正是采用了这样的方法，我们把每条链都放到一棵Splay上进行维护，然后进行某种操作 既然是用Splay来维护，那么Splay本身的操作就很自然地加入到了Link-Cut-Tree中，所以，我们首先需要实现如下操作： is_root(x)操作，判断x是否已经是Splay的根 123inline bool is_root(int x)&#123; return (ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x);&#125; pushup(x)操作，把儿子信息上传到当前点 123inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + 1;//此处维护了子树大小&#125; pushdown(x)操作，把当前点标记下传给儿子 1234567inline void pushdown(int x)&#123; if (rev[x])&#123; swap(ls, rs); rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; &#125;&#125; rotate(x)操作，旋转平衡树的核心操作——旋转，此处不解释 12345678910111213inline void rotate(int x)&#123; int k = x; x = fa[x]; int d = ch[x][1] == k; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125; splay(x)操作，Splay的核心操作——伸展，把某一个点“伸展”到根，其实就是旋转到根的位置 123456789101112131415161718192021222324int st[maxn];int cst = 0;void splay(int x)&#123; int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125;//为了方便我们事先pushdown所有会经过的结点 x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; rotate(x); &#125;&#125; 然后，我们再对常见的树上形态改变操作进行逐个分析： Link(x, y)操作，连接两个不同点 如果直接合并两棵树，那么就可能会导致两棵树的父子关系不匹配（或者说树的方向不一致，可以自行体会） 我们发现，如果要调整父子关系体系使得这两棵树匹配的话，只需要调整其中的一棵就可以，而且为了理顺父子关系，我们肯定需要让连到另一棵树上的这个点成为自己所在树的根，然后连上去 这个操作就是moveroot 所以，我们现在需要实现moveroot，具体该怎么做呢？我们可以分析这个操作，我们需要让这个点先一路连到根，使它和根在同一条链里，也就是同一棵Splay里，然后，我们知道，点的深度决定了点在Splay里的键值，由于我们把一个点设置为根，相当于把这个点到根的路径的深度翻转，也就是把链翻转 而把链翻转，其实就是序列翻转，而这个正好是Splay的标志性操作，我们就可以在Splay中直接翻转这个序列 这样的话，我们在Splay就需要维护反转标记，下传时需要交换左右儿子 但是我们发现，如果我们直接合并所有的从x到根的链，那么会导致一些原来在x下方的点也被包含了进来，这样的话，就会变得比较麻烦，因为这些点是不需要被翻转的，如果保留它们，在最后打翻转标记的时候就需要分裂Splay，那我们不妨一开始就舍弃他们，这样便没有了后顾之忧 这个合并到根路径上所有链形成新的链的操作就是access 先说一句，合并所有链，指的是在一条链被合并的时候，它不在这条路径上的部分是会被舍弃的，也就是说，我们最后合并完的东西，还是一条链，并且一端为x，另一端为根 在这个操作中，我们需要不断的合并、分裂Splay，但是，我们发现，永远被合并、分裂的部分的深度是从链的底端向上的一部分，而合并也是从底端向下接上一端，这些恰好与Splay合并、分裂不相交序列的经典操作吻合（总之Splay无限好，看起来就像是专门为了LCT开发的……），所以我们只需要直接在Splay上操作就可以了，代码如下： 12345678910void access(int x)&#123; int tem = 0; while (x)&#123; splay(x); rs = tem; pushup(x); tem = x; x = fa[x]; &#125;&#125; 具体来说就是不断先把当前点旋到根，然后连接上新的右子树，然后爬向父亲，如此往复直到原树树根 这样，我们解决了access操作 回到moveroot，我们显然是要先进行一次access，然后翻转这棵Splay，那么这个也是Splay基础操作，我们把要打标记的那个点Splay到根，然后直接打上反转标记即可12345void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125; 这样moveroot也解决了 回到Link操作，我们也就是需要把其中一个点x设置为根，即moveroot(x)，然后直接把它连到另一个点上，即fa[x] = y，由于每个点维护的是Splay树中的信息，而x与y之间的边不在Splay中，所以不必更新y的任何信息（但是后文要讲的就不是这样(^_^) ……） 1234void link(int x, int y)&#123; moveroot(x); fa[x] = y;&#125; 这样Link操作就被我们解决了 还有一个操作，因为既然有Link，那么一定有Cut对吧，这样才是Link-Cut-Tree嘛 Cut还要用到一个额外的操作，但是一会再说… Cut(x, y)操作，断开x与y在原树上的连接 我们先假设x与y之间存在这条边 我们发现，我们很难直接Cut掉两个点之间的连接，因为它们要么在同一棵Splay里，要么不在，如果在的话，由于我们把链放在了Splay中，所以它们之间不一定有边相连，位置关系也很难确定，不在一棵Splay中则更是如此 那么，我们首先要做的，是舍弃不在同一棵Splay中的情况，就是把它们两个放在一条链里，而我们现在有的操作，只有moveroot和access，能不能通过这两个操作实现这一目的呢？这是可以的 我们先moveroot(y)，然后access(x)，这样x，y就很自然地在同一条链上了 那么，在同一条链上以后呢？此时x, y在Splay里面的位置关系是未知的，我们要把情况归一来方便处理，那么我们可以splay(x)，这样就整洁多了 由于x, y之间有边，y还是树根，那么x左子树里肯定只有一个点，那就是y，这时候，我们就可以放心的断开这条边啦，即fa[y] = ch[x][0] = 0，但是因为这样做改变了Splay的形态，所以我们需要对x进行一下pushup(x)操作 12345void cut(int x, int y)&#123; split(x, y); fa[y] = ls = 0; pushup(x);&#125; 下面只剩下最后的一个部分啦，那就是链修改与查询的相关操作，无论是哪一种，为了正确地处理问题，我们都需要单独将这条链提取出来，其实就是直接类比Splay里面的修改与查询，这样，我们就还需要一种操作，那就是提取特定链 split(x, y)操作，将x到y的链提取出来放进一棵Splay中维护，并且为了处理修改与查询，使x为Splay的根 这样，我们需要做的，就是把x, y放进一棵Splay，等等，这个和刚才Cut时的操作有点像啊？ 其实就是一个操作，我们先moveroot(y)，然后access(x)，最后再splay(x)，这就是split(x, y)的全部操作 12345void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125; 所以，Cut中的操作，事实上是先提取链，然后断开连接 这样，我们每次修改与查询的时候，直接作用于被操作链的Splay根就可以了，因为这棵Splay本身就是这条被操作链 下面再讲一个东西，就是高鲁棒性的Link-Cut-Tree操作： 有的时候，我们会Link两个已经连通的点，此时我们需要忽略此操作（后文有些时候就不会忽略），还有的时候，我们会Cut两个没有边直接相连的点，这时我们也需要忽略，那么这样该怎么做呢？ 我们再加入一个操作： check(x, y)操作，检查两个点是否已经连通 具体做法应该很简单了吧，我们直接access(x)，然后splay(x)，然后一直向左跳找到原树树根，对y也这样做，然后看这两个树根是否相同即可 123456789bool check(int x, int y)&#123; access(x); splay(x); while (ls) x = ls; int f1 = x; x = y; access(x); splay(x); while (ls) x = ls; return f1 == x;&#125; 但是常常会有另一种写法，那就是直接从这个点开始暴力跳父亲，跳到树根，这样好像也挺正确的 实际上，我们最好不要这样写，虽然这样比较简便，但是这样做实际上是无法获得复杂度保证的，是一种错误的写法（个人认为） 关于LCT的复杂度，下面会提到 然后，对于Link，我们事先check一下x, y就可以了 12345void link(int x, int y)&#123; if (check(x, y)) return; moveroot(x); fa[x] = y;&#125; 对于Cut，我们也是要先Check一下，但是两个点即使在同一棵树里也不一定有边直接相连，所以，我们需要在split(x, y)以后，判断y的左右儿子是否存在，只要有一个存在，都是需要直接return掉的 1234567void cut(int x, int y)&#123; split(x, y); if (ls == y &amp;&amp; !ch[y][0] &amp;&amp; !ch[y][1])&#123; fa[y] = ls = 0; pushup(x); &#125;&#125; 至于为什么，可以自己思考一下 关于LCT的复杂度证明，首先用到的是Splay的均摊复杂度证明，这个可以证明是$O(\log n)$的，然后，对于LCT的access操作来说（因为别的操作都由此衍生，所以只分析这个就可以了），可以证明是一种差分相加的形式，最后可以势能分析仍然是$O(\log n)$的，这也就解释了为什么我认为暴力跳父亲是错误写法，因为这样失去了势能分析的前提条件 模板汇总一下，板子大概就是这个样子的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118int ch[maxn][2];int val[maxn];int sum[maxn];int fa[maxn];bool rev[maxn];bool is_root(int x)&#123; return (ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x);&#125;void pushup(int x)&#123; sum[x] = sum[ls] + sum[rs] + val[x];&#125;void pushdown(int x)&#123; if (rev[x])&#123; swap(ls, rs); rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; &#125;&#125;void rotate(int x)&#123; int k = x; x = fa[x]; int d = ch[x][1] == k; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;int st[maxn];int cst = 0;void splay(int x)&#123; int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125;//为了方便我们事先pushdown所有会经过的结点 x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; rotate(x); &#125;&#125;void access(int x)&#123; int t = 0; while (x)&#123; splay(x); rs = t; pushup(x); t = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;bool check(int x, int y)&#123; access(x); splay(x); while (ls) x = ls; int f1 = x; x = y; access(x); splay(x); while (ls) x = ls; int f2 = x; return f1 == f2;&#125;void link(int x, int y)&#123; if (check(x, y)) return; moveroot(x); fa[x] = y;&#125;void cut(int x, int y)&#123; split(x, y); if (ls == y &amp;&amp; !ch[y][0] &amp;&amp; !ch[y][1])&#123; fa[y] = ls = 0; pushup(x); &#125;&#125;void modify(int x, int y)&#123; splay(x); val[x] = y;&#125;int get(int x, int y)&#123; split(x, y); return sum[x];&#125; 这个有两种操作，一个是单点修改，一个是链查询 例题既然都讲到这里了，那就放几道例题吧，一句话题解采用白色字体 BZOJ 2631: tree 基础标记下传LCT，正常搞就好了 题解 BZOJ 3282: Tree 基础LCT，正常搞就好了 题解 BZOJ 1180: [CROATIAN2009]OTOCI 高鲁棒性LCT 题解 BZOJ 2002: [Hnoi2010]Bounce 弹飞绵羊 稍微有一点思考难度的LCT（其实一点也没有…）但是这题还可以分块做 易错点 pushdown操作中，除了交换子树以外不可以将信息延迟更新，比如链加操作，必须在接收到add标记以后就立刻更新sum, mx, mi等信息，而rev标记不需要，但是如果rev标记也采用这种及时更新信息的方法，那么注意是否交换子树不取决于当前的rev标记，而在于传递的标记值 如果有Splay的其他操作，比如找第K大这种需要从根向下游历的操作，必须沿路进行pushdown操作，因为不这样做无法保证左右子树的正确性和信息正确性。这种错误往往非常隐蔽，一定要小心！ 在Splay中进行了查询某个点的操作以后，为了保证时间复杂度，必须将这个点Splay到根，这其实是Splay的有关内容，在那个里面也算是一个易错点吧 在注意Splay中预先pushdown时，最后到根的那个点也要加入栈中，而且在Splay时，不能因为当前点已经是根就直接不执行Splay操作，因为这样会影响access中的子树交换正确性 寻找当前原树树根的方法必须采用上文讲述的方法 注意Splay中每次需要rotate的点 注意pushup的时候要算上自己的信息 rotate时需要判断被rotate的点的父亲是否为Splay的根 注意题目中对Link, Cut操作鲁棒性的要求 后记那么，本章就到此结束啦！对于LCT来说，把基本的概念理解的十分透彻是一件十分重要的事，因为所有的LCT题目都离不开对基本结构的理解与分析 Link-Cut-Tree维护边信息讲解我们都知道，树上不只是有点，还是有边的，而边上往往也会负载许多的信息，比如长度什么的 在树链剖分中，我们常用的做法是把边信息下放到深度较大的那一端上，这样是正确的，而且维护起来十分方便 但是在LCT中，由于父子关系时常发生变化，所以，这样做很难维护正确性，我们必须考虑使用其他的方法 既然LCT维护点信息十分方便，那么我们为什么不将边信息转化为点信息呢？考虑到图论中常用的加点法，我们可以把每一条边都看成点，然后这个新点向原来的两端连边，然后，我们把边信息附着在这个点上，我们就可以维护边信息啦 当然，还有不用加点的方法，在neither_nor的博客中被提到了，那个方法比较复杂，所以像我这么菜肯定是不会的啦O(∩_∩)O！ 其实就是这么点东西…… 这样，我们就可以解决许多的问题了，比如动态最小生成树，线段树分治套最小生成树……之类的 模板有一道十分经典的题目，那就是[Noi2014]魔法森林这道题，相信很多人都是使用什么动点SPFA这种暴力的方法过的是吧…… 我们就以它为例吧！ 具体方法大家是不是都会…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 300005 #define INF 2000000005#define ls ch[x][0]#define rs ch[x][1]#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;struct edge&#123; int x, y, va, vb; edge(int x = 0, int y = 0, int va = 0, int vb = 0) : x(x), y(y), va(va), vb(vb)&#123;&#125;&#125;e[maxn &lt;&lt; 1];bool cmp(edge a, edge b)&#123; return (a.va != b.va) ? a.va &lt; b.va : a.vb &lt; b.vb;&#125;int ch[maxn][2];int mx[maxn];int val[maxn];int fa[maxn];bool rev[maxn];stack&lt;int&gt; s;void pushup(int x)&#123; mx[x] = x; if (val[mx[ls]] &gt; val[mx[x]]) mx[x] = mx[ls]; if (val[mx[rs]] &gt; val[mx[x]]) mx[x] = mx[rs];&#125;void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; swap(ls, rs); rev[x] = 0; &#125;&#125;bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;void rotate(int x, int d)&#123; int k = ch[x][d]; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k); &#125;void splay(int x)&#123; int tem = x; while (!is_root(x))&#123; s.push(x); x = fa[x]; &#125; s.push(x); while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = tem; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = ch[f1][1] == x; if (!is_root(f1))&#123; int f2 = fa[f1]; int d2 = ch[f2][1] == f1; if (d1 ^ d2) rotate(f1, d1), rotate(f2, d2); else rotate(f2, d2), rotate(f1, d1); &#125; else rotate(f1, d1); &#125;&#125;void access(int x)&#123; int tmp = 0; while (x)&#123; splay(x); rs = tmp; pushup(x); tmp = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;void link(int x, int y)&#123; moveroot(x); fa[x] = y;&#125;void cut(int x, int y)&#123; split(x, y); fa[y] = ls = 0; pushup(x);&#125;int get_max_point(int x, int y)&#123; split(x, y); return mx[x];&#125;bool check(int x, int y)&#123; access(x), splay(x); while (ls) x = ls; int f1 = x; x = y; access(x), splay(x); while (ls) x = ls; return f1 == x;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("magic.in", "r", stdin); #endif int x, y, z, w; read(n), read(m); rep(i, 1, m)&#123; read(x), read(y), read(z), read(w); e[i] = edge(x, y, z, w); &#125; //rep(i, 1, n) val[i] = 0; sort(e + 1, e + 1 + m, cmp); rep(i, 1, m) val[i + n] = e[i].vb;//Link-Cut-Tree上维护的是B的有关信息 int ans = INF; rep(i, 1, m)&#123; x = e[i].x, y = e[i].y, z = e[i].va, w = e[i].vb; if (!check(x, y)) &#123; link(x, i + n); link(y, i + n); &#125; else&#123; int k = get_max_point(x, y); if (val[k] &gt; w) &#123; cut(k, e[k - n].x); cut(k, e[k - n].y); link(x, i + n); link(y, i + n); &#125; &#125; if (check(1, n))&#123; int k = get_max_point(1, n); ans = min(ans, val[k] + z); &#125; &#125; if (ans == INF) printf("-1"); else printf("%d", ans); return 0;&#125; 例题 BZOJ 3669: [Noi2014]魔法森林 UOJ #274. 【清华集训2016】温暖会指引我们前行 好像和普通的最大生成树没什么区别…正常做就好 题解 易错点 最主要的易错点，就是由于加点而引起的点数增多，这常常会被忽略而导致严重的问题，我们要时刻考虑这个问题 后记这就是一个常用的技巧，其实没什么难的…… Link-Cut-Tree维护子树信息讲解不错，终于到了这里了～ 这个技巧是相对来说有点难度的（其实也没有……），我们知道LCT本身其实是很难维护子树信息的，因为它的维护对象是树上的链剖分，也就是一条一条的链 我们发现，一个点的子树，会包含什么？ 显然这个点在某个链剖分上，所以，它一定会包含自己所在链的下面的点的各自的子树，以及它自己的不在链上的子树 这样，我们可以子树信息分为三部分，一个是实子树信息，就是Splay上的LCT子树信息，另一个是虚子树信息，就是自己的不在链上的点的LCT子树信息，第三个，就是前面提到的LCT子树信息，一个点的LCT子树信息，就是它的实子树信息与虚子树信息之和 看起来比较乱是不是 我们发现，一个点如果不是链上的最底端的点，那么它所包含的也会有自己下面的链上的其他点的信息，而这样是很难维护的，我们要做的就是把这个点下面的链上点都与他断开 模板 例题 易错点 Link-Cut-Tree高级应用 前言 例题 易错点]]></content>
      <tags>
        <tag>LCT</tag>
        <tag>重要文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4530: [Bjoi2014]大融合]]></title>
    <url>%2F2018%2F01%2F13%2FBZOJ-4530-Bjoi2014-%E5%A4%A7%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[引言BZOJ 4530: [Bjoi2014]大融合 题解 BZOJ 4530: [Bjoi2014]大融合 Time Limit: 10 Sec Memory Limit: 256 MB Description小强要在N个孤立的星球上建立起一套通信系统。这套通信系统就是连接N个点的一个树。这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。 例如，在上图中，现在一共有了5条边。其中，(3,8)这条边的负载是6，因为有六条简单路径2-3-8,2-3-8-7,3-8,3-8-7,4-3-8,4-3-8-7路过了(3,8)。现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。 Input第一行包含两个整数N,Q，表示星球的数量和操作的数量。星球从1开始编号。接下来的Q行，每行是如下两种格式之一：A x y 表示在x和y之间连一条边。保证之前x和y是不联通的。Q x y 表示询问(x,y)这条边上的负载。保证x和y之间有一条边。1≤N,Q≤100000 Output对每个查询操作，输出被查询的边的负载。 Sample Input8 6 A 2 3 A 3 4 A 3 8 A 8 7 A 6 5 Q 3 8 Sample Output6 Source鸣谢佚名上传 题目分析LCT维护子树信息，当然也可以用离线树链剖分来搞 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cassert&gt; //#define TEST#define maxn 200005#define ls ch[x][0]#define rs ch[x][1]#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int siz[maxn];int vsiz[maxn];int fa[maxn];int ch[maxn][2];bool rev[maxn];void debug()&#123; rep(x, 0, n)&#123; printf("#%d : siz = %d, vsiz = %d, ls = %d, rs = %d, fa = %d, rev = %d\n", x, siz[x], vsiz[x], ls, rs, fa[x], rev[x]); &#125; printf("\n\n\n");&#125;inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + vsiz[x] + 1;&#125;inline void pushv(int x, int op)&#123; //op == 1 || op == -1 vsiz[fa[x]] += op * siz[x];&#125;inline void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; swap(ls, rs); &#125;&#125;void rotate(int x, int d)&#123; int k = ch[x][d]; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;stack&lt;int&gt; s;void splay(int x)&#123; int t = x; while (!is_root(x))&#123; s.push(x); x = fa[x]; &#125; s.push(x);//Error!!!! while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = ch[f1][1] == x; if (!is_root(f1))&#123; int f2 = fa[f1]; int d2 = ch[f2][1] == f1; if (d1 ^ d2) rotate(f1, d1), rotate(f2, d2); else rotate(f2, d2), rotate(f1, d1); &#125; else rotate(f1, d1); &#125;&#125;void access(int x)&#123; int t = 0; while (x)&#123; splay(x); pushv(rs, 1), pushv(t, -1); rs = t; pushup(x); t = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x), splay(x), rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y), access(x), splay(x);&#125;void link(int x, int y)&#123; moveroot(x), access(y), splay(y); fa[x] = y; pushv(x, 1); pushup(y);&#125;ll get(int x, int y)&#123; split(x, y); int a = vsiz[x] + 1; split(y, x); int b = vsiz[y] + 1; return (ll) a * b;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("comb.in", "r", stdin); #ifdef TEST freopen("comb.out", "w", stdout); #endif #endif int x, y; read(n), read(m); char op; rep(i, 1, m)&#123; op = gc(); while (op != 'Q' &amp;&amp; op != 'A') op = gc(); switch(op)&#123; case 'A': read(x), read(y), link(x, y); break; case 'Q': read(x), read(y), printf("%lld\n", get(x, y)); break; default: assert(false); break; &#125; #ifdef TEST debug(); #endif &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #228. 基础数据结构练习题]]></title>
    <url>%2F2018%2F01%2F13%2FUOJ-228-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[引言UOJ #228. 基础数据结构练习题 题解 UOJ #228. 基础数据结构练习题 sylvia 是一个热爱学习的女孩子，今天她想要学习数据结构技巧。 在看了一些博客学了一些姿势后，她想要找一些数据结构题来练练手。于是她的好朋友九条可怜酱给她出了一道题。 给出一个长度为 $n$ 的数列 $A$，接下来有 $m$ 次操作，操作有三种： 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $A_i+x$。 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $\lfloor \sqrt {A_i} \rfloor$。 对于所有的 $i \in [l,r]$，询问 $A_i$ 的和。 作为一个不怎么熟练的初学者，sylvia 想了好久都没做出来。而可怜酱又外出旅游去了，一时间联系不上。于是她决定向你寻求帮助：你能帮她解决这个问题吗。 输入格式 第一行两个数：$ n, m $。 接下来一行 $ n $ 个数 $A_i$。 接下来 $ m $ 行中，第 $ i $ 行第一个数 $ t_i $ 表示操作类型： 若 $ t_i = 1 $，则接下来三个整数 $ l_i, r_i, x_i $，表示操作一。 若 $ t_i = 2 $，则接下来三个整数 $ l_i, r_i$，表示操作二。 若 $ t_i = 3 $，则接下来三个整数 $ l_i, r_i$，表示操作三。 输出格式 对于每个询问操作，输出一行表示答案。 样例一 input 5 5 1 2 3 4 5 1 3 5 2 2 1 4 3 2 4 2 3 5 3 1 5 output 5 6 样例二 见样例数据下载。 限制与约定 测试点编号$n$ 的规模$m$ 的规模其他约定1$n \leq 3000$$m \leq 3000$234$n \leq 100000$$m \leq 100000$数据随机生成56$t_i \neq 1$78910 对于所有数据，保证有 $1 \leq l_i \leq r_i \leq n,1 \leq A_i,x_i \leq 10^5$ 时间限制：$1\texttt{s}$ 空间限制：$256\texttt{MB}$ 下载 样例数据下载 题目分析首先，这非常显然是一道平摊分析线段树的题对吧……因为有开方这种无法批量快速维护的操作 我们知道，在没有增加的操作的时候，开方的运算量级是$O(\log \log n)$，是极其地小的，可以直接暴力操作 但是这道题有区间加，所以，我们就考虑什么时候我们可以批量更改信息，我们可以维护一个区间的最大值和最小值，显然如果这两个值开方后相同，那么就可以直接区间覆盖对吧 然后，我们可以考虑开方操作分到两边的次数（这意味着我们暴力的量级）， 这说明，当前这个区间的最大值和最小值开方后不相等，但这个差距在经过开方的运算量级这么多次操作以后，这个差距就会被消除掉，而要想再制造出这样的差距，每个差距都需要一次区间加操作，所以暴力是很稳的 但是如果只是这样做其实是不行的，因为当差距为$1$的时候，已经无法再消除的更小了，但是这个时候最大值和最小值的开方也可以不相同啊，比如一个是$n ^ 2 - 1$，另一个是$n ^ 2$。，这样，我们可以这样构造数据，$0$和$1$间隔放置，然后开方操作和区间加65535间隔放置（至于为什么是这个数，请自行思考），这样这个算法就会退化到$O(n ^ 2)$级别 所以，我们只要再特殊判断一下这种坑人的情况就可以了（其实应该很容易想到，因为$1$开多少次方都还是$1$，相等于是差距经过数次开方减少到了边界） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cassert&gt;//#define DEBUG#define maxn 300005#define ll long long int#define llen (mid - l + 1)#define rlen (r - mid)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int a[maxn];ll sum[maxn &lt;&lt; 1];ll mx[maxn &lt;&lt; 1];ll mi[maxn &lt;&lt; 1];ll set[maxn &lt;&lt; 1];ll add[maxn &lt;&lt; 1];int qx, qy;ll qd;void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; mx[o] = max(mx[o &lt;&lt; 1], mx[o &lt;&lt; 1 | 1]); mi[o] = min(mi[o &lt;&lt; 1], mi[o &lt;&lt; 1 | 1]);&#125;void pushdown(int l, int r, int o)&#123; int mid = ((r - l) &gt;&gt; 1) + l, ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (set[o] != -1)&#123; ll k = set[o]; sum[ls] = llen * k, mx[ls] = mi[ls] = set[ls] = k, add[ls] = 0; sum[rs] = rlen * k, mx[rs] = mi[rs] = set[rs] = k, add[rs] = 0; set[o] = -1; &#125; if (add[o])&#123; ll k = add[o]; sum[ls] += llen * k, mx[ls] += k, mi[ls] += k, add[ls] += k; sum[rs] += rlen * k, mx[rs] += k, mi[rs] += k, add[rs] += k; add[o] = 0; &#125;&#125;void init(int l, int r, int o)&#123; set[o] = -1; //add[o] = 0; if (l == r)&#123; mx[o] = mi[o] = sum[o] = a[l]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o);&#125;ll get(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; ll ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;void square(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; int a = (int) sqrt(mx[o]), b = (int) sqrt(mi[o]); if (a == b) &#123; if (add[o] || set[o] != -1) assert(false); set[o] = mx[o] = mi[o] = a; sum[o] = (ll)a * (r - l + 1); &#125; else if (mx[o] == mi[o] + 1)&#123; ll k = a - mx[o]; add[o] += k, mx[o] += k, mi[o] += k; sum[o] += k * (r - l + 1); &#125; else &#123; int mid = ((r - l) &gt;&gt; 1) + l; square(l, mid, o &lt;&lt; 1); square(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o); &#125; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) square(l, mid, o &lt;&lt; 1); if (qy &gt; mid) square(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o);&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; add[o] += qd, mx[o] += qd, mi[o] += qd; sum[o] += (r - l + 1) * qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o);&#125;void debug()&#123; rep(i, 1, n)&#123; qx = qy = i; printf("%lld ", get(1, n, 1)); &#125; printf("\n\n\n");&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("prac.in", "r", stdin); #endif int t; read(n), read(m); rep(i, 1, n) read(a[i]); init(1, n, 1); rep(i, 1, m)&#123; read(t), read(qx), read(qy); switch(t)&#123; case 1: read(qd), modify(1, n, 1); break; case 2: square(1, n, 1); break; case 3: printf("%lld\n", get(1, n, 1)); break; default: break; &#125; #ifdef DEBUG debug(); #endif &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>题解</tag>
        <tag>UOJ</tag>
        <tag>平摊分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #207. 共价大爷游长沙]]></title>
    <url>%2F2018%2F01%2F13%2FUOJ-207-%E5%85%B1%E4%BB%B7%E5%A4%A7%E7%88%B7%E6%B8%B8%E9%95%BF%E6%B2%99%2F</url>
    <content type="text"><![CDATA[引言UOJ #207. 共价大爷游长沙 题解 UOJ #207. 共价大爷游长沙 火车司机出秦川，跳蚤国王下江南，共价大爷游长沙。每个周末，勤劳的共价大爷都会开车游历长沙市。 长沙市的交通线路可以抽象成为一个 $n$ 个点 $n-1$ 条边的无向图，点编号为 $1$ 到 $n$，任意两点间均存在恰好一条路径，显然两个点之间最多也只会有一条边相连。有一个包含一些点对 $(x,y)$ 的可重集合S，共价大爷的旅行路线是这样确定的：每次他会选择 $S$ 中的某一对点 $(x,y)$，并从 $x$ 出发沿着唯一路径到达 $y$。 小L是共价大爷的脑残粉，为了见到共价大爷的尊容，小L决定守在这张图的某条边上等待共价大爷的到来。为了保证一定能见到他，显然小L必须选择共价大爷一定会经过的边——也就是所有共价大爷可能选择的路径都经过的边。 现在小L想知道，如果他守在某一条边，是否一定能见到共价大爷。 然而长沙市总是不断的施工，也就是说，可能某个时刻某条边会断开，同时这个时刻一定也有某条新边会出现，且任意时刻图都满足任意两点间均存在恰好一条路径的条件。注意断开的边有可能和加入的新边连接着相同的两个端点。共价大爷的兴趣也会不断变化，所以S也会不断加入新点对或者删除原有的点对。当然，小L也有可能在任何时候向你提出守在某一条边是否一定能见到共价大爷的问题。你能回答小L的所有问题吗？ 输入格式 输入的第一行包含一个整数 $\mathrm{id}$，表示测试数据编号，如第一组数据的$\mathrm{id} = 1$，样例数据的 $\mathrm{id}$ 可以忽略。hack数据中的 $\mathrm{id}$必须为 $0$ 到 $10$ 之间的整数。hack数据中$\mathrm{id}$的值和数据类型没有任何关系。 输入的第二行包含两个整数 $n, m$，分别表示图中的点数，以及接下来会发生的事件数，事件的定义下文中会有描述。初始时 $S$ 为空。 接下来 $n - 1$ 行，每行两个正整数 $x, y$，表示点 $x$ 和点 $y$ 之间有一条无向边。 接下来 $m$ 行，每行描述一个事件，每行的第一个数 $\mathrm{type}$ 表示事件的类型。 若$\mathrm{type} = 1$，那么接下来有四个正整数$x, y, u, v$，表示先删除连接点$x$和点$y$的无向边，保证存在这样的无向边，然后加入一条连接点$u$和点$v$的无向边，保证操作后的图仍然满足题中所述条件。 若$\mathrm{type} = 2$，那么接下来有两个正整数 $x, y$，表示在 $S$ 中加入点对 $(x, y)$。 若$\mathrm{type} = 3$，那么接下来有一个正整数 $x$，表示删除第 $x$ 个加入 $S$ 中的点对，即在第 $x$ 个 $\mathrm{type} = 2$ 的事件中加入 $S$ 中的点对，保证这个点对存在且仍然在 $S$ 中。 若 $\mathrm{type} = 4$，那么接下来有两个正整数 $x, y$，表示小L询问守在连接点 $x$ 和点 $y$ 的边上是否一定能见到共价大爷，保证存在这样的无向边且此时 $S$ 不为空。 输出格式 对于每个小L的询问，输出“YES”或者“NO”（均不含引号）表示小L一定能或者不一定能见到共价大爷。 样例一 input 0 5 7 1 2 1 3 2 4 1 5 2 1 5 1 1 5 2 5 4 2 5 2 1 4 4 2 5 3 1 4 2 4 output YES NO YES explanation 最开始将点对 $(1,5)$ 加入到 $S$ 中，此时点 $1$ 和点 $5$ 之间的路径是 $1 \rightarrow 5$。 接着将连接点 $1$ 和点 $5$ 的边断开，加入连接点 $2$ 和点 $5$ 的边，我们发现图仍然满足题中所述条件，且点 $1$ 和点 $5$ 之间的路径是 $1 \rightarrow 2 \rightarrow 5$，经过点了 $2$ 和点 $5$ 之间的边，因此第一个询问答案是 YES。 接着将点对 $(1,4)$ 加入到 $S$ 中，点 $1$ 和点 $4$ 之间的路径是 $1 \rightarrow 2 \rightarrow 4$，没有经过点 $2$ 和点 $5$ 之间的边，因此第二个询问答案是 NO。 接着，我们删除了第一个加入到 $S$ 中的点对，也就是点对 $(1,5)$，此时 $S$ 中唯一的点对就是 $(1,4)$，经过了点 $2$ 和点 $4$ 之间的边，因此最后一个询问答案是 YES。 样例二 见样例数据下载。 样例三 见样例数据下载。这组数据中 $\mathrm{type} \ne 1$。 限制与约定 每组测试数据的限制与约定如下所示： 测试点编号 $n$ $m$ $\mathrm{type}=$ 限制与约定 1$n \le 100$$m \le 100$$1,2,3,4$2$n \le 100000$$m \le 300000$$2,4$3 4$2,3,4$56$1,2,3,4$任意时刻 $|S| \le 10$78910 时间限制：$2\texttt{s}$ 空间限制：$512\texttt{MB}$ 来源 matthew99 题解 http://matthew99.blog.uoj.ac/blog/1771 下载 样例数据下载 题目分析这道题，我们发现，由于新增了一个集合，我们很难快速的应对整个集合的批量信息维护要求，因为集合内部有增删操作，外部也有树的形态改变，如果直接维护所有点对形成的链的交，外部形态改变可能会影响到所有的集合内的元素，所以这样就十分地差 我们发现，主要问题是维护链交很难同时维护所有集合内的点对的有关信息，因此我们现在想要做的，就是用一种方法快速地包含集合内的信息，同时在外部形态改变的时候不会受到太大影响（最好是无影响），能够快速反映这种变化 我们知道，如果一条边满足题目的条件，那么我们可以发现，这条边两端的每个子树中，一定包含每个点对中的恰好一个点，其他的情况都不成立 只包含一次的时候才计算，二次或是不出现都不计算，这让我们想到什么？没错，那就是异或运算！ 进一步，由于我们要快速包含所有信息，而异或也正可以尽可能多地包含所有的原有信息，并且运算方便快捷 通过异或，我们可以联想异或的有关应用，我们常常使用异或值的相等关系来进行等价性判定，这就是Hash的思想 我们知道，在字符串中，我们有一种方法叫做Hash，我们在改变字符串的时候，Hash很容易维护，而用Hash来进行相等判断，只需要$O(1)$的时间，我们可以考虑这样做 我们为每一个点对随意赋上一个权值，然后，我们维护每个点里面的所有点的权值的子树异或和，使用经典的LCT维护子树方法即可做到这一点 在判定时，我们维护一个当前集合内所有点对的异或和，然后直接比较这条边的某一个端点的子树异或和是否与之相等即可 注意，随机权值在int范围内时会被hack，需要增大随机范围到long long int方可通过本题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;//#define DEBUG#define maxn 200005#define INF 2000000005#define ls ch[x][0]#define rs ch[x][1]#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;ll all = 0;ll val[maxn];ll sum[maxn];ll vsum[maxn];int fa[maxn];int ch[maxn][2];bool rev[maxn];inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;inline void pushup(int x)&#123; sum[x] = vsum[x] ^ sum[ls] ^ sum[rs] ^ val[x];&#125;inline void pushv(int x)&#123; vsum[fa[x]] ^= sum[x];&#125;inline void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; swap(ls, rs); rev[x] = 0; &#125;&#125;inline void rotate(int x)&#123; int k = x; x = fa[x]; if (!x) return; fa[k] = fa[x]; int d = ch[x][1] == k; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;int st[maxn];int cst = 0;void splay(int x)&#123; if (!x) assert(false); int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if (!x) assert(false); if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; if (!x) assert(false); rotate(x); &#125;&#125;void access(int x)&#123; int t = 0; while (x)&#123; splay(x); pushv(rs), pushv(t); rs = t; pushup(x); t = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;void cut(int x, int y)&#123; split(x, y); ls = fa[y] = 0; pushup(x);&#125;void link(int x, int y)&#123; moveroot(y); moveroot(x); fa[x] = y; pushv(x);&#125;void modify(int x, ll y)&#123; access(x), splay(x); val[x] ^= y;&#125;void get(int x, int y)&#123; moveroot(y); access(x); int f1 = ((vsum[x] ^ val[x]) == all); moveroot(x); access(y); int f2 = ((vsum[y] ^ val[y]) == all); if (f1 ^ f2) assert(false); if (f1) printf("YES\n"); else printf("NO\n");&#125;struct ele&#123; int x, y; ll z; ele(int x = 0, int y = 9, ll z = 0) : x(x), y(y), z(z)&#123;&#125;&#125;save[maxn];int cnt = 0;int main()&#123; #ifndef ONLINE_JUDGE freopen("changsha.in", "r", stdin); #endif int x, y, op; ll z; read(n); read(n), read(m); rep(i, 1, n - 1) read(x), read(y), link(x, y); rep(i, 1, m)&#123; read(op); switch(op)&#123; case 1: read(x), read(y), cut(x, y), read(x), read(y), link(x, y); break; case 2: read(x), read(y); z = (ll)rand() * rand(); modify(x, z), modify(y, z), save[++cnt] = ele(x, y, z), all ^= z; break; case 3: read(x), modify(save[x].x, save[x].z), modify(save[x].y, save[x].z), all ^= save[x].z; break; case 4: read(x), read(y), get(x, y); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Hash</tag>
        <tag>LCT</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #274. 【清华集训2016】温暖会指引我们前行]]></title>
    <url>%2F2018%2F01%2F13%2FUOJ-274-%E3%80%90%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%E3%80%91%E6%B8%A9%E6%9A%96%E4%BC%9A%E6%8C%87%E5%BC%95%E6%88%91%E4%BB%AC%E5%89%8D%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[引言UOJ #274. 【清华集训2016】温暖会指引我们前行 题解 UOJ #274. 【清华集训2016】温暖会指引我们前行 寒冬又一次肆虐了北国大地 无情的北风穿透了人们御寒的衣物 可怜虫们在冬夜中发出无助的哀嚎 “冻死宝宝了！” 这时 远处的天边出现了一位火焰之神 “我将赐予你们温暖和希望！” 只见他的身体中喷射出火焰之力 通过坚固的钢铁，传遍了千家万户 这时，只听见人们欢呼 “暖气来啦！” 任务描述 虽然小R住的宿舍楼早已来了暖气，但是由于某些原因，宿舍楼中的某些窗户仍然开着（例如厕所的窗户），这就使得宿舍楼中有一些路上的温度还是很低。 小R的宿舍楼中有$n$个地点和一些路，一条路连接了两个地点，小R可以通过这条路从其中任意一个地点到达另外一个地点。但在刚开始，小R还不熟悉宿舍楼中的任何一条路，所以他会慢慢地发现这些路，他在发现一条路时还会知道这条路的温度和长度。每条路的温度都是互不相同的。 小R需要在宿舍楼中活动，每次他都需要从一个地点到达另一个地点。小R希望每次活动时经过一条最温暖的路径，最温暖的路径的定义为，将路径上各条路的温度从小到大排序后字典序最大。即温度最低的路温度尽量高，在满足该条件的情况下，温度第二低的路温度尽量高，以此类推。小R不会经过重复的路。由于每条路的温度互不相同，因此只存在一条最温暖的路径。 对于小R的每次活动，你需要求出小R需要走过的路径总长度。如果小R通过当前发现的路不能完成这次活动，则输出 $-1$。 注意本题中的字典序与传统意义上的字典序定义有所不同，对于两个序列$a,b(a \neq b)$，若$a$是$b$的前缀则$a$的字典序较大，同时可以推出空串的字典序最大。 输入格式 第一行两个正整数 $n,m$。表示小R的宿舍楼中有 $n$ 个地点，共发生了 $m$ 个事件。 接下来 $m$ 行，每行描述一个事件，事件分为三类。 $\texttt{find id u v t l}$ 表示小R发现了一条连接$u$和$v$之间的路，编号为$id$。相同$id$的边只会出现一次。 $\texttt{move u v}$ 表示小R要从$u$到达$v$，你需要计算出最温暖的路径的长度 ，若不能从$u$到达$v$，则输出$-1$。 $\texttt{change id l}$ 表示从$u$到$v$这条边的长度变为了$l$（保证在当前时间点这条边存在）。 输出格式 对于每个询问，输出一行整数，表示最温暖的路径长度。 样例一 input 8 19 find 0 0 2 7 2 find 1 2 4 4 4 find 2 4 6 10 1 find 3 6 7 8 6 move 2 7 move 1 6 find 4 2 5 3 4 move 0 5 change 0 12 find 5 4 5 5 10 find 6 2 3 6 9 move 3 5 find 7 0 1 12 1 move 1 6 find 8 1 7 11 100 move 1 6 move 3 7 move 5 6 move 2 2 output 11 -1 6 23 18 106 122 11 0 样例二 input 15 45 find 0 1 0 8 5987 find 1 2 0 14 5455 find 2 3 0 27 8830 find 3 4 3 42 7688 find 4 5 0 25 1756 find 5 6 5 35 1550 find 6 7 4 43 9440 move 3 9 change 2 9113 move 10 13 move 3 3 move 11 10 find 7 8 7 6 7347 find 8 9 8 26 8935 move 8 4 change 3 4466 find 9 10 9 28 8560 move 6 5 find 10 11 10 31 6205 change 9 9228 find 11 12 10 23 948 find 12 13 12 45 5945 move 0 9 move 2 5 change 2 6118 find 13 14 13 12 6906 move 4 1 change 2 504 find 14 4 2 22 9796 move 10 7 move 1 14 move 13 3 find 15 12 9 39 8985 find 16 9 8 17 3710 change 1 5370 find 17 1 0 36 4669 find 18 7 6 37 8087 move 9 0 find 19 14 9 33 8234 find 20 0 4 24 5209 change 1 4883 find 21 6 3 9 2461 find 22 5 2 19 4291 change 1 7219 change 6 4846 output -1 -1 0 -1 16787 1550 39301 7211 16571 25510 59706 46309 30692 样例三 见样例数据下载 限制与约定 对于find操作：$(0\le id\lt m, 0\le u,v \lt n, u\ne v,0\le t\le 1000000000, 0 \le l \le 10000)$； 对于move操作：$(0\le u,v \lt n)$； 对于change操作：$(0 \le l \le 10000)$。 对于100%的数据，$1\le n\le 100000, 1\le m \le 300000$ 。 本题共有20个数据点，每个数据点5分。 测试点$n$$m$$其它$$1-2$$\leq20$$\leq50$无特殊约定$3-5$$\leq1000$$\leq3000$$6-10$$\leq100000$$\leq300000$所有的find事件都在move事件之前，且没有change事件$11-14$所有的find事件都在move事件之前$15-20$无特殊约定 时间限制：$2\texttt{s}$ 空间限制：$512\texttt{MB}$ 下载 样例数据下载 题目分析这道题，我们显然是要先维护一下当前温度的最大生成树，然后不断地向里面加边，替换已有的边，然后回答询问，大概就是这样的一个思路 我们发现，要查询和要维护的信息都在边上，但是LCT很难直接维护边信息，怎么办呢？可以使用加点法 我们新加入一些点，这些点的信息就是对应的边上的信息，就是说，我们是用这些新加入的点来代替原来的边的，假设原来的边的两端为$x$和$y$，那么这个新点就再和$x$, $y$连边即可 然后就和普通的LCT一样了，维护一下当前子树中点权最小的那个点即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;#define maxn 600005 #define INF 2000000005#define ls ch[x][0]#define rs ch[x][1]#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)using namespace std;int n, m;struct edge&#123; int x, y, t, l; edge(int x = INF, int y = INF, int t = INF, int l = INF) : x(x), y(y), t(t), l(l)&#123;&#125;&#125;e[maxn];int num[maxn];int val[maxn];int sum[maxn];int fa[maxn];int ch[maxn][2];bool rev[maxn];bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;inline void pushup(int x)&#123; sum[x] = sum[ls] + sum[rs] + val[x]; num[x] = x; if (e[num[ls]].t &lt; e[num[x]].t) num[x] = num[ls]; if (e[num[rs]].t &lt; e[num[x]].t) num[x] = num[rs];&#125;inline void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; swap(ls, rs); &#125;&#125;void rotate(int x, int d)&#123; //printf("rotate start-----------------------\n"); int k = ch[x][d]; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k); //printf("rotate end-----------------------\n");&#125;stack&lt;int&gt; s;void splay(int x)&#123; //printf("splay start-----------------------\n"); int t = x; while (!is_root(x))&#123; s.push(x); x = fa[x]; if (x == fa[x]) printf("%d", x), assert(false); &#125; s.push(x); while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = ch[f1][1] == x; if (!is_root(f1))&#123; int f2 = fa[f1]; int d2 = ch[f2][1] == f1; if (d1 ^ d2) rotate(f1, d1), rotate(f2, d2); else rotate(f2, d2), rotate(f1, d1); &#125; else rotate(f1, d1); &#125; //printf("splay end-----------------------\n");&#125;void access(int x)&#123; //printf("access start-----------------------\n"); int t = 0; while (x)&#123; splay(x); rs = t; pushup(x); t = x; x = fa[x]; &#125; //printf("access end-----------------------\n");&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;bool check(int x, int y)&#123; access(x), splay(x); while (ls) x = ls; splay(x); int f = x; x = y; access(x), splay(x); while (ls) x = ls; splay(x); return f == x;&#125;int get_edge(int x, int y)&#123; split(x, y); return num[x];&#125;void get_len(int x, int y)&#123; if (!check(x, y)) &#123; printf("-1\n"); return; &#125; split(x, y); printf("%d\n", sum[x]);&#125;void cut(int x, int y)&#123; split(x, y); fa[y] = ls = 0; pushup(x);&#125;void link(int id)&#123; int x = e[id].x, y = e[id].y; if (check(x, y))&#123; int k = get_edge(x, y); if (e[k].t &gt; e[id].t) return; cut(k, e[k].x); cut(k, e[k].y); &#125; sum[id] = val[id] = e[id].l; num[id] = id; moveroot(x); fa[x] = id; moveroot(y); fa[y] = id;&#125;void modify(int id, int len)&#123; access(id); splay(id); val[id] = len;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("warm.in", "r", stdin); #endif char op[15]; int x, y, z, w, id; scanf("%d%d", &amp;n, &amp;m); rep(i, 1, m)&#123; scanf("%s", op); switch(op[0])&#123; case 'f': scanf("%d%d%d%d%d", &amp;id, &amp;x, &amp;y, &amp;z, &amp;w), id += n + 1, x++, y++, e[id] = edge(x, y, z, w), link(id); break; case 'm': scanf("%d%d", &amp;x, &amp;y), x++, y++, get_len(x, y); break; case 'c': scanf("%d%d", &amp;id, &amp;x), id += n + 1, modify(id, x); break; default: assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
        <tag>UOJ</tag>
        <tag>生成树</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3510: 首都]]></title>
    <url>%2F2018%2F01%2F13%2FBZOJ-3510-%E9%A6%96%E9%83%BD%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3510: 首都 题解 BZOJ 3510: 首都 Time Limit: 10 Sec Memory Limit: 256 MB Description在X星球上有N个国家，每个国家占据着X星球的一座城市。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。X星球上战乱频发，如果A国打败了B国，那么B国将永远从这个星球消失，而B国的国土也将归A国管辖。A国国王为了加强统治，会在A国和B国之间修建一条公路，即选择原A国的某个城市和B国某个城市，修建一条连接这两座城市的公路。同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。现在告诉你发生在X星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：1、A x y：表示某两个国家发生战乱，战胜国选择了x城市和y城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。2、Q x：询问当前编号为x的城市所在国家的首都。3、Xor：询问当前所有国家首都编号的异或和。 Input第一行是整数N，M，表示城市数和需要处理的信息数。接下来每行是一个信息，格式如题目描述（A、Q、Xor中的某一种）。 Output输出包含若干行，为处理Q和Xor信息的结果。 Sample Input10 10 Xor Q 1 A 10 1 A 1 4 Q 4 Q 10 A 7 6 Xor Q 7 Xor Sample Output11 1 1 1 2 6 2 HINT对于100%的数据，2&lt;=N&lt;=100000，1&lt;=M&lt;=200000。 题目分析首先这题要我们寻找树的重心，这个是挺有意思的，因为我们知道重心的性质是非常多的，于是我猜想了一个性质，两棵树合并后，重心一定在原来两棵树的重心的路径上 其实也挺显然的，想想重心的递归求法，再结合一下定义就明白了 但是，我们发现，即便如此，我们无法精确地直接求出中心位置（也许可以二分？？不知道），所以，我们可以考虑暴力地移动重心，但是，路径长度是$O(n)$的，这样做时间复杂度无法保证，怎么办呢？ 我们继续研究，发现，中心移动的距离不会超过这两棵树的大小，这非常显然，所以，基于这个思路，我们可以尝试启发式合并，把小树链到大树上然后移动大树的重心，这样，大树移动的步数不会超过$O(小树大小)$，这便是启发式合并了，复杂度$O(nlog ^ 2 n)$ 那么我们要做的，就是用并查集维护每棵树的大小和重心，然后合并以及移动重心 看网上题解都是把点一个一个插入，感觉好傻哦，为什么不直接链到上面然后再移动重心呢？所以，我们先把小树链上去，然后split一下两个重心，然后在这个Splay上不断地找后继，这便是移动重心了 但是，移动需要用到子树大小，我们怎么维护呢？我们知道，在LCT上是可以维护子树大小的，我们可以多记录一个虚子树大小的信息，那么在一个点执行access操作以后，这个点的虚子树大小加一就是原树上的它的子树的大小，但是，在移动中心的时候，我们也不能每次都调用一下access对吧，这样复杂度无法保证，但是我们知道，当前点的下一个点的子树大小，其实就是Splay上这个点的右子树的大小，这个大小包含了所有下面的所有点的实子树加虚子树大小 这样，我们就可以根据这个信息来移动重心了，因为根据前面的性质，我们只需要判断这棵子树大小与整块大小的一半的关系，注意，当存在两个重心时，需要特殊地处理一下 细节其实也挺TM多的…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;//#define DEBUG#define maxn 200005#define INF 2000000005#define ls ch[x][0]#define rs ch[x][1]#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int xorsum = 0;int g[maxn];int ufs[maxn];int sum[maxn];//树的大小int find_root(int x)&#123; return ufs[x] = (x == ufs[x]) ? x : find_root(ufs[x]);&#125;int ch[maxn][2];int fa[maxn];int vsiz[maxn], siz[maxn];bool rev[maxn];void debug(int x)&#123; printf("第%d次操作， 要输出的可真是多啊.....\n", x); rep(i, 1, n) &#123; int k = find_root(i); if (k == i) printf("#%d : ufs = %d, sum = %d, g = %d\n", i, ufs[i], sum[i], g[i]); else printf("#%d : ufs = %d\n", i, ufs[i]); &#125; rep(i, 1, n)&#123; printf("#%d : siz = %d, vsiz = %d, fa = %d, rev = %d, ls = %d, rs = %d\n", i, siz[i], vsiz[i], fa[i], rev[i], ch[i][0], ch[i][1]); &#125; printf("\n\n\n");&#125;inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + vsiz[x] + 1;&#125;inline void pushv(int x, int op)&#123; //op == 1 || op == -1 vsiz[fa[x]] += op * siz[x];&#125;inline void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; swap(ls, rs); &#125;&#125;inline void rotate(int x)&#123; int k = x; x = fa[x]; if (!x) return; fa[k] = fa[x]; int d = ch[x][1] == k; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;int st[maxn];int cst = 0;void splay(int x)&#123; if (!x) assert(false); int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if (!x) assert(false); if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; if (!x) assert(false); rotate(x); &#125;&#125;void access(int x)&#123; int t = 0; while (x)&#123; splay(x); pushv(rs, 1), pushv(t, -1);//Warning!!! rs = t; pushup(x); t = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void merge(int x, int y)&#123; int _x = find_root(x), _y = find_root(y); if (sum[_x] &gt; sum[_y]) swap(_x, _y), swap(x, y);//Error!!!!! sum[_y] += sum[_x]; ufs[_x] = _y; xorsum ^= g[_x] ^ g[_y]; access(y), splay(y);//Error!!! moveroot(x); fa[x] = y; pushv(x, 1); moveroot(g[_y]); access(g[_x]); splay(g[_y]); x = g[_y]; int con = sum[_y] &gt;&gt; 1; g[_y] = INF;//Warning!!! while (1)&#123; pushdown(x); int subtree_siz = siz[rs]; if (subtree_siz &lt; con) break; else if (subtree_siz == con)&#123; if (sum[_y] &amp; 1) break; else g[_y] = x; &#125; x = rs; while (pushdown(x), ls) x = ls;//Error!!!!!!!!! splay(x); &#125; g[_y] = min(g[_y], x); xorsum ^= g[_y];&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("capital.in", "r", stdin); #endif int x, y; read(n), read(m); rep(i, 1, n) ufs[i] = i, g[i] = i, sum[i] = 1, xorsum ^= i; rep(i, 1, m)&#123; char op = gc(); while (op != 'A' &amp;&amp; op != 'X' &amp;&amp; op != 'Q') op = gc(); switch(op)&#123; case 'A': read(x), read(y), merge(x, y); break; case 'Q': read(x), printf("%d\n", g[find_root(x)]); break; case 'X': printf("%d\n", xorsum); break; &#125; #ifdef DEBUG debug(i); #endif &#125; return 0;&#125; 关于代码的细节及坑点可以观察上面的Warning和Error]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>启发式合并</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
        <tag>树的重心</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3779: 重组病毒]]></title>
    <url>%2F2018%2F01%2F13%2FBZOJ-3779-%E9%87%8D%E7%BB%84%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3779: 重组病毒 题解 BZOJ 3779: 重组病毒 Time Limit: 20 Sec Memory Limit: 512 MB Description黑客们通过对已有的病毒反编译，将许多不同的病毒重组，并重新编译出了新型的重组病毒。这种病毒的繁殖和变异能力极强。为了阻止这种病毒传播，某安全机构策划了一次实验，来研究这种病毒。实验在一个封闭的局域网内进行。局域网内有n台计算机，编号为1~n。一些计算机之间通过网线直接相连，形成树形的结构。局域网中有一台特殊的计算机，称之为核心计算机。根据一些初步的研究，研究员们拟定了一个一共m步的实验。实验开始之前，核心计算机的编号为1，每台计算机中都有病毒的一个变种，而且每台计算机中的变种都不相同。实验中的每一步会是下面中的一种操作：1、 RELEASE x在编号为x的计算机中植入病毒的一个新变种。这个变种在植入之前不存在于局域网中。2、 RECENTER x将核心计算机改为编号为x的计算机。但是这个操作会导致原来核心计算机中的病毒产生新变种，并感染过来。换言之，假设操作前的核心计算机编号为y，相当于在操作后附加了一次RELEASE y的操作。根据研究的结论，在植入一个新变种时，病毒会在局域网中搜索核心计算机的位置，并沿着网络中最短的路径感染过去。而第一轮实验揭露了一个惊人的真相：病毒的不同变种是互斥的。新变种在感染一台已经被旧变种感染的电脑时，会把旧变种完全销毁之后再感染。但研究员发现了实现过程中的漏洞。如果新变种在感染过程中尚未销毁过这类旧变种，需要先花费1单位时间分析旧变种，才能销毁。如果之前销毁过这类旧变种，就可以认为销毁不花费时间。病毒在两台计算机之间的传播亦可认为不花费时间。研究员对整个感染过程的耗时特别感兴趣，因为这是消灭病毒的最好时机。于是在m步实验之中，研究员有时还会做出如下的询问：3、 REQUEST x询问如果在编号为x的计算机的关键集合中的计算机中植入一个新变种，平均感染时间为多长。编号为y的计算机在编号为x的计算机的关键集合中，当且仅当从y沿网络中的最短路径感染到核心计算机必须经过x。由于有RECENTER操作的存在，这个集合并不一定是始终不变的。至此，安全机构认为已经不需要实际的实验了，于是他们拜托你编写一个程序，模拟实验的结果，并回答所有的询问。 Input输入的第一行包含两个整数n和m，分别代表局域网中计算机的数量，以及操作和询问的总数。接下来n-1行，每行包含两个整数x和y，表示局域网中编号为x和y的计算机之间有网线直接相连。接下来m行，每行包含一个操作或者询问，格式如问题描述中所述。 Output对于每个询问，输出一个实数，代表平均感染时间。输出与答案的绝对误差不超过 10^(-6)时才会被视为正确。 Sample Input8 6 1 2 1 3 2 8 3 4 3 5 3 6 4 7 REQUEST 7 RELEASE 3 REQUEST 3 RECENTER 5 RELEASE 2 REQUEST 1 Sample Output4.0000000000 2.0000000000 1.3333333333 HINTN &lt; = 1 00 000 M &lt; = 1 00 000 题目分析这道题其实和SDOI2017的树点涂色那道题很像的，只不过多了一个换根操作，实际难度就大幅提升…… 首先，我们知道第一种操作可以类比LCT中的access，所以，我们可以用LCT的树剖分来维护每种颜色的情况，也即，在一条重链里的所有点的颜色是相同的 那么，我们就需要分析题目所求的东西是什么，我们经过分析可以发现，一个点感染到根的时间就等于这个点到根的轻边树加一，那么，我们只需要维护一个点到根经过了多少条轻边就可以了 联想边的轻重转换，我们知道，一条边的转换，只有可能发生于access操作中，我们还知道，树上信息的维护可以使用DFS序+线段树，因为它支持快速方便的子树修改，如果还有链修改，那么就可以使用树链剖分+线段树，由于access不会涉及链修改，所以也不需要这样做 我们不妨从$1$开始遍历，求出DFS序 具体方法就是我们在每次access切换边的轻重的时候，在这条边下面的子树中进行子树修改，即区间加一或减一，当然，这是正常的情况，由于本题支持换根，所以当一个点$x$为根时，从$x$到$1$的路径上的所有点的子树方向会发生改变（其实不够准确，因为有些子树仍是它的子树，但是请体会精神……)，我们需要考虑这样的情况，更特殊的，当当前点为根的时候，我们需要对整个区间进行操作，而这些如果不特殊判断都是会有问题的 如何讨论情况呢，下面分条阐述： 当前点为根，直接维护一下当前的根是什么就可以了，直接关于整个区间操作 当前点在$1$到根的链上，我们可以用根的DFS序和这个点的DFS序进行比较，看看这个点的是否包含根的，如果是，那么就在链上，否则不在，在此时的父亲的区间补集（最多两个区间）上操作即可 剩下就是正常情况直接搞就可以了，在关于这个点占据的DFS区间上操作即可 那么只剩下一个问题了，就是如何寻找当前树上的父亲，我们需要先把当前点旋到根，然后有两种情况： 当前点有左儿子，那么这个点不是链的顶端，找这条链上的它的前驱即可，注意为了保证时间复杂度，找到了以后要Splay它一下 当前点没有左儿子，这个点是链的顶端，直接返回它的父亲即可 那么，问题就都解决了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define maxn 400005#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() (((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') ch = gc(), f = 0; while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;namespace Tree_Chain_Partition&#123; #define erep(i, x) for (register int i = h[x]; i; i = e[i].next) const int root = 1; struct edge&#123; int next, to; edge(int next = 0, int to = 0) : next(next), to(to)&#123;&#125; &#125;e[maxn &lt;&lt; 1]; int h[maxn], cnt = 1; inline void Add_Edge(int&amp; x, int&amp; y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt; &#125; int fa[maxn]; int siz[maxn]; int son[maxn]; int dfs[maxn]; int idfs[maxn]; int top[maxn]; int d[maxn]; int t = 0; void DFS(int x)&#123; siz[x] = 1; erep(i, x)&#123; int op = e[i].to; if (op == fa[x]) continue; fa[op] = x; d[op] = d[x] + 1; DFS(op); siz[x] += siz[op]; if (siz[op] &gt; siz[son[x]]) son[x] = op; &#125; &#125; void DFS(int x, int tp)&#123; dfs[x] = ++t; idfs[t] = x; top[x] = tp; if (son[x]) DFS(son[x], tp); erep(i, x)&#123; int op = e[i].to; if (op == fa[x] || op == son[x]) continue; DFS(op, op); &#125; &#125; ll sum[maxn &lt;&lt; 1]; int add[maxn &lt;&lt; 1]; int qx, qy, qd; inline void pushup(int&amp; o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; &#125; inline void pushdown(int&amp; l, int&amp; r, int&amp; o)&#123; if (add[o] &amp;&amp; l != r)&#123; int x = add[o]; int mid = ((r - l) &gt;&gt; 1) + l; add[o &lt;&lt; 1] += x, add[o &lt;&lt; 1 | 1] += x; sum[o &lt;&lt; 1] += (ll)(mid - l + 1) * x; sum[o &lt;&lt; 1 | 1] += (ll)(r - mid) * x; add[o] = 0; &#125; &#125; void init(int l, int r, int o)&#123; if (l == r)&#123; sum[o] = d[idfs[l]] + 1; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o); &#125; void Add(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; add[o] += qd; sum[o] += (ll)(r - l + 1) * qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) Add(l, mid, o &lt;&lt; 1); if (qy &gt; mid) Add(mid + 1, r, o &lt;&lt; 1 | 1); pushup(o); &#125; ll get_sum(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; ll ans = 0; if (qx &lt;= mid) ans += get_sum(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get_sum(mid + 1, r, o &lt;&lt; 1 | 1); return ans; &#125; void init()&#123; DFS(1); DFS(1, 1); init(1, n, 1); &#125;&#125;using Tree_Chain_Partition :: init;using Tree_Chain_Partition :: get_sum;using Tree_Chain_Partition :: Add;using Tree_Chain_Partition :: dfs;using Tree_Chain_Partition :: siz;using Tree_Chain_Partition :: qx;using Tree_Chain_Partition :: qy;using Tree_Chain_Partition :: qd;using Tree_Chain_Partition :: Add_Edge;namespace Link_Cut_Tree&#123; #define ls ch[x][0] #define rs ch[x][1] int root; int ch[maxn][2]; int fa[maxn]; bool rev[maxn]; inline bool is_root(int&amp; x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void pushdown(int x)&#123; if (rev[x])&#123; rev[ls] ^= 1, rev[rs] ^= 1; swap(ls, rs); rev[x] = 0; &#125; &#125; inline void rotate(int x)&#123; int k = x; x = fa[x]; fa[k] = fa[x]; int d = ch[x][1] == k; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; &#125; int st[maxn]; int cst = 0; void splay(int x)&#123; int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; rotate(x); &#125; &#125; inline bool judge(int x)&#123;//1 正序，０ 逆序 if (dfs[x] &lt;= dfs[root] &amp;&amp; dfs[root] + siz[root] - 1 &lt;= dfs[x] + siz[x] - 1) return 0; return 1; &#125; void Modify(int x, int op)&#123; if (x == root) qx = 1, qy = n, qd = op, Add(1, n, 1); else if (judge(x)) qx = dfs[x], qy = dfs[x] + siz[x] - 1, qd = op, Add(1, n, 1); else&#123; qx = 1, qy = n, qd = op, Add(1, n, 1); x = fa[x]; qx = dfs[x], qy = dfs[x] + siz[x] - 1, qd = -op, Add(1, n, 1); &#125; &#125; void access(int x)&#123; int t = 0; while (x)&#123; splay(x); int k = rs; if (t) &#123; while (pushdown(t), ch[t][0]) t = ch[t][0]; splay(t); Modify(t, -1); &#125; rs = t; if (k) &#123; while (pushdown(k), ch[k][0]) k = ch[k][0]; splay(k); Modify(k, 1); &#125; t = x; x = fa[x]; &#125; &#125; void moveroot(int x)&#123; access(x); splay(x); root = x; rev[x] ^= 1; &#125; void get_ans(int x)&#123; if (x == root) qx = 1, qy = n, printf("%.10lf\n", (double)1.0 * get_sum(1, n, 1) / n); else if (judge(x)) qx = dfs[x], qy = dfs[x] + siz[x] - 1, printf("%.10lf\n", (double)1.0 * get_sum(1, n, 1) / siz[x]); else&#123; splay(x); qx = 1, qy = n; ll a = get_sum(1, n, 1), b = n; if (ls)&#123; x = ls; while (pushdown(x), rs) x = rs; &#125; else if (fa[x]) x = fa[x]; qx = dfs[x], qy = dfs[x] + siz[x] - 1, a -= get_sum(1, n, 1), b -= siz[x]; printf("%.10lf\n", (double)1.0 * a / b); &#125; &#125;&#125;using Link_Cut_Tree :: access;using Link_Cut_Tree :: moveroot;using Link_Cut_Tree :: get_ans;void Release(int&amp; x)&#123; access(x);&#125;void Recenter(int&amp; x)&#123; moveroot(x);&#125;void Request(int&amp; x)&#123; get_ans(x);&#125; int main()&#123; #ifndef ONLINE_JUDGE freopen("virus.in", "r", stdin); #endif int x, y; read(n), read(m); rep(i, 1, n - 1) read(x), read(y), Add_Edge(x, y); init(); rep(i, 1, n) Link_Cut_Tree :: fa[i] = Tree_Chain_Partition :: fa[i]; Link_Cut_Tree :: root = 1; rep(i, 1, m)&#123; char op = gc(); while (op != 'Q' &amp;&amp; op != 'L' &amp;&amp; op != 'C') op = gc(); switch(op)&#123; case 'L': read(x), Release(x); break; case 'C': read(x), Recenter(x); break; case 'Q': read(x), Request(x); break; default: break; &#125; &#125; return 0;&#125; 然而我还是非常SB的用了树链剖分……]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
        <tag>树链剖分</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3159: 决战]]></title>
    <url>%2F2018%2F01%2F13%2FBZOJ-3159-%E5%86%B3%E6%88%98-md%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3159: 决战 题解 BZOJ 3159: 决战 Time Limit: 10 Sec Memory Limit: 512 MB Description Input第一行有三个整数N、M和R，分别表示树的节点数、指令和询问总数，以及X国的据点。 接下来N-1行，每行两个整数X和Y，表示Katharon国的一条道路。 接下来M行，每行描述一个指令或询问，格式见题目描述。 Output对于每个询问操作，输出所求的值。 Sample Input5 8 1 1 2 2 3 3 4 4 5 Sum 2 4 Increase 3 5 3 Minor 1 4 Sum 4 5 Invert 1 3 Major 1 2 Increase 1 5 2 Sum 1 5 Sample Output0 0 6 3 19 HINT1&lt;=N,M&lt;=50000.且对于运送操作1&lt;=W&lt;=1000 SourceKatharon+#1 题目分析很好的动态树技巧…… 最近写了几发JCY课件上的题，感觉都巨强无比……应该是我太菜了，每道题都差不多写半(half)天 这道题也是如此，我们发现，前几个操作都是动态树的ZZ操作对吧，但是最后一个要我们资磁值的翻转，这就有点为难了，因为我们如果直接在LCT上翻转的话，实际上相当于什么都没有做对吧…… 但如果顺着这个方向想，我们可以发现，之所以在原来的LCT上不能直接翻转，是因为它上面的值和点是对应的，我们翻转只是改变了树的形态，而点与值的对应关系并没有发生改变，而题目的要求，使得我们必须改变这种对应关系，所以，我们可以先考虑在一棵Splay中翻转对应关系，但是这个并不好维护，为什么呢？因为这种翻转是和其他的子树相关联的，比如我现在要在左子树里面查找一个值，而这个值很显然也和其他某个子树有关（如果当前树的值被翻转了），这样这种关系就会过于复杂以至于根本无法维护 那么还可以怎么办呢？我们发现，主要矛盾就在于点与值的捆绑维护，那么我们把它们拆开，分别来维护，不就能够解决这样的问题了吗？ 所以，我们考虑构建两棵LCT，一棵维护结构，而另一棵维护值，注意，此时两棵LCT相同编号的点不一定是对应点，我们不妨称前者为TrueLCT，后者为ValueLCT 我们在执行其他修改操作以及询问操作的时候，我们直接在两棵LCT上同步进行，而在值翻转的时候，我们只翻转ValueLCT上的点 而如何实现同步进行呢？我们知道，为了保证每次操作都能够同步，我们必须保证两棵LCT的每个Splay能够两两对应，而且对应的这两个Splay点数必须相同（内部具体结构不必完全相同），进一步，我们可以知道，这两个对应的Splay，就分别维护了某一特定链的形态和值，也即链上深度排名为$i$的点$x$，在TrueLCT中的对应的点编号就是$x$，而在ValueLCT里面对应的点是它在TrueLCT里面所在Splay对应的ValueLCT里面的Splay的排名为$i$的那个点（好好理解一下～），这样，我们就可以快速的找到一个点的值是多少，而且，通过在两棵LCT上同步进行Split操作，我们也就可以回答链的询问（因为这条链对应的那两棵Splay形态肯定是一致的），所以这种对应是有很大的意义的 我们发现，此时由于两个编号相同的点不一定关联，所以我们首先要在TrueLCT的每棵Splay的根上维护这个根在ValueLCT里面的对应Splay上的某个点（不一定就是根的对应点，只是为了定位所在的Splay，为了方便不妨称为定位点），这样才能够知道每个点的对应点在ValueLCT里面的哪棵Splay上，才能够进行找对应点的操作，而且，定位点信息当且仅当当前这个点是所在Splay的根的时候才有意义 注意，由于ValueLCT服务于TrueLCT，且受TrueLCT支配，所以它的具体形态无关紧要，它上面的Splay之间的具体形态信息可能是错误的，但是这样不会导致问题，因为我们在进行操作时，不会根据ValueLCT的形态来进行操作，而是根据TrueLCT的形态以及实际需要来查找或更新ValueLCT里面的对应Splay的信息，所以ValueLCT里面的具体形态无关紧要 说起来大概就是这么多，下面是每个具体的操作方(xi)法(jie)（其实都是我入的坑……)： 找对应点操作，假设我们要找$x$（在TrueLCT中）的对应点$x’$（在ValueLCT中），我们首先把$x$Splay到根，然后可以直接得到它在Splay中的排名$k$，然后，我们在ValueLCT中把之前提到的定位点Splay到根，然后通过排名$k$在它的子树里面寻找排名为$k$的点即可，最后，为了方便及正确性，我们把$x$的定位点更新为刚找到的它的对应点 access操作，我们可以发现，在这个操作里面我们干的无非就是两件事，一是合并Splay，二是分裂Splay，为了方便我们直接把这两个操作放在一起。假设当前以$x$为根的Splay要合并到$y$点上，$y$要与某个点$z$断开，那么，我们为了同步维护两个LCT里面的Splay形态，我们首先需要找到$x$的对应点$x’$，然后，我们同时断开$x$和$x’$的右儿子与它们各自的连接并连接到新点上即可（把它们的右儿子更新为需要的那个点），注意，由于在TrueLCT中，$x$的右儿子原先不是根，现在成为了新根，为了正确性，我们要更新它的定位点信息为$x’$原来的右儿子，同时，因为ValueLCT上的形态不保证正确，所以，$x’$新接上去的点的父亲不一定是$x’$，我们需要强制地把新连上去的点的父亲更新为$x’$，这个操作里面就是这两个细节 pushdown操作，由于我们现在要维护的信息是需要随时查询的，所以我们不能延迟信息更新，也就是说，在得到标记的那一刻就要更新自己维护的信息，而不是等到下传标记时才更新自己的信息，但是反转标记除外，因为它影响的范围是自己的下一层，在查询到下一层时当前点的标记显然已经下传完毕了，所以就不会有什么影响，注意，我们在TureLCT上维护的标记只有反转标记，信息只有左右儿子，父亲，子树大小以及定位点，剩下的都交给ValueLCT维护 rotate操作（只限于TrueLCT），我们为了保证定位点信息的正确性，需要在rotate时更新，比如现在已知单/双旋一次之后这个点就会成为根，那么我们就需要把根的定位点信息传给这个点，在ValueLCT里面就无所谓了 splay操作，其实由于没有严格限制，所以无所谓，但是为了严密性，我们最好同时对两棵LCT中的点进行Splay，也就是说，在对一个点进行Splay以后（TrueLCT中），最好把它的对应点（ValueLCT中）也Splay一下，这样处理较为方便 moveroot, split以及修改查询等操作，正常做就可以了，注意修改查询要保证当前的点（ValueLCT中）为所在Splay的根，这也就是为什么上面的Splay操作最好那样写 其实全都是TMD细节，就这一道题，先是写了一份一千多行的代码，结果因为没维护定位点所以错了(我本以为可以不维护这东西）……后来重新写了一份三百多行的，又调了大半天……才TMD过 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#define maxn 100005#define ls ch[x][0]#define rs ch[x][1]#define _ls ch[_x][0]#define _rs ch[_x][1]#define ll long long int#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') ch = gc(), f = 0; while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;namespace TrueLCT&#123; int fa[maxn]; int ch[maxn][2]; bool rev[maxn]; int poi[maxn];//只有Splay树根上的才有意义 int siz[maxn]; inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + 1; &#125; inline void pass(int x, bool r)&#123; rev[x] ^= r; if (r) swap(ls, rs); &#125; inline void pushdown(int x)&#123; if (ls) pass(ls, rev[x]); if (rs) pass(rs, rev[x]); rev[x] = 0; &#125; inline void rotate(int x)&#123; int k = x; x = fa[x]; int d = ch[x][1] == k; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k); &#125; int st[maxn]; int cst = 0; void splay(int x)&#123; int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if (is_root(f2)) poi[x] = poi[f2]; if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); rotate(x); &#125; else rotate(x), poi[x] = poi[f1]; &#125; &#125;&#125;using TrueLCT :: poi;using TrueLCT :: pass;namespace ValueLCT&#123; int mx[maxn]; int mi[maxn]; int val[maxn]; int add[maxn]; ll sum[maxn]; int fa[maxn]; int ch[maxn][2]; bool rev[maxn]; int siz[maxn]; inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + 1; sum[x] = sum[ls] + sum[rs] + val[x]; mx[x] = max(val[x], max(mx[ls], mx[rs])); mi[x] = val[x]; if (ls) mi[x] = min(mi[x], mi[ls]); if (rs) mi[x] = min(mi[x], mi[rs]); &#125; inline void pass(int x, int k, bool r)&#123; mx[x] += k, mi[x] += k, val[x] += k, sum[x] += (ll)siz[x] * k, add[x] += k; rev[x] ^= r; if (r) swap(ls, rs); &#125; inline void pushdown(int x)&#123; if (ls) pass(ls, add[x], rev[x]); if (rs) pass(rs, add[x], rev[x]); add[x] = rev[x] = 0; &#125; inline void rotate(int x)&#123; int k = x; x = fa[x]; int d = ch[x][1] == k; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k); &#125; int st[maxn]; int cst = 0; void splay(int x)&#123; int t = x; while (!is_root(x))&#123; st[++cst] = x; x = fa[x]; &#125; st[++cst] = x; while (cst)&#123; pushdown(st[cst]); cst--; &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; if (!is_root(f1))&#123; int f2 = fa[f1]; if ((ch[f1][1] == x) ^ (ch[f2][1] == f1)) rotate(x); else rotate(f1); &#125; rotate(x); &#125; &#125; int find_by_rank(int rank, int x)&#123; splay(x); while (x)&#123; pushdown(x); int left = (ls) ? siz[ls] : 0; if (rank &lt;= left) x = ls; else if (rank == left + 1) return x; else rank -= left + 1, x = rs; &#125; return -1; &#125;&#125;using ValueLCT :: add;using ValueLCT :: mi;using ValueLCT :: mx;using ValueLCT :: sum;using ValueLCT :: pass;int get_value_point(int x)&#123; int _x = ValueLCT :: find_by_rank(TrueLCT :: siz[TrueLCT :: ls] + 1, poi[x]); poi[x] = _x; return _x;&#125;void access(int x)&#123; int t = 0; int _t = 0; while (x)&#123; TrueLCT :: splay(x); int _x = get_value_point(x); ValueLCT :: splay(_x); poi[TrueLCT :: rs] = ValueLCT :: _rs; TrueLCT :: rs = t; ValueLCT :: _rs = _t; ValueLCT :: fa[_t] = _x; TrueLCT :: pushup(x); ValueLCT :: pushup(_x); t = x; _t = _x; x = TrueLCT :: fa[x]; &#125;&#125;int splay(int x)&#123; TrueLCT :: splay(x); int _x = get_value_point(x); ValueLCT :: splay(_x); return _x;&#125;int moveroot(int x)&#123; access(x); int _x = splay(x); pass(x, 1); pass(_x, 0, 1); return _x;&#125;int split(int x, int y)&#123; moveroot(y); access(x); int _x = splay(x); return _x;&#125;void link(int x, int y)&#123; int _x = moveroot(x); TrueLCT :: fa[x] = y; ValueLCT :: fa[_x] = poi[y];&#125;void Add(int x, int y, int z)&#123; int _x = split(x, y); pass(_x, z, 0);&#125;void flip(int x, int y)&#123; int _x = split(x, y); pass(_x, 0, 1);&#125;void get_mx(int x, int y)&#123; int _x = split(x, y); printf("%d\n", mx[_x]);&#125;void get_mi(int x, int y)&#123; int _x = split(x, y); printf("%d\n", mi[_x]);&#125;void get_sum(int x, int y)&#123; int _x = split(x, y); printf("%lld\n", sum[_x]);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("war.in", "r", stdin); #endif int x, y, z; read(n), read(m), read(x); rep(i, 1, n) poi[i] = i; rep(i, 1, n - 1) read(x), read(y), link(x, y); rep(i, 1, m)&#123; char op = gc(); while (op != 'M' &amp;&amp; op != 'S' &amp;&amp; op != 'I') op = gc(); switch(op)&#123; case 'I': &#123; op = gc(), op = gc(); read(x), read(y); if (op == 'c') read(z), Add(x, y, z); else if (op == 'v') flip(x, y); else assert(false); break; &#125; case 'S': read(x), read(y), get_sum(x, y); break; case 'M': &#123; op = gc(); read(x), read(y); if (op == 'a') get_mx(x, y); else if (op == 'i') get_mi(x, y); else assert(false); break; &#125; default: assert(false); &#125; &#125; return 0;&#125; namespace和assert大法好啊！！！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原创题目&idea汇总]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%8E%9F%E5%88%9B%E9%A2%98%E7%9B%AE-idea%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[引言记录了一些生活中想出来的小idea什么的…… 由于我比(shi)较(fen)菜，所以大部分的idea我自己并不能够解决，因此数据范围也没有确定……但是请各位不要随手拿去出题什么的，至少告诉我一下…… 反正应该都是些非常菜的东西啦，只是因为我太弱所以才不会…… Renatus的硬币I蒟蒻Renatus有一排$n$个硬币，有一天它发现它们正好全部反面朝上，于是就想用它们玩一个小游戏。这个游戏是这样的，每次Renatus会等概率选择一枚硬币，将它翻面，仅此而已…..因为Renatus太咸鱼了，所以他重复了$m$次这样的操作，最后，他发现好多的硬币仍然是反面朝上的，并且是连续的，于是，他想知道最长的连续反面朝上的硬币串的长度期望是多少？ 输入$n$, $m$，请输出此时的答案 Renatus的硬币II蒟蒻Renatus有一排$n$个硬币，有一天他在桌子上画了许多个圆圈，这些圆圈恰好排成一行，于是就用它们玩了一个小游戏。这个游戏是这样的，每次Renatus会等概率选择一个圆圈，然后放一枚硬币上去（如果上面已经有了硬币，那么就把它堆在那枚硬币上）…..因为Renatus太咸鱼了，所以他重复了$m$次这样的操作，最后，他发现这些硬币堆高低不齐，于是，他想知道在一段区间$[l, r]$中，硬币数最多的那一堆的硬币数的期望是多少，由于Renatus特别ZZ，所以一共有$K$次询问 输入$n$, $m$，$K$, 以及$K$个询问的区间，请输出此时的答案 Renatus的硬币III蒟蒻Renatus有一排$n$个硬币，有一天他在桌子上画了许多个圆圈，这些圆圈恰好排成一行，于是就用它们玩了一个小游戏。这个游戏是这样的，每次Renatus会以一定概率选择某一个圆圈（概率已知），然后放一枚硬币上去（如果上面已经有了硬币，那么就把它堆在那枚硬币上）…..因为Renatus太咸鱼了，所以他重复了$m$次这样的操作，最后，他发现这些硬币堆高低不齐，于是，他想知道在一段区间$[l, r]$中，硬币数最多的那一堆的硬币数的期望是多少，由于Renatus特别ZZ，所以一共有$K$次询问 输入$n$, $m$，以及$n$个圆圈各自被选中的概率$p_i$，保证其和为$1$, 最后是$K$, 以及$K$个询问的区间，请输出此时的答案 总之，我其实就是Renatus啦]]></content>
      <tags>
        <tag>原创题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3589: 动态树]]></title>
    <url>%2F2018%2F01%2F02%2FBZOJ-3589-%E5%8A%A8%E6%80%81%E6%A0%91%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3589: 动态树 题解 BZOJ 3589: 动态树 Time Limit: 30 Sec Memory Limit: 1024 MB Description别忘了这是一棵动态树, 每时每刻都是动态的. 小明要求你在这棵树上维护两种事件事件0:这棵树长出了一些果子, 即某个子树中的每个节点都会长出K个果子.事件1:小明希望你求出几条树枝上的果子数. 一条树枝其实就是一个从某个节点到根的路径的一段. 每次小明会选定一些树枝, 让你求出在这些树枝上的节点的果子数的和. 注意, 树枝之间可能会重合, 这时重合的部分的节点的果子只要算一次. Input第一行一个整数n(1&lt;=n&lt;=200,000), 即节点数.接下来n-1行, 每行两个数字u, v. 表示果子u和果子v之间有一条直接的边. 节点从1开始编号.在接下来一个整数nQ(1&lt;=nQ&lt;=200,000), 表示事件.最后nQ行, 每行开头要么是0, 要么是1.如果是0, 表示这个事件是事件0. 这行接下来的2个整数u, delta表示以u为根的子树中的每个节点长出了delta个果子.如果是1, 表示这个事件是事件1. 这行接下来一个整数K(1&lt;=K&lt;=5), 表示这次询问涉及K个树枝. 接下来K对整数u_k, v_k, 每个树枝从节点u_k到节点v_k. 由于果子数可能非常多, 请输出这个数模2^31的结果. Output对于每个事件1, 输出询问的果子数. Sample Input5 1 2 2 3 2 4 1 5 3 0 1 1 0 2 3 1 2 3 1 1 4 Sample Output13 HINT 1 &lt;= n &lt;= 200,000, 1 &lt;= nQ &lt;= 200,000, K = 5. 生成每个树枝的过程是这样的:先在树中随机找一个节点, 然后在这个节点到根的路径上随机选一个节点, 这两个节点就作为树枝的两端. SourceBy 佚名提供 题目分析首先这题神tm动态树 好了我们来说正题…… 这道题我自己想了一下，首先显然是树链剖分对吧……当然也可以改成LCT，这样少一个$log$,也正好能够呼应题目（雾 由于我十分的菜，我看到题目每次同时询问的链的个数不超过$5$，于是我想，这不是和$O(1)$一样的吗……所以我每次对每条链都查询一下就行？ 所以现在的主要问题就是怎么舍去重复的结点，我考虑了一下，我们可以考虑每次查询完一条链以后，把它在线段树上正好覆盖的那些区间的$Sum$信息都设为零，但这样我们在查询到这些节点的下方结点时仍然会计重，那么我就再开一个$Set$标记，表示这个节点是不是已经被设为了$0$，如果我们每次进入了一个节点，发现它有$Set$标记，那么我们就直接退出 由于每次查询涉及的结点数为$O(\log^2 n)$级别的，所以我们上面的操作都是可行的 现在，我们的问题就转化为，如何快速恢复每个被更改节点的信息，以及如何处理信息下传的情况 首先，对于有信息下传的情况，我们可以发现，同时进行查询以及维护信息下传是一件很麻烦的事情，很容易出现问题，所以我们不妨类比LCT中在Splay预先下传所有相关信息的技巧，在最开始先把所有会被影响到的节点的信息都下传完毕，这样就解决了这个问题，而且复杂度也是正确的 这个技巧不妨称为线段树信息下传预处理 其次，对于如何快速恢复每个被更改节点的信息这个问题，我们可以类比回滚的技巧，用一个栈来维护所有的修改，这样，我们就可以把所有结点的$Set$复位，$Sum$复原，这样就可以了，同时由于下面的结点被修改，上面的结点会因信息上传而同样受到影响，所以我们需要把所有经过的结点都复原，但即便如此，复杂度仍然正确，是$O(\log^2 n)$ 这个技巧不妨称为线段树信息回滚 这样，通过这道题，我们就掌握了两种技巧以及其背后的思想，所以这道题目是一道非常优秀的题目 所以我们就完美地解决了这个问题，相关细节可以参考代码 后记去网上baidu了一下题解，发现大家好像都不是我这样做的（捂脸 好像是什么容斥原理+链求交，看了一下觉得也是好有道理的，还顺便学习了一下如何链求交，但是貌似跑起来没有我这个快？ 还有一个技巧就是利用题目中特殊的模数，我们可以用unsigned int直接自然溢出，最后输出答案时再&amp;上一个$2147483647$即可 然而我非常ZZ，并不知道这件事，直接暴力上long long int然后暴力取模…… 优化完一下子从$13196ms$跑到了$8216ms$ O(∩_∩)O~ 总之这道题目确实非常好啊 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cassert&gt;#define maxn 400005#define ll unsigned int#define pil pair&lt;int, ll&gt; #define pii pair&lt;int, int&gt;#define fi first#define se second#define M 2147483647#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int dfs[maxn];int idfs[maxn];int son[maxn];int siz[maxn];int d[maxn];int top[maxn];int fa[maxn];int t = 0;void DFS(int x)&#123; siz[x] = 1; erep(i, x)&#123; int op = e[i].to; if (op == fa[x]) continue; fa[op] = x, d[op] = d[x] + 1; DFS(op); siz[x] += siz[op]; if (siz[op] &gt; siz[son[x]]) son[x] = op; &#125;&#125;void DFS(int x, int tp)&#123; dfs[x] = ++t; idfs[t] = x; top[x] = tp; if (son[x]) DFS(son[x], tp); erep(i, x)&#123; int op = e[i].to; if (op == fa[x] || op == son[x]) continue; DFS(op, op); &#125;&#125;void init()&#123; DFS(1); DFS(1, 1);&#125;ll sum[maxn &lt;&lt; 1];ll add[maxn &lt;&lt; 1];int qx, qy;ll qd;void pushdown(int l, int r, int o)&#123; if (add[o] &amp;&amp; l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; ll&amp; ad = add[o]; add[o &lt;&lt; 1] += ad; add[o &lt;&lt; 1 | 1] += ad; sum[o &lt;&lt; 1] += (mid + 1 - l) * ad; sum[o &lt;&lt; 1 | 1] += (r - mid) * ad; ad = 0; &#125;&#125;void pushup(int l, int r, int o)&#123; if (l == r) return; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void Add(int l, int r, int o)&#123; //printf("------------------------Add------------------------"); pushdown(l, r, o); //printf("------------------------OUTAdd------------------------"); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; add[o] += qd; sum[o] += qd * (r - l + 1); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) Add(l, mid, o &lt;&lt; 1); if (qy &gt; mid) Add(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void Modify(int x, int y)&#123; qx = dfs[x], qy = dfs[x] + siz[x] - 1, qd = y; Add(1, n, 1);&#125;void Pushdown(int l, int r, int o)&#123; //printf("------------------------Pushdown------------------------"); pushdown(l, r, o); //printf("------------------------OUTPushdown------------------------"); if (qx &lt;= l &amp;&amp; r &lt;= qy) return; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) Pushdown(l, mid, o &lt;&lt; 1); if (qy &gt; mid) Pushdown(mid + 1, r, o &lt;&lt; 1 | 1);&#125;bool set[maxn &lt;&lt; 1];stack&lt;pil&gt; s;ll Get(int l, int r, int o)&#123; if (set[o]) return 0; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; ll tem = sum[o]; s.push(pil(o, sum[o])); sum[o] = 0; set[o] = 1; return tem; &#125; int mid = ((r - l) &gt;&gt; 1) + l; ll ans = 0; if (qx &lt;= mid) ans += Get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += Get(mid + 1, r, o &lt;&lt; 1 | 1); s.push(pil(o, sum[o])); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; return ans;&#125;void recover()&#123; while (!s.empty())&#123; pil op = s.top(); s.pop(); sum[op.fi] = op.se; set[op.fi] = 0; &#125;&#125;void Pushdown(int x, int y)&#123; int f1 = top[x], f2 = top[y]; while (f1 != f2)&#123; if (d[f1] &gt; d[f2])&#123; qx = dfs[f1], qy = dfs[x]; Pushdown(1, n, 1); x = fa[f1]; f1 = top[x]; &#125; else&#123; qx = dfs[f2], qy = dfs[y]; Pushdown(1, n, 1); y = fa[f2]; f2 = top[y]; &#125; &#125; qx = dfs[x], qy = dfs[y]; if (qx &gt; qy) swap(qx, qy); Pushdown(1, n, 1);&#125;ll Get(int x, int y)&#123; ll ans = 0; int f1 = top[x], f2 = top[y]; while (f1 != f2)&#123; if (d[f1] &gt; d[f2])&#123; qx = dfs[f1], qy = dfs[x]; ans += Get(1, n, 1); x = fa[f1]; f1 = top[x]; &#125; else&#123; qx = dfs[f2], qy = dfs[y]; ans += Get(1, n, 1); y = fa[f2]; f2 = top[y]; &#125; &#125; qx = dfs[x], qy = dfs[y]; if (qx &gt; qy) swap(qx, qy); ans += Get(1, n, 1); return ans;&#125;pii que[maxn];int ct = 0;void Solve()&#123; ll tot = 0; rep(i, 1, ct) Pushdown(que[i].fi, que[i].se); rep(i, 1, ct) tot += Get(que[i].fi, que[i].se); recover(); printf("%u\n", tot &amp; M);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("dynamic.in", "r", stdin); #endif int x, y, op; read(n); rep(i, 1, n - 1) read(x), read(y), Add_Edge(x, y); init(); read(m); rep(i, 1, m)&#123; read(op); switch(op)&#123; case 0: read(x), read(y), Modify(x, y); break; case 1: read(ct); rep(j, 1, ct) read(x), read(y), que[j] = pii(x, y); Solve(); break; default : assert(false); break; &#125; &#125; return 0;&#125;/*ll _sum[maxn &lt;&lt; 1];stack&lt;pil&gt; s;ll Modify_Get(int l, int r, int o)&#123; pushdown(l, r, o); if (set[o]) return 0; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; set[o] = 1; s.push(o); return sum[o]; &#125; int mid = ((r - l) &gt;&gt; 1) + l; ll ans = 0; if (qx &lt;= mid) ans = (ans + Mod_Get(l, mid, o &lt;&lt; 1)) % M; if (qy &gt; mid) ans = (ans + Mod_Get(mid + 1, r, o &lt;&lt; 1 | 1)) % M; _sum[o] = (_sum[o &lt;&lt; 1] + _sum[o &lt;&lt; 1 | 1]) % M; return ans;&#125;*//*ll Get(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; ll ans = 0; if (qx &lt;= mid) ans = (ans + Get(l, mid, o &lt;&lt; 1)) % M; if (qy &gt; mid) ans = (ans + Get(mid + 1, r, o &lt;&lt; 1 | 1)) % M; return ans;&#125;*/]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>重要文章</tag>
        <tag>树链剖分</tag>
        <tag>容斥原理</tag>
        <tag>状态压缩</tag>
        <tag>好题精选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1180: [CROATIAN2009]OTOCI]]></title>
    <url>%2F2018%2F01%2F02%2FBZOJ-1180-CROATIAN2009-OTOCI%2F</url>
    <content type="text"><![CDATA[引言BZOJ 1180: [CROATIAN2009]OTOCI 题解 BZOJ 1180: [CROATIAN2009]OTOCI Time Limit: 50 Sec Memory Limit: 162 MB Description给出n个结点以及每个点初始时对应的权值wi。起始时点与点之间没有连边。有3类操作： 1、bridge A B：询问结点A与结点B是否连通。如果是则输出“no”。否则输出“yes”，并且在结点A和结点B之间连一条无向边。 2、penguins A X：将结点A对应的权值wA修改为X。 3、excursion A B：如果结点A和结点B不连通，则输出“impossible”。否则输出结点A到结点B的路径上的点对应的权值的和。给出q个操作，要求在线处理所有操作。数据范围：1&lt;=n&lt;=30000, 1&lt;=q&lt;=300000, 0&lt;=wi&lt;=1000。 Input第一行包含一个整数n(1&lt;=n&lt;=30000)，表示节点的数目。第二行包含n个整数，第i个整数表示第i个节点初始时对应的权值。第三行包含一个整数q(1&lt;=n&lt;=300000)，表示操作的数目。以下q行，每行包含一个操作，操作的类别见题目描述。任意时刻每个节点对应的权值都是1到1000的整数。 Output输出所有bridge操作和excursion操作对应的输出，每个一行。 Sample Input5 4 2 4 5 6 10 excursion 1 1 excursion 1 2 bridge 1 2 excursion 1 2 bridge 3 4 bridge 3 5 excursion 4 5 bridge 1 3 excursion 2 4 excursion 2 5 Sample Output4 impossible yes 6 yes yes 15 yes 15 16 题目分析LCT维护动态树+单点修改 就是一个LCT的基本操作，细节可以见代码，本题的强度并没有达到BZOJ3282，如果有兴趣可以去看BZOJ3282题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;#define ls ch[x][0]#define rs ch[x][1]#define maxn 100005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int ch[maxn][2];int val[maxn];int sum[maxn];int fa[maxn];bool rev[maxn];inline void pushup(int x)&#123; sum[x] = sum[ls] + sum[rs] + val[x];&#125;inline void pushdown(int x)&#123; if (rev[x])&#123; swap(ls, rs); rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; &#125;&#125;inline bool is_root(int x)&#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;void rotate(int x, int d)&#123; int k = ch[x][d]; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;stack&lt;int&gt; s;void splay(int x)&#123; int tem = x; while (!is_root(x))&#123; s.push(x); x = fa[x]; &#125; s.push(x); while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = tem; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = ch[f1][1] == x; if (!is_root(f1))&#123; int f2 = fa[f1]; int d2 = ch[f2][1] == f1; if (d1 ^ d2) rotate(f1, d1), rotate(f2, d2); else rotate(f2, d2), rotate(f1, d1); &#125; else rotate(f1, d1); &#125;&#125;void access(int x)&#123; int tem = 0; while (x)&#123; splay(x); rs = tem; pushup(x); tem = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;bool check(int x, int y)&#123; access(x), splay(x); while (ls) x = ls; int f1 = x; x = y; access(x), splay(x); while (ls) x = ls; return f1 == x;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;void get(int x, int y)&#123; if (!check(x, y)) &#123; printf("impossible\n"); return; &#125; split(x, y); printf("%d\n", sum[x]);&#125;void modify(int x, int y)&#123; splay(x); val[x] = y;&#125;void link(int x, int y)&#123; if (check(x, y))&#123; printf("no\n"); return; &#125; moveroot(x); fa[x] = y; printf("yes\n");&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("OTOCI.in", "r", stdin); #endif int x, y; char op; read(n); rep(i, 1, n) read(val[i]); read(m); rep(i, 1, m)&#123; op = gc(); while (!('a' &lt;= op &amp;&amp; op &lt;= 'z')) op = gc(); read(x), read(y); switch(op)&#123; case 'b' : link(x, y); break; case 'p' : modify(x, y); break; case 'e' : get(x, y); break; default : assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3282: Tree]]></title>
    <url>%2F2018%2F01%2F02%2FBZOJ-3282-Tree%2F</url>
    <content type="text"><![CDATA[引言BZOJ 3282: Tree 题解 BZOJ 3282: Tree Time Limit: 30 Sec Memory Limit: 512 MB Description给定Ｎ个点以及每个点的权值，要你处理接下来的Ｍ个操作。操作有４种。操作从０到３编号。点从１到Ｎ编号。 ０：后接两个整数（ｘ，ｙ），代表询问从ｘ到ｙ的路径上的点的权值的ｘｏｒ和。保证ｘ到ｙ是联通的。 １：后接两个整数（ｘ，ｙ），代表连接ｘ到ｙ，若ｘ到Ｙ已经联通则无需连接。 ２：后接两个整数（ｘ，ｙ），代表删除边（ｘ，ｙ），不保证边（ｘ，ｙ）存在。 ３：后接两个整数（ｘ，ｙ），代表将点Ｘ上的权值变成Ｙ。 Input第１行两个整数，分别为Ｎ和Ｍ，代表点数和操作数。 第２行到第Ｎ＋１行，每行一个整数，整数在［１，１０＾９］内，代表每个点的权值。 第Ｎ＋２行到第Ｎ＋Ｍ＋１行，每行三个整数，分别代表操作类型和操作所需的量。 Output对于每一个０号操作，你须输出Ｘ到Ｙ的路径上点权的Ｘｏｒ和。 Sample Input3 3 1 2 3 1 1 2 0 1 2 0 1 1 Sample Output3 1 HINT１＜＝Ｎ，Ｍ＜＝３０００００ Source动态树 题目分析高鲁棒性LCT+单点信息修改 本题我们可以发现，这题的要求是单点修改，同时在加边与删边的时候不保证一定可行，那么我们就需要判断两个节点是否已经联通以及两个节点之间是否直接有边相连 我们首先解决单点修改，我们知道，在Splay上，每个点维护的信息范围都是自己的Splay子树，所以，我们为了方便，直接把要修改的点Splay到根，然后直接修改它的权值即可 那么对于加边操作，我们可以先判断两点连通性，然后再决定是否加边（细节见代码） 对于删边操作，我们可以使用一个妙不可言的判断式直接判断能否删边，注意理解这样做的正确性（判断式参见代码），以及注意不要漏写条件或是记错细节导致问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;#define ls ch[x][0]#define rs ch[x][1]#define maxn 500005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int ch[maxn][2];int val[maxn];int sum[maxn];int fa[maxn];bool rev[maxn];bool is_root(int x)&#123; return (ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x);&#125;void pushup(int x)&#123; sum[x] = sum[ls] ^ sum[rs] ^ val[x];&#125;void pushdown(int x)&#123; if (rev[x])&#123; swap(ls, rs); rev[ls] ^= 1, rev[rs] ^= 1; rev[x] = 0; &#125;&#125;void rotate(int x, int d)&#123; int k = ch[x][d]; fa[k] = fa[x]; if (!is_root(x)) ch[fa[x]][ch[fa[x]][1] == x] = k; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);&#125;stack&lt;int&gt; s;void splay(int x)&#123; int tem = x; while (!is_root(x))&#123; s.push(x); x = fa[x]; &#125; s.push(x); while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = tem; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = ch[f1][1] == x; if (!is_root(f1))&#123; int f2 = fa[f1]; int d2 = ch[f2][1] == f1; if (d1 ^ d2) rotate(f1, d1), rotate(f2, d2); else rotate(f2, d2), rotate(f1, d1); &#125; else rotate(f1, d1); &#125;&#125;void access(int x)&#123; int tem = 0; while (x)&#123; splay(x); rs = tem; pushup(x); tem = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;bool check(int x, int y)&#123; access(x); splay(x); while (ls) x = ls; int f1 = x; x = y; access(x); splay(x); while (ls) x = ls; int f2 = x; return f1 == f2;&#125;//检查连通性void link(int x, int y)&#123; if (check(x, y)) return; moveroot(x); fa[x] = y;&#125;//预判是否联通void cut(int x, int y)&#123; split(x, y); if (ls == y &amp;&amp; !ch[y][0] &amp;&amp; !ch[y][1])&#123;//值得注意的判断式 fa[y] = ls = 0; pushup(x); &#125;&#125;//实现高鲁棒删边功能void modify(int x, int y)&#123; splay(x); val[x] = y;&#125;//实现单点修改功能，注意此处这样写是正确的，因为在查询之前必至少有一次pushup操作，这样就可以更新到正确的sum[x]int get(int x, int y)&#123; split(x, y); return sum[x];&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("LCT.in", "r", stdin); #endif int op, x, y; read(n), read(m); rep(i, 1, n) read(val[i]); rep(i, 1, m)&#123; read(op), read(x), read(y); switch(op)&#123; case 0 : printf("%d\n", get(x, y)); break; case 1 : link(x, y); break; case 2 : cut(x, y); break; case 3 : modify(x, y); break; default : assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
        <tag>重要文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2631: tree]]></title>
    <url>%2F2018%2F01%2F02%2FBZOJ-2631-tree%2F</url>
    <content type="text"><![CDATA[引言BZOJ 2631: tree 题解 BZOJ 2631: tree Time Limit: 30 Sec Memory Limit: 128 MB Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： + u v c：将u到v的路径上的点的权值都加上自然数c； - u1 v1 u2 v2：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； * u v c：将u到v的路径上的点的权值都乘上自然数c； / u v：询问u到v的路径上的点的权值和，求出答案对于51061的余数。 Input第一行两个整数n，q 接下来n-1行每行两个正整数u，v，描述这棵树 接下来q行，每行描述一个操作 Output对于每个/对应的答案输出一行 Sample Input3 2 1 2 2 3 * 1 3 4 / 1 1 Sample Output4 HINT数据规模和约定10%的数据保证，1&lt;=n，q&lt;=2000 另外15%的数据保证，1&lt;=n，q&lt;=5*10^4，没有-操作，并且初始树为一条链 另外35%的数据保证，1&lt;=n，q&lt;=5*10^4，没有-操作 100%的数据保证，1&lt;=n，q&lt;=10^5，0&lt;=c&lt;=10^4 题目分析本题是做的第一道LCT维护信息的题目，重点在于信息的上下传操作，我们显然是要在一个点上记录它的Splay子树的相关信息，这就是说，当这个点是它所在的Splay的根的时候，这个点上的信息就是以它为顶端的重链的信息，这样我们就可以回答题目的询问了 因为这道题目很重要，这道题目的维护信息的操作是LCT的基础知识，所以下面会结合代码仔细的说明一下信息上下传的具体操作过程 pushup操作，只会在当前点的Splay形态改变时才会发生，因为每个点维护的是Splay上的信息（不包含虚边连接的点的信息），所以，在rotate, access, cut操作中会发生，而在link操作中不会发生 pushdown操作，为了方便处理，只会在对某个点进行Splay操作时才会统一进行下传，注意即使一个点本来就是Splay的根，在对它进行Splay时也要下传它的标记，原因在代码注释中 而这两个操作的内部具体过程完全可以类比线段树的标记上下传过程来写…… 虽说可以类比，但是还是有需要注意的地方的：由于和线段树有本质区别，每个LCT中的点维护的是自己和子树中的信息的和，所以在pushup时要注意算上自己的信息 对了，这道题目还有一点细节，那就是我们要使用unsigned int 类型，因为用int会WA，用long long int会TLE…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define ls ch[x][0]#define rs ch[x][1]#define M 51061#define LL unsigned int #define maxn 200005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;int n, m;int fa[maxn];int ch[maxn][2];int siz[maxn];LL val[maxn];LL sum[maxn];LL add[maxn];LL mul[maxn];bool rev[maxn];inline void pushup(int x)&#123; siz[x] = siz[ls] + siz[rs] + 1; sum[x] = (sum[ls] + sum[rs] + val[x]) % M;&#125;//对子树进行修改后的信息上传过程inline void pass(int x, LL a, LL m, bool r)&#123; mul[x] = mul[x] * m % M; add[x] = (add[x] * m % M + a) % M; sum[x] = (sum[x] * m % M + a * siz[x] % M) % M; val[x] = (val[x] * m % M + a) % M; if (r) swap(ls, rs), rev[x] ^= 1;&#125;//计算并应用下传后的信息inline void pushdown(int x)&#123; pass(ls, add[x], mul[x], rev[x]); pass(rs, add[x], mul[x], rev[x]); add[x] = rev[x] = 0, mul[x] = 1;&#125;//标记下传的过程，类比线段树inline bool is_root(int x)&#123; return (ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x);&#125;void rotate(int x, int d)&#123; int k = ch[x][d], f = fa[x]; //if (f) ch[f][ch[f][1] == x] = k;//Error!!! if (!is_root(x)) ch[f][ch[f][1] == x] = k; fa[k] = f; ch[x][d] = ch[k][d ^ 1]; fa[ch[x][d]] = x; ch[k][d ^ 1] = x; fa[x] = k; pushup(x); pushup(k);//在rotate时进行上传操作，注意x要先于k进行，因为x是k的子树&#125;stack&lt;int&gt; s;void splay(int x)&#123; //if (is_root(x)) return; //在Splay操作前进行信息的统一下传，注意绝对不能因为x是根就返回，因为下一步需要对当前的根进行子树修改（比如access中修改右子树，如果不下传，反转标记就无法达到原来的右子树上），所以必须把信息下传 int t = x; while (!is_root(x)) &#123; s.push(x); x = fa[x]; &#125; s.push(x); while (!s.empty())&#123; pushdown(s.top()); s.pop(); &#125; x = t; while (!is_root(x))&#123; int f1 = fa[x]; int d1 = (ch[f1][1] == x); if (!is_root(f1)) &#123; int f2 = fa[f1]; int d2 = (ch[f2][1] == f1); if (d1 ^ d2)&#123; rotate(f1, d1); rotate(f2, d2); &#125; else &#123; rotate(f2, d2); rotate(f1, d1); &#125; &#125; else rotate(f1, d1); &#125;&#125;void access(int x)&#123; int tem = 0; while (x)&#123; splay(x); rs = tem; pushup(x);//在access中进行信息上传 tem = x; x = fa[x]; &#125;&#125;void moveroot(int x)&#123; access(x); splay(x); rev[x] ^= 1; swap(ls, rs);&#125;void link(int x, int y)&#123; moveroot(x); fa[x] = y;&#125;void split(int x, int y)&#123; moveroot(y); access(x); splay(x);&#125;void cut(int x, int y)&#123; split(x, y); fa[y] = ls = 0; pushup(x);&#125;//在cut中进行信息上传LL get_sum(int x, int y)&#123; split(x, y); return sum[x];&#125;//inline void pass(int x, LL a, LL m, bool r)void Add(int x, int y, int z)&#123; split(x, y); pass(x, z, 1, 0);&#125;void Mul(int x, int y, int z)&#123; split(x, y); pass(x, 0, z, 0);&#125;char op[15];int main()&#123; #ifndef ONLINE_JUDGE freopen("lctree.in", "r", stdin); #endif int x, y, z, w; scanf("%d%d", &amp;n, &amp;m); rep(i, 1, n) val[i] = sum[i] = mul[i] = siz[i] = 1, add[i] = rev[i] = 0; rep(i, 1, n - 1)&#123; scanf("%d%d", &amp;x, &amp;y); link(x, y); &#125; rep(i, 1, m)&#123; scanf("%s", op); if (op[0] == '+')&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); Add(x, y, z); &#125; else if (op[0] == '-')&#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;z, &amp;w); cut(x, y), link(z, w); &#125; else if (op[0] == '*')&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); Mul(x, y, z); &#125; else if (op[0] == '/')&#123; scanf("%d%d", &amp;x, &amp;y); printf("%u\n", get_sum(x, y)) % M; &#125; else printf("fuck you!!!\n"); &#125; return 0;&#125; 所以，其实LCT的重点操作都是在Splay上完成的，一切信息的相关操作也都可以类比Splay上的信息处理方法来写 只要我们能够维护Splay上的有关信息，那么LCT的信息我们就也能够维护了]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
        <tag>重要文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1123: [POI2008]BLO]]></title>
    <url>%2F2018%2F01%2F01%2FBZOJ-1123-POI2008-BLO%2F</url>
    <content type="text"><![CDATA[引言BZOJ 1123: [POI2008]BLO题解 BZOJ 1123: [POI2008]BLO Description Input Output Sample Input Sample Output 题目分析 代码 BZOJ 1123: [POI2008]BLO Time Limit: 10 Sec Memory Limit: 162 MB DescriptionByteotia城市有n个 towns m条双向roads. 每条 road 连接 两个不同的 towns ,没有重复的road. 所有towns连通。 Input输入n&lt;=100000 m&lt;=500000及m条边 Output输出n个数，代表如果把第i个点去掉，将有多少对点不能互通。 Sample Input5 5 1 2 2 3 1 3 3 4 4 5 Sample Output8 8 16 14 8 题目分析Tarjan割点算法+DFS树 本题要求每个点删除后有多少点对不能互通，那么肯定要考虑Tarjan的割点算法，我们在跑Tarjan的过程中，维护一下当前每个点的DFS树子树大小，然后对于一个点$x$，如果它的某个儿子无法追溯到$x$的祖先，那么我们就知道以这个儿子为根的子树是会被隔离掉的（在$x$被删除以后），那么我们直接计算这个字数对答案的贡献即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 200005#define maxm 600005#define ll long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int low[maxn], pre[maxn];int siz[maxn];int t = 0;bool vis[maxn];ll ans[maxn];int Tarjan(int x, int fa)&#123; vis[x] = 1; low[x] = pre[x] = ++t; siz[x] = 1; int k = 0; erep(i, x)&#123; int op = e[i].to; if (op == fa) continue; if (vis[op]) low[x] = min(low[x], low[op]); else &#123; int tem = Tarjan(op, x); if (tem &gt;= pre[x]) ans[x] += (ll)siz[op] * (n - siz[op] - 1), k += siz[op]; low[x] = min(low[x], tem); siz[x] += siz[op]; &#125; &#125; if (k) ans[x] += (ll)(n - k - 1) * k; ans[x] += (n - 1) &lt;&lt; 1; return low[x];&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("blo.in", "r", stdin); #endif int x, y; read(n), read(m); rep(i, 1, m)&#123; read(x), read(y); Add_Edge(x, y); &#125; Tarjan(1, 1); rep(i, 1, n) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>DFS树</tag>
        <tag>联通分量体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目分析要领]]></title>
    <url>%2F2017%2F12%2F14%2F%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%E8%A6%81%E9%A2%86%2F</url>
    <content type="text"><![CDATA[引言题目分析要领，比较高效，思考题目时最好采用这样的方法 题目分析方法 第一步，审题读题，理解题意，浅层思考 第二步，陈列性质，类比推理，全局思考 第三步，细化问题，多向研究，精细思考 第四步，整合代码，明确实现，编程思考 OI心得 后记 题目分析方法第一步，审题读题，理解题意，浅层思考第一步，我们要通读题面，完全掌握题目的要求以及所有的显式性质，数据范围等等，不要因为漏掉重要条件而浪费时间 完全理解题意以后，我们要继续思考题目隐藏性质，通过题目中的一些特殊限制进行简单的推导，猜想相关结论等 第二步，陈列性质，类比推理，全局思考我们在第一步尽可能地对题目进行了一个浓缩以后，我们就要根据现有条件，类比已有模型，思考题目大体与什么体型较为相似，而不要现在就去细节化的思考问题 我们还可以大致想一想题目属于哪一大类的问题，明确算法的使用方向，像多叉索引树一样逐层向下进行尽可能的精确化，再通过这个算法的相关应用方法或是模型进行问题的全局思考 同时，我们明确了方向以后，我们还要大体掌握在这个方向下，我们需要问什么样的问题（脱离这道当前正在做的题目），下文会有例子 第三步，细化问题，多向研究，精细思考我们这时明确了题目性质，大体方向以后，就要开始进行细节化的思考了，比如这道题是一道操作类题目，我们就要思考结束时一般是什么样？中间能否划分为几个操作阶段？每一步操作的影响是什么？这几个问题的提出时间，是在第二步，也就是上文我说的“下文会有例子”，而我们这一步，就是要把这几个问题代入到当前的题目中，把问题细化，就上面的几个问题进行分析 注意，一定不要让自己的思维陷入细节化思考的泥淖中，如果感觉没什么思路，需要回到第二步甚至是第一步重新进行思考，看看是不是大体方向出现了问题，因为细节化思考是“钻牛角尖”，很容易浪费大把时间，而这对于题目分析来说是不值得的 或者我们可以更换当前细节化思考的方向，换一个思路尝试一下，说不定就会有意想不到的效果，总之，绝对不要“死抠”一道题目，如果实在想不出来，就应该回到全局思考或是换一道题目进行研究，总只要记住一点，题目肯定有一个正确的方法，只是你没有想到，他可能离你很远，也可能只是与你擦肩而过，所以死抠总是没有一点好处的 第四步，整合代码，明确实现，编程思考这时，如果你已经确信自己想出了这道题目的正确（或暴力）算法，那么就要立刻开始思考代码了，我们要先明确算法的大体实现步骤，函数定义等，避免在编程中现想现改 OI心得 任何的方法都有可能是解出题目的关键，不要因为没遇到过这样的套路或是觉得过于离谱就直接舍弃掉，无论什么方法都应该试一试 紧紧把握住题目中的每个关键信息，忽略冗余信息，直接从这几个关键信息点思考、突破 很多时候，通过数据范围猜测算法复杂度都是没有什么意义的，最好通过数据范围思考出大致的方向，或是通过猜测出的复杂度确定方向才是有用的，否则估计出的复杂度很难保证准确性，只是知道复杂度并没有什么帮助 后记大致就是这个样子，如果今后实行起来觉得有不足的地方会予以改善]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Renatus的模板库]]></title>
    <url>%2F2017%2F12%2F10%2FRenatus%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[引言本处用于存放OI中经常用到的模板，附带少量讲解 数学 线性代数 异或高斯消元 图论 链式前向星 点连通性判定 边连通性判定 欧拉回路 数据结构 动态线段树 小常数Treap 线段树套指针版Treap 线段树套数组版Treap 树状数组套可持久化线段树 是Renatus本人亲自使用通过的难度较高的模板 数学线性代数异或高斯消元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 本代码用于01异或方程组的高斯消元* 复杂度:O(n * m ^ 2 / 32)*/int n, m;bitset&lt;maxn&gt; ga[maxn];bool isf[maxn];///是否为自由变量int fre[maxn];//自由变量的编号列表int ct = 0;//自由变量的个数bool Gauss_Elimination()&#123; int all = n * m - 1; int k = 0; rep(i, 0, all)&#123; int f = -1; rep(j, k, all)&#123; if (ga[j][i]) &#123; f = j; break; &#125; &#125; if (f == -1) &#123; fre[++ct] = i; isf[i] = 1; continue; &#125; swap(ga[k], ga[f]); rep(j, 0, k - 1) if (ga[j][i]) ga[j] ^= ga[k]; rep(j, k + 1, all) if (ga[j][i]) ga[j] ^= ga[k]; k++; &#125;//正规的高斯消元写法，维护了非自由变量当前值k，同时采用了bitset优化 per(i, all, 0)&#123; bool f = 0; rep(j, 0, all) &#123; if (ga[i][j]) &#123; f = 1; break; &#125; &#125; if (!f &amp;&amp; ga[i][all + 1]) return false; &#125;//判断是否无解 int num = (1 &lt;&lt; ct) - 1; rep(S, 0, num)&#123; //do something... &#125;//枚举每个自由变量的取值，然后...搞事情 //也可以采用DFS进行自由变量最优取值的搜索，此处是枚举所有情况 return true;&#125; 图论链式前向星12345678910111213141516/** 这是一种存储边的方法，方便快速地进行图上遍历*/#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y, int z)&#123; e[++cnt] = edge(h[x], y, z); h[x] = cnt;&#125; 点连通性判定边连通性判定123456789101112131415161718192021222324252627282930313233343536/** 这是用于判断图中边连通性的代码* 每次从任一点开始遍历*/#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y, int z)&#123; e[++cnt] = edge(h[x], y, z); h[x] = cnt;&#125;bool idx[maxm &lt;&lt; 1];bool rec[maxn];int ct = 0;void DFS(int x)&#123; rec[x] = 1; erep(i, x) &#123; if (!idx[i]) idx[i] = 1, ct++; int op = e[i].to; if (rec[op]) continue; DFS(op); &#125;&#125;bool judge()&#123; DFS(1); return ct == cnt;&#125; 欧拉回路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** 这是用于求出无向图及有向图欧拉回路的代码* 使用圈套圈算法*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 200005#define maxm 400005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define erep(i, x) for (register int i = h[x]; i; i = e[i].next)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc();&#125;int n, m, t;struct edge&#123; int next, to, id; edge(int next, int to, int id) : next(next), to(to), id(id)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int out[maxn];int in[maxn];int h[maxn], cnt = 1;void Add_Edge(int x, int y, int z)&#123; e[++cnt] = edge(h[x], y, z); h[x] = cnt; out[x]++, in[y]++;&#125;int ans[maxn];int ct = 0;int root = 0;bool vis[maxm &lt;&lt; 1];void DFS(int x)&#123; for (register int&amp; i = h[x]; i; i = e[i].next)&#123; //注意要用引用记录当前扫描位置避免超时 if (vis[i]) continue; vis[i] = 1; if (t == 1) vis[i ^ 1] = 1; int op = e[i].to; int tem = e[i].id; //注意使用引用后当前边会发生改变 DFS(op); ans[++ct] = tem; &#125;&#125;bool idx[maxm &lt;&lt; 1];bool rec[maxn];int ct2 = 0;void Go(int x)&#123; rec[x] = 1; erep(i, x) &#123; if (!idx[i])&#123; idx[i] = 1; ct2++; &#125; int op = e[i].to; if (rec[op]) continue; Go(op); &#125;&#125;bool judge()&#123; Go(root); if (t == 1) m &lt;&lt;= 1; if (ct2 != m) return false; //注意判断边连通性 if (t == 1) &#123; rep(i, 1, n) if (in[i] &amp; 1) return false; &#125; else &#123; rep(i, 1, n) if (in[i] != out[i]) return false; &#125; //注意if与else的搭配识别 return true;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("Euler_Path.in", "r", stdin); #endif int x, y; read(t), read(n), read(m); rep(i, 1, m)&#123; read(x), read(y); Add_Edge(x, y, i); if (t == 1) Add_Edge(y, x, -i); root = x; //记录度数大于零的点，从这样的点开始DFS &#125; if (!judge()) printf("NO\n"); else &#123; printf("YES\n"); DFS(root); per(i, ct, 1) printf("%d ", ans[i]); //倒序输出答案 &#125; return 0;&#125; 数据结构动态线段树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** 本代码实现的是《普通平衡树》题目要求* 采用动态开点的线段树实现，实测已通过*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt; #include &lt;algorithm&gt;#define maxm 4000005#define INF 10000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxm, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxm];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int sum[maxm];int le[maxm];int ri[maxm];int root, ct;void update(int x, int d)&#123; if (!root) root = ++ct; int o = root, l = -INF, r = INF; while (l != r)&#123; sum[o] += d; int mid = ((r - l) &gt;&gt; 1) + l; if (x &lt;= mid) o = le[o] = (!le[o]) ? ++ct : le[o], r = mid; else o = ri[o] = (!ri[o]) ? ++ct : ri[o], l = mid + 1; &#125; sum[o] += d;&#125;int get_smaller(int x)&#123; int ans = 0, o = root, l = -INF, r = INF; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (x &lt;= mid) o = le[o], r = mid; else ans += sum[le[o]], o = ri[o], l = mid + 1; &#125; return ans;&#125;int find(int rank)&#123; int o = root, l = -INF, r = INF; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (sum[le[o]] &gt;= rank) o = le[o], r = mid; else rank -= sum[le[o]], o = ri[o], l = mid + 1; &#125; if (!o) return -1; return l;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("DST.in", "r", stdin); #endif int n, op, x; read(n); rep(i, 1, n)&#123; read(op), read(x); switch(op)&#123; case 1 : update(x, 1); break; case 2 : update(x, -1); break; case 3 : printf("%d\n", get_smaller(x) + 1); break; case 4 : printf("%d\n", find(x)); break; case 5 : printf("%d\n", find(get_smaller(x))); break; case 6 : printf("%d\n", find(get_smaller(x + 1) + 1)); break; default : printf("fuck you!!!\n"); &#125; &#125; return 0;&#125; 小常数Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** 本代码实现的是《普通平衡树》题目要求* 采用Treap实现，吸收了GXZLegend大佬的小常数，实测已通过*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define INF 2000000005#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int p[maxn], v[maxn], n[maxn], s[maxn];int l[maxn], r[maxn];int ct = 0, root = 0;void zig(int&amp; o)&#123; int k = l[o]; l[o] = r[k], r[k] = o, s[k] = s[o], s[o] = s[l[o]] + s[r[o]] + n[o]; o = k;&#125;void zag(int&amp; o)&#123; int k = r[o]; r[o] = l[k], l[k] = o, s[k] = s[o], s[o] = s[l[o]] + s[r[o]] + n[o]; o = k;&#125;void insert(int&amp; o, int x)&#123; if (!o) o = ++ct, p[o] = rand(), v[o] = x, n[o] = s[o] = 1; else if (v[o] == x) s[o]++, n[o]++; else if (x &lt; v[o])&#123; s[o]++, insert(l[o], x); if (p[l[o]] &gt; p[o]) zig(o); &#125; else &#123; s[o]++, insert(r[o], x); if (p[r[o]] &gt; p[o]) zag(o); &#125;&#125;void del(int&amp; o, int x)&#123; if (v[o] == x)&#123; if (n[o] &gt; 1) n[o]--, s[o]--; else if (!l[o] || !r[o]) o = l[o] + r[o]; else if (p[l[o]] &gt; p[r[o]]) zig(o), del(o, x); else zag(o), del(o, x); &#125; else s[o]--, del((v[o] &lt; x) ? r[o] : l[o], x);&#125;int get_smaller(int o, int x)&#123; int ans = 0; while (o)&#123; if (x &lt; v[o]) o = l[o]; else if (x &gt; v[o]) ans += s[l[o]] + n[o], o = r[o]; else return ans + s[l[o]]; &#125; return ans;&#125;int find(int o, int rank)&#123; while (o)&#123; if (rank &lt;= s[l[o]]) o = l[o]; else if (rank &gt; s[l[o]] + n[o]) rank -= s[l[o]] + n[o], o = r[o]; else return v[o]; &#125; return -1;&#125;int pre(int o, int x)&#123; int ans = -INF; while (o)&#123; if (x &lt;= v[o]) o = l[o]; else ans = max(ans, v[o]), o = r[o]; &#125; return ans;&#125;int suf(int o, int x)&#123; int ans = INF; while (o)&#123; if (x &gt;= v[o]) o = r[o]; else ans = min(ans, v[o]), o = l[o]; &#125; return ans;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("Treap.in", "r", stdin); #endif int n, op, x; read(n); rep(i, 1, n)&#123; read(op), read(x); switch(op)&#123; case 1 : insert(root, x); break; case 2 : del(root, x); break; case 3 : printf("%d\n", get_smaller(root, x) + 1); break; case 4 : printf("%d\n", find(root, x)); break; case 5 : printf("%d\n", pre(root, x)); break; case 6 : printf("%d\n", suf(root, x)); break; default : printf("fuck you!!!\n"); &#125; &#125; return 0;&#125; 线段树套指针版Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257/** 本代码实现的是《二逼平衡树》题目要求* 采用线段树套指针版Treap实现，实测已通过*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define maxn 200005#define maxm 4000005#define INF 1000000005 //Error!!! Don't be too large!!!#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m;int line[maxn];struct node&#123; node* ch[2]; int p, v, n, s; node(int p, int v, int n, int s) : p(p), v(v), n(n), s(s)&#123;ch[0] = ch[1] = NULL;&#125; node()&#123;ch[0] = ch[1] = NULL;&#125; int cmp(int _v)&#123; if (v == _v) return -1; return v &lt; _v; &#125; void maintain()&#123; s = n;//Error!!! s should be n initially, not 1 if (ch[0]) s += ch[0] -&gt; s; if (ch[1]) s += ch[1] -&gt; s; &#125;&#125;;bool vis[maxm];int Rand()&#123;//Error!!! Don't use the same name of system function int p = rand() % maxm; while (vis[p]) p = rand() % maxm; vis[p] = 1; return p;&#125;void rotate(node*&amp; o, int d)&#123; node* k = o -&gt; ch[d]; o -&gt; ch[d] = k -&gt; ch[d ^ 1]; k -&gt; ch[d ^ 1] = o; o -&gt; maintain(); k -&gt; maintain(); o = k;&#125;//node(int p, int v, int n, int s)void insert(node*&amp; o, int v)&#123; if (!o) o = new node(Rand(), v, 1, 1); else &#123; int d = o -&gt; cmp(v); if (d == -1) o -&gt; n++; else &#123; insert(o -&gt; ch[d], v); if (o -&gt; ch[d] -&gt; p &gt; o -&gt; p) rotate(o, d); &#125; &#125; o -&gt; maintain();&#125;void del(node*&amp; o, int v)&#123; if (!o) return; if (o -&gt; v == v)&#123; if (o -&gt; n &gt; 1) o -&gt; n--; else &#123; if (o -&gt; ch[0] &amp;&amp; o -&gt; ch[1]) &#123; int d = o -&gt; ch[0] -&gt; p &lt; o -&gt; ch[1] -&gt; p; rotate(o, d), del(o -&gt; ch[d ^ 1], v); &#125; else if (!o -&gt; ch[0]) o = o -&gt; ch[1]; else o = o -&gt; ch[0]; &#125; &#125; else del(o -&gt; ch[o -&gt; cmp(v)], v); if (o) o -&gt; maintain();&#125;int get_smaller_num(node* o, int v)&#123; int ans = 0; while (o)&#123; int d = o -&gt; cmp(v); if (d == 0) o = o -&gt; ch[0]; else &#123; if (d == -1) return ans + ((o -&gt; ch[0]) ? o -&gt; ch[0] -&gt; s : 0); ans += ((o -&gt; ch[0]) ? o -&gt; ch[0] -&gt; s : 0) + o -&gt; n; o = o -&gt; ch[1]; &#125; &#125; return ans;&#125;int find_val_by_rank(node* o, int rank)&#123; while (o)&#123; int left = ((o -&gt; ch[0]) ? o -&gt; ch[0] -&gt; s : 0); if (left + 1 &lt;= rank &amp;&amp; rank &lt;= left + o -&gt; n) return o -&gt; v; if (rank &gt; left + o -&gt; n) rank -= left + o -&gt; n, o = o -&gt; ch[1]; else o = o -&gt; ch[0]; &#125; return -1;&#125;int get_val_num(node* o, int v)&#123; while (o)&#123; if (o -&gt; v == v) return o -&gt; n; o = o -&gt; ch[o -&gt; cmp(v)]; &#125; return 0;&#125;node* sum[maxn &lt;&lt; 1];int qx, qy, qd, qd2;void init(int l, int r, int o)&#123; rep(i, l, r) insert(sum[o], line[i]); if (l == r) return; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1);&#125;int get_interval_num(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return get_val_num(sum[o], qd); int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_interval_num(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get_interval_num(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int get_interval_smaller(int l ,int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return get_smaller_num(sum[o], qd); int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_interval_smaller(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get_interval_smaller(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;void update(int l, int r, int o)&#123; del(sum[o], line[qx]); insert(sum[o], qd); if (l == r) return; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) update(l, mid, o &lt;&lt; 1); else update(mid + 1, r, o &lt;&lt; 1 | 1);&#125;int judge(int x)&#123; qd = x; int ans = get_interval_smaller(1, n, 1); int tem = get_interval_num(1, n, 1); if (!tem)&#123; if (ans &lt; qd2) return 1; return 0; &#125; else &#123; if (qd2 &lt; ans + 1) return 0; else if (ans + tem &lt; qd2) return 1; else return -1; &#125; &#125;//在当前res &lt; qd2时返回false，否则返回1int user_binary_search(int l, int r)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; int d = judge(mid); if (d == 0) return user_binary_search(l, mid); else if (d == 1) return user_binary_search(mid + 1, r); else return mid;&#125;void user_init()&#123; init(1, n, 1);&#125;int user_find_by_rank(int x, int y, int z)&#123; qx = x, qy = y, qd2 = z; printf("%d\n", user_binary_search(-INF, INF));&#125;void user_get_rank(int x, int y, int z)&#123; qx = x, qy = y, qd = z; printf("%d\n", get_interval_smaller(1, n, 1) + 1);&#125;void user_update(int x, int y)&#123; qx = x, qd = y; update(1, n, 1); line[qx] = qd;&#125;void user_get_pre(int x, int y, int z)&#123; qx = x, qy = y, qd = z; int rank = get_interval_smaller(1, n, 1); user_find_by_rank(x, y, rank);&#125;void user_get_suf(int x, int y, int z)&#123; qx = x, qy = y, qd = z; int rank = get_interval_smaller(1, n, 1) + get_interval_num(1, n, 1) + 1; user_find_by_rank(x, y, rank);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("erbi.in", "r", stdin); freopen("erbi.out", "w", stdout); #endif int op, x, y, z; read(n), read(m); rep(i, 1, n) read(line[i]); user_init(); int ct = 0; rep(i, 1, m)&#123; ct++; read(op); if (op == 1)&#123; read(x), read(y), read(z); user_get_rank(x, y, z); &#125; else if (op == 2)&#123; read(x), read(y), read(z); user_find_by_rank(x, y, z); &#125; else if (op == 3)&#123; read(x), read(y); user_update(x, y); ct--; &#125; else if (op == 4)&#123; read(x), read(y), read(z); user_get_pre(x, y, z); &#125; else if (op == 5)&#123; read(x), read(y), read(z); user_get_suf(x, y, z); &#125; else printf("fuck you!!!\n"); //if (ct == 1 || ct == 3620 || ct == 4173 || ct == 7588) printf("%d %d %d %d\n", op, x, y, z); &#125; return 0;&#125; 线段树套数组版Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260/** 本代码实现的是《二逼平衡树》题目要求* 采用线段树套数组版Treap实现，实测已通过*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005#define maxm 2000005#define INF 1000000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2))? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int p[maxm];int v[maxm];int u[maxm];int s[maxm];int ch[maxm][2];int ct = 0;inline void maintain(int o)&#123; s[o] = u[o]; int l = ch[o][0], r = ch[o][1]; if (l) s[o] += s[l]; if (r) s[o] += s[r];&#125;inline void rotate(int&amp; o, int d)&#123; int k = ch[o][d]; ch[o][d] = ch[k][d ^ 1]; ch[k][d ^ 1] = o; maintain(o); maintain(k); o = k;&#125;bool vis[maxm];inline int Rand()&#123; int p = rand() % maxm; while (vis[p]) p = rand() % maxm; vis[p] = 1; return p;&#125;void insert(int&amp; o, int x)&#123; if (!o) o = ++ct, p[o] = Rand(), v[o] = x, u[o] = 1, s[o] = 1;//Error!!! p = ++ct else &#123; if (x == v[o]) u[o]++; else &#123; int d = (v[o] &lt; x); insert(ch[o][d], x); if (p[ch[o][d]] &gt; p[o]) rotate(o, d); &#125; &#125; maintain(o);&#125;void del(int&amp; o, int x)&#123; if (!o) return; if (v[o] == x)&#123; if (u[o] &gt; 1) u[o]--; else &#123; int l = ch[o][0], r = ch[o][1]; if (!l) o = r; else if (!r) o = l; else &#123; int d = (p[l] &lt; p[r]); rotate(o, d), del(ch[o][d ^ 1], x); &#125; &#125; &#125; else del(ch[o][v[o] &lt; x], x); if (o) maintain(o);&#125;int get_smaller_num(int o, int x)&#123; int ans = 0; while (o)&#123; int l = ch[o][0], r = ch[o][1]; if (x &lt; v[o]) o = l; else &#123; ans += (l) ? s[l] : 0; if (v[o] == x) return ans; ans += u[o], o = r; &#125; &#125; return ans;&#125;int find_by_rank(int o, int rank)&#123; while (o)&#123; int l = ch[o][0], r = ch[o][1]; int si = (l) ? s[l] : 0; if (rank &lt;= si) o = l; else if (rank &gt; si + u[o]) rank -= si + u[o], o = r; else return v[o]; &#125; return -1;&#125;int get_value_num(int o, int x)&#123; while (o)&#123; int l = ch[o][0], r = ch[o][1]; if (v[o] == x) return u[o]; o = (x &lt; v[o]) ? l : r; &#125; return 0;&#125;int n, m;int line[maxn];int h[maxn &lt;&lt; 1];int qx, qy, qd, qd2;void init(int l, int r, int o)&#123; rep(i, l, r) insert(h[o], line[i]); if (l == r) return; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1);&#125;void update(int l, int r, int o)&#123; del(h[o], qd); insert(h[o], qd2); if (l == r) return; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) update(l, mid, o &lt;&lt; 1); else update(mid + 1, r, o &lt;&lt; 1 | 1);&#125;int get_interval_smaller_num(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return get_smaller_num(h[o], qd); int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_interval_smaller_num(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get_interval_smaller_num(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int get_interval_value_num(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return get_value_num(h[o], qd); int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_interval_value_num(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get_interval_value_num(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int judge(int x)&#123; qd = x; int now = get_interval_smaller_num(1, n, 1); int tem = get_interval_value_num(1, n, 1); if (!tem)&#123; if (qd2 &lt;= now) return 0; //Error !!! should be &lt;= ,not &lt; return 1; &#125; else &#123; if (qd2 &lt; now + 1) return 0; if (qd2 &gt; now + tem) return 1; return -1; &#125;&#125;int binary_search(int l, int r)&#123; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; int d = judge(mid); if (d == -1) return mid; if (d == 0) r = mid;//return binary_search(l, mid); if (d == 1) l = mid + 1;//return binary_search(mid + 1, r); &#125; return l;&#125;inline void user_init()&#123; init(1, n, 1);&#125;inline void user_get_interval_rank(int x, int y, int z)&#123; qx = x, qy = y, qd = z; printf("%d\n", get_interval_smaller_num(1, n, 1) + 1);&#125;inline void user_find_by_rank(int x, int y, int z)&#123; qx = x, qy = y, qd2 = z; printf("%d\n", binary_search(0, INF));&#125;inline void user_update(int x, int y)&#123; qx = x, qd = line[x], qd2 = y; update(1, n, 1); line[x] = y;&#125;inline void user_get_pre(int x, int y, int z)&#123; qx = x, qy = y, qd = z; int rank = get_interval_smaller_num(1, n, 1); user_find_by_rank(x, y, rank);&#125;inline void user_get_suf(int x, int y, int z)&#123; qx = x, qy = y, qd = z; int rank = get_interval_smaller_num(1, n, 1) + get_interval_value_num(1, n, 1) + 1; user_find_by_rank(x, y, rank);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("erbi.in", "r", stdin); freopen("erbi.out", "w", stdout); #endif int x, y, z, op; read(n), read(m); rep(i, 1, n) read(line[i]); user_init(); rep(i, 1, m)&#123; read(op); switch(op)&#123; case 1:&#123; read(x), read(y), read(z); user_get_interval_rank(x, y, z); break; &#125; case 2:&#123; read(x), read(y), read(z); user_find_by_rank(x, y, z); break; &#125; case 3:&#123; read(x), read(y); user_update(x, y); break; &#125; case 4:&#123; read(x), read(y), read(z); user_get_pre(x, y, z); break; &#125; case 5:&#123; read(x), read(y), read(z); user_get_suf(x, y, z); break; &#125; &#125; &#125; return 0;&#125; 树状数组套可持久化线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/** 本代码实现的是《二逼平衡树》题目要求* 采用树状数组套可持久化线段树,也就是带修主席树实现，实测已通过*/#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 200005#define maxm 6000005 //Error!!! O(nlog^2 n) utilized more space than you imagined#define lowbit(x) x &amp; -x#define rank RANK#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n, m, _n;int line[maxn];int sline[maxn];struct ele&#123; int op, x, y, z; ele(int op, int x, int y, int z) : op(op), x(x), y(y), z(z)&#123;&#125; ele()&#123;&#125;&#125;save[maxn];int h[maxn];int ch[maxm][2];int s[maxm];int ct = 0;void add(int p, int v, int x)&#123; while (p &lt;= n)&#123; int l = 1, r = _n; if (!h[p]) h[p] = ++ct; int now = h[p]; while (l != r)&#123; s[now] += x; int mid = ((r - l) &gt;&gt; 1) + l; if (v &lt;= mid) &#123; if (!ch[now][0]) ch[now][0] = ++ct; now = ch[now][0]; r = mid; &#125; else &#123; if (!ch[now][1]) ch[now][1] = ++ct; now = ch[now][1]; l = mid + 1; &#125; &#125; s[now] += x; p += lowbit(p); &#125;&#125;int get_smaller(int p, int v)&#123; int ans = 0; while (p)&#123; int l = 1, r = _n, now = h[p]; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (v &lt;= mid) now = ch[now][0], r = mid; else ans += s[ch[now][0]], now = ch[now][1], l = mid + 1; &#125; p -= lowbit(p); &#125; return ans;//Error!!! remember to return ans&#125;int get_bigger(int p, int v)&#123; int ans = 0; while (p)&#123; int l = 1, r = _n, now = h[p]; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; if (v &lt;= mid) ans += s[ch[now][1]], now = ch[now][0], r = mid; else now = ch[now][1], l = mid + 1; &#125; p -= lowbit(p); &#125; return ans;//Error!!! remember to return ans&#125;int left, right, rank;int judge(int x)&#123; int small = get_smaller(right, x) - get_smaller(left - 1, x); int big = get_bigger(right, x) - get_bigger(left - 1, x); int tem = right - left + 1 - small - big; if (!tem)&#123; if (rank &lt;= small) return 0; else return 1; &#125; else &#123; if (rank &lt; small + 1) return 0; else if (rank &gt; small + tem) return 1; else return -1; &#125;&#125;int binary_search(int l, int r)&#123; while (l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; int d = judge(mid); if (d == -1) return mid; if (d == 0) r = mid; if (d == 1) l = mid + 1; &#125; return l;&#125;void user_init()&#123; rep(i, 1, n) add(i, line[i], 1); &#125;void user_get_rank(int x, int y, int z)&#123; printf("%d\n", get_smaller(y, z) - get_smaller(x - 1, z) + 1);///Error!!! Don't forget to add 1&#125;void user_find_by_rank(int x, int y, int z)&#123; left = x, right = y, rank = z; printf("%d\n", sline[binary_search(1, _n)]);&#125;void user_update(int x, int y)&#123; add(x, line[x], -1); line[x] = y; add(x, line[x], 1);&#125;void user_get_pre(int x, int y, int z)&#123; int rank = get_smaller(y, z) - get_smaller(x - 1, z); user_find_by_rank(x, y, rank);&#125;void user_get_suf(int x, int y, int z)&#123; int rank = get_bigger(y, z) - get_bigger(x - 1, z); user_find_by_rank(x, y, y - x + 1 - rank + 1);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("erbi.in", "r", stdin); freopen("erbi.out", "w", stdout); #endif int op, x, y, z, cnt = 0;; read(n), read(m); rep(i, 1, n) read(line[i]), sline[++cnt] = line[i]; rep(i, 1, m) &#123; read(op); if (op == 3) read(x), read(y), save[i] = ele(op, x, y, 0), sline[++cnt] = y; else &#123; read(x), read(y), read(z), save[i] = ele(op, x, y, z); if (op != 2) sline[++cnt] = z; //Error!!! operations whose op == 2 needn't to be discretized &#125; &#125; sort(sline + 1, sline + 1 + cnt); _n = unique(sline + 1, sline + 1 + cnt) - sline - 1; rep(i, 1, n) line[i] = lower_bound(sline + 1, sline + 1 + _n, line[i]) - sline; rep(i, 1, m) &#123; if (save[i].op == 3) save[i].y = lower_bound(sline + 1, sline + 1 + _n, save[i].y) - sline; else if (save[i].op != 2) save[i].z = lower_bound(sline + 1, sline + 1 + _n, save[i].z) - sline; //Error!!! operations whose op == 2 needn't to be discretized &#125; user_init(); rep(i, 1, m)&#123; op = save[i].op, x = save[i].x, y = save[i].y, z = save[i].z; switch(op)&#123; case 1:&#123; user_get_rank(x, y, z); break; &#125; case 2:&#123; user_find_by_rank(x, y, z); break; &#125; case 3:&#123; user_update(x, y); break; &#125; case 4:&#123; user_get_pre(x, y, z); break; &#125; case 5:&#123; user_get_suf(x, y, z); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率与期望类问题总结]]></title>
    <url>%2F2017%2F12%2F10%2F%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B%E7%B1%BB%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言最近研究了一下概率论，感觉比较有感想，于是又做了几道题练习了一下，于此文记之 总结在概率与期望问题中，我们大概有如下几种方法，分别用于不同的问题： 贡献法（绝对是最常用的）&amp; 隔离法 高斯消元解方程组（特定题目） 概率/期望DP 相关内容： 期望的线性可加性（较难的题目，不只限于贡献法） 期望的独立可乘性（还没遇到…) 概率论基本理论（也是一种思想，做题时回归理论本身） 概率论基础知识个人认为，做概率方面的问题，我们需要回归基本概念，思考问题的本质，所以下面先讲解一下概率论的基础内容 注意：下面的定义或含义纯属口胡，应该不是标准定义，只是为了便于理解，请体会精神 试验 我们常常在生活中做“试验”，一个试验是针对一个随机体系而言的，我们每次抛出一枚硬币，观察其正反面情况，这个是一种试验；我们买彩票，最后开奖时观察结果，是中了还是没中，这也是一种试验 试验，就是我们对一个随机现象进行实践，然后得到一个随机结果的过程 样本空间与样本点 样本空间就是我们在一个特定试验中我们能得到的所有可能随机结果的集合，这个集合里面可以是任何东西，而不仅仅一定是数 样本点就是样本空间内的单个元素 事件与基本事件 我们常常需要研究带有特定性质的元素集合的规律性，所以一个事件就是一个满足给定条件的样本点的集合，也即样本空间的子集（可以为空） 基本事件则是由单个样本点构成的集合，即大小为$1$的集合 事件$A$的发生概率可以表示为$P[A]$ 事件的运算其实就是直接考虑集合的运算就可以惹… 我们把$A = \bigcup_{i \in S}A_i$中的$A$称为$A_i$们的和事件，它表示只要事件$A_i$中有至少一个发生，那么事件$A$发生 我们把$A = \bigcap_{i \in S}A_i$中的$A$称为$A_i$们的积事件，它表示只有事件$A_i$全部同时发生，事件$A$才发生 我们把$A = S - T$中的$A$称为$S$与$T$的差事件，它表示只有事件$S$发生且$T$不发生，事件$A$才发生 概率 我们在随机试验背后发现的统计规律性，即一个结果出现次数在试验次数趋于正无穷时的稳定值除以试验次数得到的$[0, 1]$之间的实数，简单点理解就是一个结果出现的量化可能性 随机变量和分布列（律） 它其实不是变量，而更像是一个映射（函数） 我们把样本空间内的每个元素对应到一个实数上，这个对应关系就是随机变量，随机变量的取值只能为实数，而不是任意的什么东西，这是为了方便问题的研究而引入的 显然，由于样本空间中的每个元素有一定概率出现，所以随机变量的每个值也都是有一定概率出现的，我们把随机变量的每种不同取值与其出现概率放在一起，就构成了这个随机变量的分布列（律） 我们常用$X$,$Y$等大写字母代表一个随机事件 我们可以直接用$X = x$（$x$为一个确定数值）表示一个事件，这个事件里面包含所有使得$X = x$的样本点 类比事件的发生概率表示方法，我们用$P[X = x]$代表随机变量$X$取值为$x$的概率 随机变量的离散性 比如，我们有一个随机变量$X$，它的取值为${1, 2, 3.2, 4.1, 5}$，是有限个数值，我们称之为有限离散，$X$满足离散性 又比如，我们有一个随机变量$X$，它的取值为${1, 2, 3, \cdots}$，虽然是无限个数值，但它们可以被我们一一列举（只要你想），那么我们称之为无限可数离散，$X$满足离散性 而如果，我们有一个随机变量$X$，它的取值为$[0, 1]$，是无限个数值，而且其中的数值你无法列举出来，那么$X$不满足离散性 随机变量的期望 随机变量的期望说明，期望只有定义在一个确切的随机变量上才有意义，但是我们常常简称为期望 期望表明了随机变量在平均状态下的取值是什么，即有这个公式: E[X] = \sum_{x \in X} P[X = x] * x 其中$E[X]$即为随机变量$X$的期望 大概的基础知识就是这么多，下面进入其他问题的讲解 期望的性质首先讲一下期望的两个性质：线性可加性， 独立可乘性 期望的线性可加性我们在知道了随机变量$A$与$B$的期望以后，我们如果想知道$A + B$的期望，那么有： E[A + B] = E[A] + E[B]而且，我们允许$A$与$B$不独立 什么是互不独立呢？直接解释可能不是很容易，那么我们看一看不独立时是什么样子的，比如有两枚硬币$A$和$B$，$A$正反面概率相同，我们先把$A$抛出，如果$A$是正面，那么我们再抛出$B$，此时$B$的正反面概率也相同，而如果$A$是反面，那么$B$会由于某种奥妙重重的原因而一定是正面，这个时候，我们就会发现$B$在某些情况下是会受到$A$的结果的干扰的 但是期望的线性可加性允许我们直接计算$A$与$B$两者正面朝上的概率然后加在一起，可以知道，得到的结果是$0.5 + 0.75 = 1.25$ 而通过计算每个样本点的随机变量值及其概率，进行累加，我们发现，正确答案正是$1.25$ 说明随机变量不独立的时候也可以使用期望的线性可加性 期望的独立可乘性我们在知道了随机变量$A$与$B$的期望以后，我们如果想知道$A * B$的期望，那么有： E[A * B] = E[A] * E[B]此时，我们要求$A$与$B$必须互不独立 这是为什么呢？我们还是用上面的那个例子来研究这个问题 我们要求的$A * B$，其实就是只有$A$与$B$都是正面时才为$1$，否则就是$0$ 那么我们可以通过$E[A] * E[B]$得到答案为$0.5 * 0.75 = 0.375$ 但事实上呢？我们再次直接计算所有样本点得到绝对的正确答案，这个答案是$0.25$ 这说明独立可乘性要求随机变量的互相独立 关于这一点的证明，我们需要继续理解条件概率的有关内容以及随机变量独立的含义，简单说就是我们可以把每个随机变量用随机变量的期望公式进行展开，然后$A*B$的每个项都是包含分别属于两个随机变量的取值概率乘积的，相当于两个事件的概率乘积，而这个乘积等于这两个事件同时发生的概率当且仅当这两个事件独立（此处需关联条件概率的有关内容），所以如果事件不独立就会出现问题 如果我们把例子换成两个普通的互不干扰的硬币，可以发现，这个公式是成立的 一些小模型突然想起来了一些常用的小模型，这些小模型会广泛应用于之后的题目中 排列先后模型如果我们现在有$n$个不同元素，这$n$个元素会形成一个排列，而且结果为每个排列的概率是相同的 那么我们知道，对于两个元素来说，其中一个元素在另一个前面的概率为$0.5$ 这个可以通过组合计数统计各自占有的样本点数量来证明 最先删除模型一条链，有$n$个点，我们每次在上面等概率删除一个点，然后把这条链分成两个链，那么对于一条连续的长度为$l$的子链来说，其中一个点最先被删除的概率为$\frac{1}{l}$ 这应该显然。。。 概率论的容斥原理由于事件的本质是样本点的集合，所以我们可以对事件应用容斥原理(其中$A_1, A_2, \cdots $是事件)： \bigcup_{i \in S}A_i = \sum_{T \subset S} (-1)^{|T| + 1}\bigcap_{i \in T} A_i由此我们可以进一步得到： P[\bigcup_{i \in S}A_i] = \sum_{T \subset S} (-1)^{|T| + 1}P[\bigcap_{i \in T} A_i]这说明我们在计算一些事件的概率的时候，可以把它拆成若干个子事件的和事件，然后运用容斥原理来解决它 又由于使随机变量等于某个值的样本点也构成了集合，所以我们也可以对随机变量应用容斥原理： \bigcup_{i \in S}(X_i \geq x) = \sum_{T \subset S} (-1)^{|T| + 1}\bigcap_{i \in T} (X_i \geq x)而如果我们定义$MAX[X_1, X_2, \cdots]$为随机变量$X_1, X_2, \cdots$中的最大值，$MIN[X_1, X_2, \cdots]$为随机变量$X_1, X_2, \cdots$中的最小值，那么我们有： (MAX_{i \in S} [X_i] \geq x)= \sum_{T \subset S} (-1)^{|T| + 1}(MIN_{i \in T}[X_i] \geq x)想一想，为什么？（可以根据事件的运算相关知识来进行思考） 那么，当所有的随机变量都离散的时候，我们不妨把它们能取到的值都离散到自然数集上，即$[0, 1, 2, \cdots]$，那么我们每次令$y = x$，$y’ = x + 1$，然后用$y$和$y’$带入上面的公式，再对这两个得到的式子作差，则有： (MAX_{i \in S} [X_i] = x)= \sum_{T \subset S} (-1)^{|T| + 1}(MIN_{i \in T}[X_i] = x)不失一般性，可以得到： MAX_{i \in S} [X_i]= \sum_{T \subset S} (-1)^{|T| + 1}MIN_{i \in T}[X_i]这就是我们最后想要的结果 注意，上面的公式只能应用于随机变量全都离散的时候，如果不离散…好像也没有那样的OI题是吧… 这个公式在CLJ (Orz! Orz!)的讲课中提到过，但是当时我一脸懵逼…上面就相当于证明了一遍那个式子吧 （上面的那个式子两侧都是随机变量，相当于一种随机变量的等价运算，不关乎每个随机变量的特殊值，不明白可以好好的理解一下） 贡献法 &amp; 隔离法贡献法这个方法应该是比较简单的，需要注意的是贡献法这个思想本身十分重要，它还可以用于其他的一些问题上 我们在一些问题中，发现问题所要求的答案并不容易求出来，而单个元素在与答案一致的层面上的贡献我们比较容易求出，那么我们可以根据期望的线性可加性来对单个元素的贡献进行累加，最后就是答案了 这个过程中，我们需要注意，根据上面的对期望性质的分析，一个元素的贡献不必与其他贡献独立，即当前这个随机变量的分布律可以与其他的随机变量的分布律不独立 我们可以这样运用贡献法：我们把一个元素做出的贡献定义为一个随机变量，那么我们就需要知道这个随机变量在做出不同贡献时需要满足的条件是什么，然后进一步分析得到此时的概率，像这样求出该变量的分布律，最后再使用随机变量期望公式计算即可 贡献法的考察单位可以包含多个元素，然后累加所有这样的多元组的贡献，也能得到最后的答案 隔离法隔离法，可以类比高中物理的相关题目分析方法，我们把无关的变量/条件/元素舍去，只考虑有关元素之间的联系以便于计算 我们在使用贡献法的时候，经常需要屏蔽掉没有用的元素，比如考虑多元组的贡献的时候 即便是在计算单个元素贡献的时候，我们常常也只需要保留那些会影响当前元素贡献的元素，然后在它们之间进行进一步计算 我们下面来看几道题目体会一下： 概率/期望DP我们也可以使用DP来进行问题的解决，基本思想方法可以参见DP的常用思想、处理方法，我们使用这个方法时需要注意思考如何定义便于转移的随机变量，然后使用DP进行推导 其实，概率问题本身就是计数问题，只不过我们人为地给每个方案增加了一个权值，然后我们去计算这个权值的有关信息 更重要的是：我们需要确保在概率相乘的地方这两个概率背后的事件是独立的，这一点其实大多数时候都很难进行判定，我们只有回归到事件在样本空间中的涵盖情况才能真正准确地判断它们是否独立，所以一定要认真谨慎地思考问题！ 下面举几个例子： 高斯消元法有一些题目，我们可以发现状态的转移存在环，而题目中的相关状态数并不多，那么我们可以考虑列出所有可能的转移，把它们看成方程组，然后使用高斯消元方法进行解决，得到每一项的值，经过处理得到最终答案 注意高斯消元的正确写法，建议采用高斯-约当消元法 这种题大部分比较套路，只要知道大致处理方法即可，在数据范围较大时需考虑优化状态表示或者是更换算法 下面有两道题：]]></content>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集和问题详解]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言最近学习了一下CF上某大神写的SOS DP，感觉这不就是FWT吗，然后水了几道题 讲解首先，保留作者姓名转载： 其实我觉得就是把FWT的过程跑了一遍。。。还只考虑了其中的一个子问题b_i = \sum_{j \& i = i} a_j 但是感觉这种DP的思想还是非常好的，就是我们在FWT的合并过程中定义所求数值的含义然后相应地进行转移，使我们更加明确操作的方向 这种方法的缺陷就是局限性较大，在FWT理论中，我们不仅会使用FWT，还会使用IFWT进行解码问题的解决，除此以外还有结合起来使用求位运算卷积这样的高(S)级(B)玩法，而上面的DP只涉及到了FWT中的一个子问题，理论知识方面有所欠缺 例题详解下面是对于上文添加的一些相关题目的详解，最后会对于问题中的常用技巧进行一个总结 Special Pairs 题目分析首先，我们刚学完了所谓的SOS DP，那么肯定是要用了是吧 首先，我们观察这道题目，我们发现熟悉的式子$x \&amp; y = x$不在下标上，而是在元素上，那么我们第一步处理就是元素与下标的互换，把$A_i$当做下标，并相应地把$a[A_i]$增加一（对每个$A_i$都这样做） 然后，我们发现，$i \&amp; j = 0$这个东西本身好像与子集和没有什么关系，于是我们考虑把其中一个操作数取反，那么就变成了$i \&amp;j’ = i$（想一想，为什么？） 这样，我们熟悉的结构就出现了，然后我们直接套用FWT即可解决问题 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define maxn 1048576#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = gc(); if (!f) x = -x;&#125;int n;int a[maxn];int two[20];int line[maxn];int main()&#123; //freopen("spe.in", "r", stdin); two[0] = 1; rep(i, 1, 19) two[i] = two[i - 1] &lt;&lt; 1; int T, x; read(T); while (T--)&#123; read(n); rep(i, 1, n) read(line[i]), a[maxn - 1 - line[i]]++; rep(i, 0, 19) rep(j, 0, maxn - 1) if (!(j &amp; two[i])) a[j] += a[j ^ two[i]]; //FWT,只有短短的一行... long long int sum = 0; rep(i, 1, n) sum += a[line[i]]; printf("%lld\n", sum); memset(a, 0, sizeof(a)); &#125; return 0;&#125; 如果上面那一行FWT不理解的话，请先进行FWT知识的补充（或者看上文的博客用DP的方法搞也行，本质相同） Compatible Numbers 题目分析我们发现，这个题的意思与上一题完全相同，不同的地方就是答案的统计方法上，我们在这一题中只需要求出任意一个可行解即可 那么，大体思路还是相同的，不同的就是我们每次FWT更新时，不再累加答案，而是判断如果当前这一位置需要累加另一个位置的答案，而且当前这一位置答案为空并且另一位置答案不空的时候，直接把另一位的那个答案copy过来即可 代码123456789101112131415161718192021222324#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define maxn 4194304using namespace std;int n; int line[maxn];int ans[maxn];int two[22];int main()&#123; two[0] = 1; rep(i, 1, 21) two[i] = two[i - 1] &lt;&lt; 1; scanf("%d", &amp;n); rep(i, 1, n) scanf("%d", &amp;line[i]), ans[maxn - 1 - line[i]] = line[i]; rep(i, 0, 21) rep(j, 0, maxn - 1) if (!(j &amp; two[i]) &amp;&amp; !ans[j] &amp;&amp; ans[j ^ two[i]]) ans[j] = ans[j ^ two[i]]; rep(i, 1, n) &#123; if (ans[line[i]]) printf("%d ", ans[line[i]]); else printf("-1 "); &#125; return 0;&#125; 注意：所有位运算的操作均作用于下标，同时后面需要添加上一位，而不是继续进行判断性位运算 Vowels 题目分析这道题让我们求出在所有可能的的讯问中的一些情况，大概就是有多少个单词里面包含询问到的字母，然后对于每个询问，把总答案平方然后异或在一起输出 我第一眼看的时候还挺虚，这时限能过吗。。。然而还是跑得飞快，这告诉我们，$1.6 * 10 ^ 7$的数据也是可以跑$O(n\log n)$的算法的。。。 本题还是采用上面的套路，由于我们的答案基于每个询问，所以询问应该是FWT之后的数组，我们应该把单词的相关信息事先添加进初始数组中 我们发现，如果我们把每个单词在二进制意义下取反，那么一个询问不包含这个单词等价于这个询问是取反后单词的子集，这应该很显然 然后，我们可以得到这样的结构:$x \&amp; y = x$,其中$x$代表询问，这样我们继续套用FWT计算即可 注意我们答案的计算方式，是反向处理的，最后还要先变成$n - Ans$这种东西，然后再平方异或和即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 16777216#define LL long long int #define rep(i, l, r) for (register int i = l; i &lt;= r; i++) using namespace std;int n;int a[maxn];int two[24];int main()&#123; //freopen("vowels.in", "r", stdin); char s[5]; two[0] = 1; rep(i, 1, 23) two[i] = two[i - 1] &lt;&lt; 1; scanf("%d", &amp;n); /*rep(i, 1, n) &#123; LL now = 0; scanf("%s", s); rep(j, 0, 2) now |= two[(s[j] - 'a')]; a[maxn - 1 - now]++; &#125; rep(i, 0, 23) rep(j, 0, maxn - 1) if (!(j &amp; two[i])) a[j] += a[j ^ two[i]]; LL ans = 0; //rep(j, 0, maxn - 1) ans += (n - a[j]); rep(j, 0, maxn - 1) ans ^= ((LL)n - a[j]) * (n - a[j]); printf("%I64d", ans);*/ rep(i, 1, n) &#123; LL now = 0; scanf("%s", s); rep(j, 0, 2) now |= two[(s[j] - 'a')]; a[now]++; &#125; rep(i, 0, 23) rep(j, 0, maxn - 1) if (j &amp; two[i]) a[j] += a[j ^ two[i]]; LL ans = 0; //rep(j, 0, maxn - 1) ans += (n - a[j]); rep(j, 0, maxn - 1) ans ^= ((LL)n - a[j]) * (n - a[j]); printf("%I64d", ans); return 0;&#125; Vim War 题目分析跳着做的哈，感觉有些题没地方交，然后套路也都差不多。。。 一开始我还想了半天，Vim是什么呢，怎么这么熟悉？？然后突然看到题面里的gedit，立刻就懂了。。。 这个题还是稍微有点意思的，我们开始使用IFWT了 首先，这道题要求对于一个询问来说合法的子集个数，我们很难把这样的东西对应上初始模型，因为此时这个式子是这样的（把$a_i$看做集合）： Ans_i = \left|\bigcup_{\bigcup_{a_i \in T_i} = query} \{T_i\}\right|所以，我们肯定不能每次枚举一个$T_i$，再判断是否可行，我们必须有一些批量处理信息的方法 于是，我们类比FWT的思路发现，如果对于每个数字，都有一个集合，里面的任何子集都是合法方案，而且这些子集就是这个数字对应的全部答案减一（空集），这样，我们就可以很快地得到答案，即 A_i = 2 ^ {\left|S_i\right|} - 1那么这个子集是什么呢？我们可以得知，这个子集里面就是这个数字的全部子集，即 S_i = \bigcup_{j \& i = j} \{a_j\}但是，这样做，我们发现每个数字也把自己子集里的答案统计了进来，就是这个样子: A_i = \sum_{j \& i = j} B_j我们发现，这个就是我们所求的经典问题的逆问题，我们现在知道$A_i$而不知道$B_i$，那么我们就需要IFWT来进行这一操作，我们直接反着把值减下去，就是最终的答案了 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1048576#define M 1000000007#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read2(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + ch - '0', ch = gc();&#125;template &lt;class T&gt; void read10(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc();&#125;int n, m, op;int a[maxn];int two[maxn];int main()&#123; //freopen("vim.in", "r", stdin); //freopen("vim.out", "w", stdout); int x; read10(n), read10(m); rep(i, 1, n) read2(x), a[x]++; two[0] = 1; rep(i, 1, maxn - 1) two[i] = (two[i - 1] &lt;&lt; 1) % M; read2(op); rep(i, 0, 19) rep(j, 0, maxn - 1) if (j &amp; two[i]) a[j] += a[j ^ two[i]]; rep(j, 0, maxn - 1) a[j] = two[a[j]] - 1; rep(i, 0, 19) rep(j, 0, maxn - 1) if (j &amp; two[i]) a[j] = (M + a[j] - a[j ^ two[i]]) % M; printf("%d", a[op]); return 0;&#125; Jzzhu and Numbers 题目分析这题与上一题的套路又基本一致了 我们发现，本题中的集合取得十分随意，对个数并没有什么限制，于是，我们考虑继续去寻找一种能够帮助我们快速统计答案的集合，使信息合并，快速地统计出答案来 首先，我们把这样的与运算和为$i$的所有取法的集合定义为$S_i$，那么，对于这个集合来说的答案数就是$Ans_i = 2 ^ \left|S_i\right| - 1$，和上一题很相似 其次我们发现，题中所问的那个东西其实并不好求，但如果最后的结果是$i$，那么就能简单许多，因为这样你能发现，每个集合中的元素个数变得很好计算，因为里面每个元素，一定都有$i$这个子集，这样它们任意做与运算和，才能保证$i$的存在，这样就是经典模型了，即$i \&amp; a_j = i$ 所以如果我们把最终好几个数做与运算的最终结果看成是数组中的某一项（把题目的答案看作是对一个固定项的询问），那么我们就又可以通过上一题的套路来解决本题了 但是这样又面临一个问题，这样的答案里面包含了它的所有超集，即: Ans_i = \sum_{i \& j = i} Ans_j但是，这不还是经典模型吗，我们只需要一次IFWT搞回去就可以了 代码123456789101112131415161718192021222324#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define M 1000000007#define maxn 1048576#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) using namespace std;int n;int a[maxn];int two[maxn];int main()&#123; //freopen("jzz.in", "r", stdin); //freopen("jzz.out", "w", stdout); int x; two[0] = 1; rep(i, 1, maxn - 1) two[i] = (two[i - 1] &lt;&lt; 1) % M; scanf("%d", &amp;n); rep(i, 1, n) scanf("%d", &amp;x), a[x]++; rep(i, 0, 19) rep(j, 0, maxn - 1) if (!(j &amp; two[i])) a[j] += a[j ^ two[i]]; rep(j, 0, maxn - 1) a[j] = (M + two[a[j]] - 1) % M; rep(i, 0, 19) rep(j, 0, maxn - 1) if (!(j &amp; two[i])) a[j] = (M + a[j] - a[j ^ two[i]]) % M; printf("%d", a[0]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>快速沃尔什变换(FWT)</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总IX]]></title>
    <url>%2F2017%2F11%2F03%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBIX%2F</url>
    <content type="text"><![CDATA[引言I’ll keep fighting, just wait for my triumph…. Problem 3100. -- 排列3100: 排列Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 16 MBSubmit: 723&nbsp;&nbsp;Solved: 208[Submit][Status][Discuss]Description 给定一个长度为n的序列a，选取连续的一段使其为1~k的一个排列。 求k的最大值。 Input 输入的第一行包含一个整数n。接下来n个数描述序列a 1&lt;=N&lt;=1000000，1 &lt;= ai &lt;=n Output输出一个整数表示k的最大值。Sample Input 5 1 2 3 4 5 Sample Output 5HINT 2017.522新加数据2组By 150137 题目分析刚才水完的一道题，感觉细节很多于是赶紧滚过来写Blog了… 首先说一下我的辣鸡思路，我的方(bao)法(li)是用ST表倍增预处理mex值以及max值，（mex是当前区间中未出现的最小正整数）然后可以做到$O(1)$查询子区间内的这两个信息，然后枚举左端点，向右不断地跳，同时判断合法性，如果合法更新答案 但是这显然有一种数据可以卡，比如前半部分都是$1$，后半部分是$2, 3, 4, \cdots$这样的，这样肯定就是$O(n ^ n)$的了，于是我又想维护每个数的相同数的前驱后继，然后每跳一个区间，就把里面的前驱的最大值更新一下，如果最大值大于等于左端点，那么肯定就有重复元素了，于是就可以skip掉了 这样我们需要ST表预处理三个东西，mex, max以及pre的最大值 但是这样的方法复杂度并没有保证，我个人感觉好像可以证明不会很大，可能均摊$O(n\log n)$，但是又不会证。。。也没构造出可以卡的数据。。。 然而后来我发现，，，本题卡内存 《(⊙＿⊙) 所以上面方法肯定不行啦，但是我后来发现一道一样的而且不卡内存的题，就是BZOJ1318，一会写一下那个方法(^o^)/~ 这题还是看了下题解。。。发现思路还是很巧妙的，我们以$1$的位置作为分割进行分块，然后我们每次考虑一个$1$的两侧，由于最大值可能在$1$的左右任一侧，所以我们需要都跑一遍，但是由于这两种情况对称，所以我们可以先只考虑最大值在$1$右侧的情况 假设当前考虑的这个$1$位置为$p$, 而且我们当前还枚举了一个右端点$r$，我们需要保证这个$r$与$p$之间只有一个$1$，也即当前的$r$没有越过自己所在的块，然后我们就可以求出$[p, r]$的最大值$mx$，我们显然知道，当前只可能是区间$[r - mx + 1, r]$合法，而且$r - mx + 1 &lt;= p$ 这里你可能有疑问，如果$[r - mx + 1, p]$里面的最大值$mx’$大于$mx$了怎么办？我当时也很奇怪这件事，但是我们先不管它，后文会提这件事 此时，我们知道，$[r - mx + 1, r]$合法，需要满足下面几个条件： $[r - mx + 1, r]$ 中没有重复元素 $[r - mx + 1, r]$ 中的元素和为$\frac{mx * (mx + 1)}{2}$ 反过来，满足这两个一定合法（充分性论证），这其实还是挺显然的。。。（必须是$1, 2, \cdots, mx$，所以上文说的如过左边有更大的值一定不合法，因为这样的话在满足第一个条件时，元素和一定会超） 我们知道第二个条件很好判断，直接维护前缀和减一下就好了，但是第一个条件我们并不能很快地进行判断，于是我们就时刻保证满足第一个条件就行了 这时如何保证呢？我们发现，如果我们只是单调地从$p$开始向右扫描，那么合法区间左端点有时会增大，有时会减小，这样子就十分麻烦， 我们肯定也不能每次都暴力地去乱搞 其实我们可以看到，当我们不断加入右边元素的时候，最远左端点的位置显然是不降的，因为会出现重复元素，为了保证条件必须向右移动最远左端点，但是这件事我自己并没有细想，于是去看了题解 就是在这个时候，我发现网上很多题解都是GG的，他们都是在处理这件事情上采用了错误或是不完全的方法，于是被Hack了（甚至连CA爷的题解都是不正确的。。。） 然而后来我还是找到一篇对的，这是因为我研究了一遍他的代码发现很有道理。。。 是这样处理的，我们每次先把$l$一直向右扩展，但是不能越过自己所在的块，同时$[l, p]$内也不能出现相同的元素，得到了这样的最远的$l$以后，我们就可以顺序从$p$开始向右扫描，然后用当前扫到的元素的前驱更新最远左端点的位置，那么，我们可以知道，我们现在就是保证了$[l, r]$内没有相同元素，而且$[l - 1, r]$内一定有相同元素（其实就是极大无重复子区间），我们还需要确保$l &lt; p$，否则区间中就没有$1$了 于是，我们在处理当前位置$r$的时候，只要满足$r - mx + 1 \geq l$即可，同时再求一下前缀差判断子区间元素和，就可以保证满足条件了 由于本题卡内存，我们直接把原数组求前缀和，同时为了维护元素前驱，我们需要一个$save$数组，在线更新，但是这样我们就不能使用这个数组向左扩展$l$了（因为$l$所在的是前一块，而那块已经被更新完了），于是我们再维护一个bool型的$vis$数组，下标表示元素的值，然后用它扩展$l$即可，当前块扫完以后还要回滚回false的状态（为了保证复杂度） 这样内存占用大概是$13$M,是可以通过本题的 其实本题细节确实很多，网上题解大多不很详细，所以搞这样一篇长题解，如果还是不懂可以参考下面代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 1000005#define maxm #define INF #define eps #define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define per(i, r, l) for (register int i = r; i &gt;= l; i--)#define sline(i) (line[i] - line[i - 1])//#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;/*char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; bool f = 1; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; ch != '-') ch = gc(); if (ch == '-') f = 0, ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc(); if (!f) x = -x;&#125;*/int n;long long int line[maxn];int save[maxn];bool vis[maxn];int main()&#123; scanf("%d", &amp;n); rep(i, 1, n) scanf("%lld", &amp;line[i]), line[i] += line[i - 1]; int ans = 1; rep(i, 1, n)&#123; if (sline(i) == 1)&#123; int l = i - 1; while (l &gt; 0 &amp;&amp; sline(l) != 1 &amp;&amp; !vis[sline(l)]) vis[sline(l)] = 1, l--; int tem = ++l; int r = i + 1; int mx = 0; while (r &lt;= n &amp;&amp; sline(r) != 1)&#123; mx = max(sline(r), (long long int)mx); l = max(l, save[sline(r)] + 1), save[sline(r)] = r; if (l &lt;= i &amp;&amp; r - mx + 1 &gt;= l &amp;&amp; (line[r] - line[r - mx] == ((long long int) mx * (mx + 1) &gt;&gt; 1))) ans = max(ans, mx); r++; &#125; rep(j, tem, i - 1) vis[sline(j)] = 0; &#125; else save[sline(i)] = i; &#125; memset(save, 0, sizeof(save)); per(i, n, 1) line[i] = sline(i); reverse(line + 1, line + 1 + n); rep(i, 1, n) line[i] += line[i - 1]; rep(i, 1, n)&#123; if (sline(i) == 1)&#123; int l = i - 1; while (l &gt; 0 &amp;&amp; sline(l) != 1 &amp;&amp; !vis[sline(l)]) vis[sline(l)] = 1, l--; int tem = ++l; int r = i + 1; int mx = 0; while (r &lt;= n &amp;&amp; sline(r) != 1)&#123; mx = max(sline(r), (long long int)mx); l = max(l, save[sline(r)] + 1), save[sline(r)] = r; if (l &lt;= i &amp;&amp; r - mx + 1 &gt;= l &amp;&amp; (line[r] - line[r - mx] == ((long long int) mx * (mx + 1) &gt;&gt; 1))) ans = max(ans, mx); r++; &#125; rep(j, tem, i - 1) vis[sline(j)] = 0; &#125; else save[sline(i)] = i; &#125; printf("%d", ans); return 0;&#125; 不要区别对待上下的两个大的$i$循环，因为我其实是直接从上面复制到下面的，没有一点区别。。。 下面我再附上我参考的正确题解代码，来自 BraketBN123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Footprints In The Blood Soaked Snow */ #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; typedef unsigned int uint; typedef long long LL; const int maxn = 1000005, inf = 0x3f3f3f3f; int n, last[maxn], next[maxn], ans; uint sum[maxn]; bool vis[maxn]; inline int iread() &#123; int f = 1, x = 0; char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()) f = ch == '-' ? -1 : 1; for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - '0'; return f * x; &#125; inline void calc(int x) &#123; int len = 0, r = inf; for(int i = x + 1; i &lt;= n &amp;&amp; sum[i] - sum[i - 1] != 1; i++) &#123; int now = sum[i] - sum[i - 1]; if(!vis[now]) vis[now] = 1; else &#123; r = i; break; &#125; &#125; for(int i = x; i &gt;= 1; i--) &#123; int now = sum[i] - sum[i - 1]; if(now == 1 &amp;&amp; i != x) break; len = max(len, now); r = min(r, next[i]); if(i + len - 1 &lt; r &amp;&amp; i + len - 1 &lt;= n) if(sum[i + len - 1] - sum[i - 1] == (LL)len * (len + 1) &gt;&gt; 1) ans = max(ans, len); &#125; for(int i = x + 1; i &lt;= n &amp;&amp; sum[i] - sum[i - 1] != 1; i++) vis[sum[i] - sum[i - 1]] = 0; &#125; inline void solve() &#123; for(int i = 1; i &lt;= n; i++) last[i] = inf; for(int i = n; i &gt;= 1; i--) &#123; int now = sum[i] - sum[i - 1]; next[i] = last[now]; last[now] = i; &#125; for(int i = 1; i &lt;= n; i++) if(sum[i] - sum[i - 1] == 1) calc(i); &#125; int main() &#123; n = iread(); for(int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + iread(); solve(); for(int i = n; i &gt;= 1; i--) sum[i] = sum[i] - sum[i - 1]; reverse(sum + 1, sum + 1 + n); for(int i = 1; i &lt;= n; i++) sum[i] += sum[i - 1]; solve(); printf("%d\n", ans); return 0; &#125; 再附上一份我发现的错误题解代码，来自 WerKeyTom_FT，这位同学下面的评论里已经有人指出问题，所以我就不评论了 希望这位同学不要因为我引用您的代码作为错误范本而生气，只是为了更加深刻的理解，并无恶意。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(i=a;i&lt;=b;i++)#define fd(i,a,b) for(i=a;i&gt;=b;i--)using namespace std;const int maxn=1000000+2;typedef long long ll;ll a[maxn];int last[maxn];int i,n,ans,mx,wz;void calc()&#123; int j,l; ans=max(ans,1); mx=1; l=last[a[i]-a[i-1]]; last[a[i]-a[i-1]]=i; wz=l+1; fo(j,i+1,n+1)&#123; if (j&gt;n||a[j]-a[j-1]==1) break; l=last[a[j]-a[j-1]]; last[a[j]-a[j-1]]=j; wz=max(wz,l); mx=max(mx,int(a[j]-a[j-1])); if (wz&lt;=j-mx+1) if (a[j]-a[j-mx]==(ll)mx*(mx+1)/2) ans=max(ans,mx); &#125; i=j;&#125;int main()&#123; scanf("%d",&amp;n); fo(i,1,n)&#123; scanf("%lld",&amp;a[i]); //sum[i]=sum[i-1]+(ll)a[i]; //left[i]=last[a[i]]; //last[a[i]]=i; &#125; fo(i,1,n) a[i]+=a[i-1]; fo(i,1,n)&#123; if (a[i]-a[i-1]==1) break; last[a[i]-a[i-1]]=i; &#125; while (i&lt;=n)&#123; calc(); &#125; fd(i,n,1) a[i]-=a[i-1]; fo(i,1,n/2) swap(a[i],a[n-i+1]); fo(i,1,n) a[i]+=a[i-1]; fo(i,1,n) last[i]=0; fo(i,1,n)&#123; if (a[i]-a[i-1]==1) break; last[a[i]-a[i-1]]=i; &#125; while (i&lt;=n)&#123; calc(); &#125; printf("%d\n",ans);&#125;/*8 4 4 4 4 2 9 1 8 Hack数据*/ Hack数据来自 独立团团长李云龙，错在哪里就不解释了，根据上文的讲解应该可以自己比划出来 尊重版权从我做起 希望能对大家有所帮助，写得可真是累啊(′O`) / Problem 1318. -- [Spoj744] Longest Permutation1318: [Spoj744] Longest PermutationTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 593&nbsp;&nbsp;Solved: 358[Submit][Status][Discuss]Description给你一个序列A含有n个正整数(1&lt;=Ai&lt;=n)。A的子集形式类如Au, Au+1 … , Av (1&lt;=u&lt;=v&lt;=n)，即必须是连续的。我们感兴趣的是一种子集，它含有元素包括1,2,…k。（k是子集的大小）。你的任务是找到这种类型的最长的子集。 &lt;/div&gt;Input第一行，一个数n，表示序列A的长度 第二行，n个数，第I个数表示元素Ai Output一个数，表示可选子集的长度 Sample Input 5 4 1 2 3 2 Sample Output 4 HINT 你可以选得子集从A1开始到A4,这个子集长度为4，包含了1，2，3，4） 1]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总VIII]]></title>
    <url>%2F2017%2F11%2F02%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBVIII%2F</url>
    <content type="text"><![CDATA[引言Some day we’ll meet again…. Problem 4804. -- 欧拉心算4804: 欧拉心算Time Limit: 15 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 354&nbsp;&nbsp;Solved: 212[Submit][Status][Discuss]Description&nbsp;给出一个数字N Input第一行为一个正整数T，表示数据组数。 接下来T行为询问，每行包含一个正整数N。 T&lt;=5000,N&lt;=10^7 Output按读入顺序输出答案。 Sample Input 1 10Sample Output 136HINT source By FancyCoder 题目分析感觉最近做了好多莫比乌斯反演套路题。。。 仍然是老玩法，我们枚举最大公约数，然后发现可以预处理$\varphi$前缀和然后分块搞，本题就这样结束了。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 10000005#define LL long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) using namespace std;bool vis[maxn];int p[maxn];int cnt = 0;int phi[maxn];LL pre[maxn];void init()&#123; phi[1] = 1; rep(i, 2, maxn - 1) &#123; if (!vis[i])&#123; p[++cnt] = i; phi[i] = i - 1; &#125; rep(j, 1, cnt) &#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; &#125; rep(i, 1, maxn - 1) pre[i] = pre[i - 1] + phi[i];&#125;void work(int n)&#123; LL ans = 0; rep(d, 1, n)&#123; int next = n / (n / d); ans += (LL)pre[n / d] * (pre[next] - pre[d - 1]); d = next; &#125; ans &lt;&lt;= 1; printf("%lld\n", ans - pre[n]);//Error!!! 注意输出格式...&#125;int main()&#123; int T, n; init(); scanf("%d", &amp;T); while (T--)&#123; scanf("%d", &amp;n); work(n); &#125; return 0;&#125; Problem 5071. -- [Lydsy十月月赛]小A的数字5071: [Lydsy十月月赛]小A的数字Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 317&nbsp;&nbsp;Solved: 152[Submit][Status][Discuss]Description&nbsp;www.lydsy.com/JudgeOnline/upload/201710/10.rar注意此题的PDF版题面有问题，请以压缩包中txt文档为准！ 题目分析既然放在第一题上应该非常水是吧。。。然而我太弱了还是没想到 我们仔细研究一下这个操作，可以发现我们实际上是把前缀和交换了位置，所以我们只需要判断两个序列的前缀和是否完全相同（不考虑顺序）于是我们只要排个序再比较一下就好了。。。 代码123456789101112131415161718192021222324#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)#define LL long long intusing namespace std;LL a[maxn];LL b[maxn];int main()&#123; int n, T, x; scanf("%d", &amp;T); while (T--)&#123; scanf("%d", &amp;n); rep(i, 1, n) scanf("%d", &amp;x), a[i] = a[i - 1] + x; rep(i, 1, n) scanf("%d", &amp;x), b[i] = b[i - 1] + x; sort(a + 1, a + 1 + n), sort(b + 1, b + 1 + n); rep(i, 1, n) if (a[i] != b[i]) &#123;printf("NO\n"); goto jump;&#125; printf("YES\n"); jump:; &#125; return 0;&#125; Problem 5074. -- [Lydsy十月月赛]小B的数字5074: [Lydsy十月月赛]小B的数字Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 201&nbsp;&nbsp;Solved: 134[Submit][Status][Discuss]Descriptionwww.lydsy.com/JudgeOnline/upload/201710/10.rar&nbsp; 题目分析这题可以对所需满足的条件列出数学公式，然后直接进行推导，容易发现只要$\sum_{i = 1} ^ n \frac{1}{a_i} &gt;= 1$即可 代码1234567891011121314151617181920212223242526272829#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define maxn 100005#define eps 1e-7#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char buffer[maxn];char *p1, *p2;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = gc();x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = gc();&#125;int main()&#123; int T, n, x; read(T); double now; while (T--)&#123; now = 0; read(n); rep(i, 1, n) read(x), now += 1.0 / x; if (now - 1.0 &gt; eps) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125; Problem 1925. -- [Sdoi2010]地精部落1925: [Sdoi2010]地精部落Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 64 MBSubmit: 1613&nbsp;&nbsp;Solved: 1004[Submit][Status][Discuss]Description传说很久以前，大地上居住着一种神秘的生物：地精。地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 N 的山脉 H可分为从左到右的 N 段，每段有一个独一无二的高度 Hi，其中Hi是1到N 之间的正整数。如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。地精们希望这N 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。现在你希望知道，长度为N 的可能有地精居住的山脉有多少种。两座山脉A和B不同当且仅当存在一个 i，使得 Ai≠Bi。由于这个数目可能很大，你只对它除以P的余数感兴趣。 &lt;/div&gt;Input 仅含一行，两个正整数 N, P。 Output仅含一行，一个非负整数，表示你所求的答案对P取余 之后的结果。 Sample Input 4 7Sample Output 3HINT 对于 20%的数据，满足 N≤10； 对于 40%的数据，满足 N≤18； 对于 70%的数据，满足 N≤550； 对于 100%的数据，满足 3≤N≤4200，P≤109 source 第一轮Day2 题目分析基本一道水题，考虑递归求解，从小到大放入数字，那么我们直接DP一下就好了，大概要求出插入位置前面是山谷/山顶，后面是山谷/山顶的数量，由于插入的数相对于之前的数是最大的，所以我们不用管具体数列中都是什么数，DP只要记录一个数字个数就可以转移了 代码123456789101112131415161718192021222324252627282930#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 4205#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define per(i, l, r) for (register int i = r; i &gt;= l; i--)#define LL long long int using namespace std;int n;LL ft[maxn], fh[maxn], M;int C[maxn];int main()&#123; scanf("%d%lld", &amp;n, &amp;M); if (n == 1)&#123; printf("%lld", 1 % M); return 0; &#125; ft[0] = fh[0] = ft[1] = fh[1] = 1; C[0] = 1; rep(i, 2, n)&#123; per(j, 1, i) C[j] = (C[j - 1] + C[j]) % M; rep(j, 0, i)&#123; if (j &amp; 1) fh[i] += C[j] * ft[j] % M * fh[i - j - 1] % M, fh[i] %= M; if ((i - j - 1) &amp; 1) ft[i] += C[j] * ft[j] % M * fh[i - j - 1] % M, ft[i] %= M; &#125; &#125; printf("%lld", (ft[n] &lt;&lt; 1) % M); return 0;&#125; Problem 4358. -- permu4358: permuTime Limit: 30 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 974&nbsp;&nbsp;Solved: 248[Submit][Status][Discuss]Description给出一个长度为n的排列P(P1,P2,...Pn)，以及m个询问。每次询问某个区间[l,r]中，最长的值域 连续段长度。 Input第一行两个整数n,m。 接下来一行n个整数，描述P。 接下来m行，每行两个整数l,r，描述一组询问。 Output对于每组询问，输出一行一个整数，描述答案。 Sample Input 8 3 3 1 7 2 5 8 6 4 1 4 5 8 1 7Sample Output 3 3 4HINT 对于询问[1,4]，P2,P4,P1组成最长的值域连续段[1,3]； 对于询问[5,8]，P8,P5,P7组成最长的值域连续段[4,6]； 对于询问[1,7]，P5,P7,P3,P6组成最长的值域连续段[5,8]。 1&lt;=n,m&lt;=50000 source By sumix173 题目分析看到这样的数据范围，应该能想到是序列莫队算法，但是我们发现维护连续段的时候，我们为了保证操作的$O(1)$进行，必须使用并查集维护，然而这样的话我们就不能支持动态删除这样的操作 我们知道，对于左端点在同一个块中的询问，它们的右端点是单调递增的，所以我们考虑维护操作之前的情况，这样每次查询时，我们先更新询问的右端点到这个询问的位置，在查询一个左端点时，我们也先暴力搞到那个位置，但在查询完以后要再将对于左端点的操作复位到初始指针的位置（右端点的更新一直积累，不进行复位） 为了方便处理，我们把此时这个块的初始指针指在末尾，这样更新左右端点时就不会互相影响 这样我们可以维护每次操作前的情况，复位时我们就可以直接恢复连续段之前的样子，就像是撤销操作一样，然后就像普通的莫队一样搞就行了 这听起来像是回滚莫队，但不知道究竟是不是这个。。。 如果没看懂可以结合代码一起食用 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define maxn 100005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define per(i, l, r) for (register int i = r; i &gt;= l; i--) #define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)using namespace std;char buffer[maxn];char *p1, *p2;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = gc();&#125;int n, m;int p[maxn];int pos[maxn];int res[maxn];struct query&#123; int l, r, id; query(int l, int r, int id) : l(l), r(r), id(id)&#123;&#125; query()&#123;&#125; bool operator &lt; (const query b) const&#123; return (pos[l] == pos[b.l]) ? r &lt; b.r : pos[l] &lt; pos[b.l]; &#125;&#125;q[maxn];struct record&#123; int *l, *r; int a, b; record(int* l, int* r, int a, int b) : l(l), r(r), a(a), b(b)&#123;&#125; record()&#123;&#125;&#125;save[maxn];int cnt = 0;int rig[maxn];int lef[maxn];bool in[maxn];int ans = 0;void add(int l, int r)&#123; rep(i, l, r)&#123; int x = p[i]; in[x] = 1; int le = (in[x - 1]) ? lef[x - 1] : x; int ri = (in[x + 1]) ? rig[x + 1] : x; save[++cnt] = record(rig + le, lef + ri, *(rig + le), *(lef + ri)); *(rig + le) = ri, *(lef + ri) = le; ans = max(ans, ri - le + 1); &#125;&#125;void del(int l, int r)&#123; rep(i, l, r)&#123; in[p[i]] = 0; record op = save[cnt--]; *op.l = op.a, *op.r = op.b; &#125;&#125;int main()&#123; #ifdef FILE freopen("permu.in", "r", stdin); freopen("permu.out", "w", stdout); #endif int x, y; read(n), read(m); rep(i, 1, n) read(p[i]); rep(i, 1, m) &#123; read(x), read(y); q[i] = query(x, y, i); &#125; int siz = (int) sqrt(n) + 1; rep(i, 1, n) pos[i] = (i - 1) / siz; sort(q + 1, q + 1 + m); int l, r, nb = -1, tem = 0; rep(i, 1, m) &#123; if (pos[q[i].l] != nb)&#123; memset(lef, 0, sizeof(lef)); memset(rig, 0, sizeof(rig)); memset(in, 0, sizeof(in)); cnt = tem = 0; nb = pos[q[i].l]; l = r = (nb + 1) * siz; r++; &#125; ans = tem; if (q[i].r &gt;= r)&#123; add(r, q[i].r); r = q[i].r + 1; tem = ans; &#125; add(q[i].l, min(q[i].r, l)); res[q[i].id] = ans; del(q[i].l, min(q[i].r, l)); &#125; rep(i, 1, m) printf("%d\n", res[i]); return 0;&#125; Problem 4198. -- [Noi2015]荷马史诗4198: [Noi2015]荷马史诗Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 1462&nbsp;&nbsp;Solved: 775[Submit][Status][Discuss]Description追逐影子的人，自己就是影子。 &mdash;&mdash;荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 n 种不同的单词，从 1 到 n 进行编号。其中第 i 种单词出现的总次数为 wi。Allison 想要用 k 进制串 si 来替换第 i 种单词，使得其满足如下要求: 对于任意的 1&le;i,j&le;n，i&ne;j，都有：si 不是 sj 的前缀。 现在 Allison 想要知道，如何选择 si，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 si 的最短长度是多少？ 一个字符串被称为 k 进制字符串，当且仅当它的每个字符是 0 到 k&minus;1 之间（包括 0 和 k&minus;1）的整数。 字符串 Str1 被称为字符串 Str2 的前缀，当且仅当：存在 1&le;t&le;m，使得 Str1=Str2[1..t]。其中，m 是字符串 Str2 的长度，Str2[1..t] 表示 Str2 的前 t 个字符组成的字符串。 Input输入文件的第 1 行包含 2 个正整数 n,k，中间用单个空格隔开，表示共有 n 种单词，需要使用 k 进制字符串进行替换。 接下来 n 行，第 i+1 行包含 1 个非负整数 wi，表示第 i 种单词的出现次数。 Output输出文件包括 2 行。 第 1 行输出 1 个整数，为《荷马史诗》经过重新编码以后的最短长度。 第 2 行输出 1 个整数，为保证最短总长度的情况下，最长字符串 si 的最短长度。 Sample Input 4 2 1 1 2 2Sample Output 12 2HINT 用 X(k) 表示 X 是以 k 进制表示的字符串。 一种最优方案：令 00(2) 替换第 1 种单词，01(2) 替换第 2 种单词，10(2) 替换第 3 种单词，11(2) 替换第 4 种单词。在这种方案下，编码以后的最短长度为： 1&times;2+1&times;2+2&times;2+2&times;2=12 最长字符串 si 的长度为 2。 一种非最优方案：令 000(2) 替换第 1 种单词，001(2) 替换第 2 种单词，01(2) 替换第 3 种单词，1(2) 替换第 4 种单词。在这种方案下，编码以后的最短长度为： 1&times;3+1&times;3+2&times;2+2&times;1=12 最长字符串 si 的长度为 3。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。 对于所有数据，保证 2&le;n&le;100000，2&le;k&le;9。 选手请注意使用 64 位整数进行输入输出、存储和计算。 题目分析基本就是一个Huffman树的变式，我们每次还是用小根堆维护，然后每次连着取出$k$个就可以 注意我们为了保证贪心的正确，必须在进行合并操作之前在堆中补零元素，具体需要补零的个数应该很容易计算出来（根据最后Huffman树一定是完全树的性质进行推导） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define LL long long intusing namespace std;struct ele&#123; LL val, len; ele(LL val, LL len) : val(val), len(len)&#123;&#125; ele()&#123;&#125; bool operator &lt; (const ele b) const&#123; return (val == b.val) ? len &gt; b.len : val &gt; b.val; &#125;&#125;;priority_queue&lt;ele&gt; s;int main()&#123; register int i; LL n, k, x; scanf("%lld%lld", &amp;n, &amp;k); for (i = 1; i &lt;= n; i++)&#123; scanf("%lld", &amp;x); s.push(ele(x, 1)); &#125; if ((n - 1) % (k - 1)) for (i = 0; i &lt; k - 1 - (n - 1) % (k - 1); i++) s.push(ele(0, 1)); LL ans = 0; while (!s.empty())&#123; LL val = 0, len = 0; for (i = 0; i &lt; k; i++)&#123; ele op = s.top();s.pop(); val += op.val, len = max(len, op.len); if (s.empty()) break; &#125; ans += val; if (s.empty())&#123; printf("%lld\n%lld", ans, len); break; &#125; else s.push(ele(val, len + 1)); &#125; return 0;&#125; Problem 1537. -- [POI2005]Aut- The Bus 1537: [POI2005]Aut- The Bus Time Limit: 5 Sec&nbsp;&nbsp;Memory Limit: 64 MBSubmit: 401&nbsp;&nbsp;Solved: 276[Submit][Status][Discuss]DescriptionByte City 的街道形成了一个标准的棋盘网络 – 他们要么是北南走向要么就是西东走向. 北南走向的路口从 1 到 n编号, 西东走向的路从1 到 m编号. 每个路口用两个数(i, j) 表示(1]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总VII]]></title>
    <url>%2F2017%2F11%2F02%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBVII%2F</url>
    <content type="text"><![CDATA[引言Can you hear me ? I have arrived at this place, it’s far from where we start, isn’t it? Problem 4800. -- [Ceoi2015]Ice Hockey World Championship4800: [Ceoi2015]Ice Hockey World ChampionshipTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 486&nbsp;&nbsp;Solved: 259[Submit][Status][Discuss]Description有n个物品，m块钱，给定每个物品的价格，求买物品的方案数。 Input第一行两个数n，m代表物品数量及钱数 第二行n个数，代表每个物品的价格 n&lt;=40，m&lt;=10^18 Output一行一个数表示购买的方案数 （想怎么买就怎么买，当然不买也算一种） Sample Input 5 1000 100 1500 500 500 1000Sample Output 8 题目分析你看这个题目说的，“想怎么买就怎么买”，这题一定很随意，所以我们必须搜索出所有的情况，但是如果Naive的做这道题，我们显然会TLE，那么，我们还是考虑如何合并一些信息，加快速度 我们观察题目，物品个数的数据范围虽然在暴力情况下会TLE，但是本身其实也并不大，这时就有一个技巧，那就是Meet in the Middle，即中途相遇法，我们把前后各$20种物品的取用方法分别预处理出来，然后考察其中一部分，枚举里面的情况在另一部分中二分，然后直接更新答案即可，这时就会变得非常稳 然而我这么弱并没有想到QAQ，感觉之前要是不会还是挺难想的。。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long int#define maxn 45#define maxm 2000005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) using namespace std;int n;LL m;LL c[maxn];LL A[maxm];int ca = 0;LL B[maxm];int cb = 0;int mid;void DFS1(int pos, LL sum)&#123; if (sum &gt; m) return; if (pos == mid + 1) &#123; A[++ca] = sum; return; &#125; DFS1(pos + 1, sum); DFS1(pos + 1, sum + c[pos]);&#125;void DFS2(int pos, LL sum)&#123; if (sum &gt; m) return; if (pos == n + 1) &#123; B[++cb] = sum; return; &#125; DFS2(pos + 1, sum); DFS2(pos + 1, sum + c[pos]);&#125;int main()&#123; scanf("%d%lld", &amp;n, &amp;m); mid = n &gt;&gt; 1; rep(i, 1, n) scanf("%lld", &amp;c[i]); DFS1(1, 0); DFS2(mid + 1, 0); sort(A + 1, A + 1 + ca); LL ans = 0; rep(i, 1, cb) ans += upper_bound(A + 1, A + 1 + ca, m - B[i]) - A - 1; printf("%lld", ans); return 0;&#125; Problem 4296. -- [PA2015]Mistrzostwa4296: [PA2015]MistrzostwaTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSec&nbsp;&nbsp;Special JudgeSubmit: 222&nbsp;&nbsp;Solved: 93[Submit][Status][Discuss]Description给定一张n个点m条边的无向图，请找到一个点数最多的点集S，满足： 1.对于点集中任何一个点，它至少与d个点集中的点相邻。 2.仅保留点集中的点后，剩下的图连通。Input第一行包含三个正整数n,m,d(2&lt;=n&lt;=200000，1&lt;=m&lt;=200000，1&lt;=d&lt;n)，分别表示点数，边数以及度数限制。 接下来m行，每行包含两个正整数a,b(1&lt;=a,b&lt;=n，a不等于b)，表示a点和b点之间有一条边。Output若无解，输出NIE。 否则第一行输出一个正整数k，表示你找到的点数最多的点集S的点数。 第二行输出k个正整数，按升序依次输出点集中的点的编号，若有多组解，输出任意一组。Sample Input 4 4 2 1 2 2 3 3 4 4 2Sample Output 3 2 3 4 题目分析首先我们知道，度数不超过$d$的点是肯定不行的，所以我们就先把它们删掉，删掉以后又会有一些点度数变小，我们就可以用队列来搞删除这个操作，删到最后，如果还有点剩下，那么这些点的度数一定都是大于等于$d$的，而此时这些点其实本身就可以作为答案来更新了，因为它们满足题目中的条件。。。 所以，我们删完点后，考虑每个连通块，直接求出最大答案即可 本题主要是一种递归处理的思想吧，其实之前POI也考了一道类似的题，忘了是哪年的了。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#define maxn 200005#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define erep(i, x) for (register int i = h[x]; i; i = e[i].next)using namespace std;int n, m, d;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1, deg[maxn];void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt; deg[x]++, deg[y]++;&#125;queue&lt;int&gt; q;bool kill[maxn];int vis[maxn];int siz[maxn];int ct = 0;void DFS(int x)&#123; vis[x] = ct; erep(i, x)&#123; int op = e[i].to; if (vis[op] || kill[op]) continue; DFS(op); &#125;&#125;set&lt;int&gt; ans;int main()&#123; int x, y; scanf("%d%d%d", &amp;n, &amp;m, &amp;d); rep(i, 1, m)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; rep(i, 1, n) if (deg[i] &lt; d) q.push(i); while (!q.empty())&#123; int op = q.front(); q.pop(); kill[op] = 1; erep(i, op)&#123; int k = e[i].to; if (deg[k] &lt; d) continue; deg[k]--; if (deg[k] &lt; d) q.push(k); &#125; &#125; rep(i, 1, n) if (!vis[i] &amp;&amp; !kill[i]) ct++, DFS(i); if (!ct)&#123; printf("NIE"); return 0; &#125; rep(i, 1, n) siz[vis[i]]++; int ma = 0; rep(i, 1, ct) ma = max(ma, siz[i]); rep(i, 1, ct)&#123; if (siz[i] == ma)&#123; rep(j, 1, n) if (vis[j] == i) ans.insert(j); break; &#125; &#125; printf("%d\n", ma); for (set&lt;int&gt; :: iterator it = ans.begin(); it != ans.end(); it++) printf("%d ", *it); return 0;&#125; Problem 4292. -- [PA2015]Równanie4292: [PA2015]RównanieTime Limit: 1 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 481&nbsp;&nbsp;Solved: 270[Submit][Status][Discuss]Description对于一个正整数n，定义f(n)为它十进制下每一位数字的平方的和。现在给定三个正整数k,a,b，请求出满足a&lt;=n&lt;=b且k*f(n)=n的n的个数。 Input第一行包含三个正整数k,a,b(1&lt;=k,a,b&lt;=10^18,a&lt;=b)。 Output输出一个整数，即满足条件的n的个数。 Sample Input 51 5000 10000Sample Output 3HINT 满足的3个n分别为7293，7854和7905。 source By Claris 题目分析这种题显然是要枚举。。。因为$f$函数就那么几个值，我们就考虑把求值型问题转化为判定性问题，我们枚举$f$函数值然后直接搞就可以了。。。 代码123456789101112131415161718192021#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long intusing namespace std;int main()&#123; LL k, a, b; int ans = 0; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); for (register LL i = 1; i &lt;= 81 * 18; i++)&#123; LL op = i * k; if (op &lt; a) continue; if (op &gt; b) break; LL tem = 0; while (op) tem += (op % 10) * (op % 10), op /= 10; if (tem == i) ans++; &#125; printf("%d", ans); return 0;&#125; Problem 4291. -- [PA2015]Kieszonkowe4291: [PA2015]KieszonkoweTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 978&nbsp;&nbsp;Solved: 570[Submit][Status][Discuss]Description给定n个数，请从中选出若干个数，使得总和为偶数，请最大化这个总和。 Input第一行包含一个正整数n(1&lt;=n&lt;=1000000)。 第二行包含n个正整数a_1,a_2,...,a_n(1&lt;=a_i&lt;=1000)。 Output输出一个正整数，即最大的总和，若无解则输出NIESTETY。 Sample Input 5 2 4 3 3 3Sample Output 12HINT source By Claris 题目分析这题可以竞选OJ十大水题。。。不解释，然而我还WA了一次QAQ 代码123456789101112131415161718192021#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n, x; scanf("%d", &amp;n); int ans = 0; int mi = 1005; int f = 0; for (register int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); ans += x; if (x &amp; 1) mi = min(mi, x), f ^= 1;//Error：别忘了奇数有偶数个的情况...... &#125; if (f &amp;&amp; mi &lt; 1005) ans -= mi; if (!ans) printf("NIESTETY"); else printf("%d", ans); return 0;&#125; Problem 2086. -- [Poi2010]Blocks2086: [Poi2010]BlocksTime Limit: 20 Sec&nbsp;&nbsp;Memory Limit: 259 MBSubmit: 754&nbsp;&nbsp;Solved: 336[Submit][Status][Discuss]Description给出N个正整数a[1..N]，再给出一个正整数k，现在可以进行如下操作：每次选择一个大于k的正整数a[i]，将a[i]减去1，选择a[i-1]或a[i+1]中的一个加上1。经过一定次数的操作后，问最大能够选出多长的一个连续子序列，使得这个子序列的每个数都不小于k。 总共给出M次询问，每次询问给出的k不同，你需要分别回答。 Input第一行两个正整数N (N &lt;= 1,000,000)和M (M &lt;= 50)。 第二行N个正整数，第i个正整数表示a[i] (a[i] &lt;= 10^9)。 第三行M个正整数，第i个正整数表示第i次询问的k (k &lt;= 10^9)。 Output共一行，输出M个正整数，第i个数表示第i次询问的答案。 &lt;/div&gt;Sample Input 5 6 1 2 1 1 5 1 2 3 4 5 6 Sample Output 5 5 2 1 1 0 题目分析首先这题我们可以把数字看做海拔，高度小于$k$的那些就是坑喽，并且要搞明白什么时候可以把坑补上然后继续向一侧延伸，我们发现，对于一个区间，如果有里面的数字之和非负，那么这个区间可以通过各种填坑或是移山的操作使之没有坑，这样，我们可以用前缀差表示这件事 我们如果固定顺序扫描前缀的话，我们需要二分查找这样的环节，但是这样显然会炸是吧，（其实$O(nm)$都是挺虚的），所以我们不能这样搞 我们可以发现，当两个前缀和$pre_i$与$pre_j$满足这样的条件时：$pre_i &lt; pre_j \mbox{而且} i &lt; j$的时候，$pre_i$肯定就没有用了，这应该很显然，因为对于$pre_i$来说可行的左端点对于$pre_j$来说也一定可行，然后$j$还在$i$的后面。。。 所以，我们可以用单调栈来维护这些东西，最后，这些可能最优的决策就是一个单调递减的东西，而且它们的最远合法左端点一定也是单调递增的，那么我们就可以直接扫描一遍，求出答案 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define LL long long int#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define per(i, l, r) for (register int i = r; i &gt;= l; i--) using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = gc();&#125;int n;int a[maxn];LL b[maxn];int sta[maxn];int head = 0;int main()&#123; int m, x; read(n); read(m); rep(i, 1, n) read(a[i]); rep(i, 1, m) &#123; read(x); rep(j, 1, n) b[j] = b[j - 1] + a[j] - x; per(j, 1, n)&#123; while (head &amp;&amp; (b[j - 1] &lt;= b[sta[head] - 1])) head--; sta[++head] = j; &#125; int now = n, ans = 0; rep(j, 1, head)&#123; while (now &amp;&amp; b[now] &lt; b[sta[j] - 1]) now--; ans = max(ans, now - sta[j] + 1); &#125; if (i == 1) printf("%d", ans); else printf(" %d", ans); head = 0; &#125; return 0;&#125; Problem 4806. -- 炮4806: 炮Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 681&nbsp;&nbsp;Solved: 333[Submit][Status][Discuss]Description众所周知，双炮叠叠将是中国象棋中很厉害的一招必杀技。炮吃子时必须隔一个棋子跳吃，即俗称&quot;炮打隔子&quot;。&nbsp; 炮跟炮显然不能在一起打起来，于是rly一天借来了许多许多的炮在棋盘上摆了起来&hellip;&hellip;他想知道，在N&times;M的矩形 方格中摆若干炮（可以不摆）使其互不吃到的情况下方案数有几种。 棋子都是相同的。 Input一行，两个正整数N和M。 N&lt;=100,M&lt;=100 Output一行，输出方案数mod 999983。 Sample Input 1 3Sample Output 7HINT source By FancyCoder 题目分析这题首先第一点就是任一行和列不能有超过两个棋子，这非常显然，然后，考虑按行DP，我们发现，对于当前的所有列都分别有多少棋子这件事我们是需要知道的，但是我们不需要知道具体某一列的情况，因为我们可以组合计数，所以我们可以多加入三维：当前列上棋子为0, 1, 2的列的个数分别是多少，然后转移时分类讨论一下，结合列信息推一推就好了 代码12345678910111213141516171819202122232425262728#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define M 999983#define maxn 105#define LL long long intusing namespace std;int n, m;bool vis[maxn][maxn][maxn];int dp[maxn][maxn][maxn];int DP(int pos, int n0, int n1)&#123; if (pos == n + 1) return 1; if (vis[pos][n0][n1]) return dp[pos][n0][n1]; vis[pos][n0][n1] = 1; int&amp; ans = dp[pos][n0][n1]; ans = DP(pos + 1, n0, n1) % M; if (n0) ans += (LL)DP(pos + 1, n0 - 1, n1 + 1) * n0 % M, ans %= M; if (n0 &gt; 1) ans += (LL)DP(pos + 1, n0 - 2, n1 + 2) * (n0 * (n0 - 1) &gt;&gt; 1) % M, ans %= M; if (n1) ans += (LL)DP(pos + 1, n0, n1 - 1) * n1 % M, ans %= M; if (n1 &gt; 1) ans += (LL)DP(pos + 1, n0, n1 - 2) * (n1 * (n1 - 1) &gt;&gt; 1) % M, ans %= M; if (n0 &amp;&amp; n1) ans += (LL)DP(pos + 1, n0 - 1, n1) * n0 % M * n1 % M, ans %= M; return ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); printf("%d", DP(1, m, 0)); return 0;&#125; 正好1000B，真是大吉大利 Problem 4414. -- 数量积4414: 数量积Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 383&nbsp;&nbsp;Solved: 142[Submit][Status][Discuss]Description神犇heheda最近得到了UOJ抱枕，蒟蒻yts1999想要玩。于是heheda给yts1999出了一道题： 一个长度为2n+2的整数数列 按照下式定义： A0=0 A1=C Ai+2=(Ai+1+Ai) Mod M (0&lt;=i&lt;=2*N) 现有n个平面向量v1&hellip;vn： V1=(A2,A3),V2=(A4,A5)...Vn=(A2n,A2n+1) 集合S的定义如下： &nbsp; 其中&quot;vi&bull;vj&quot;表示向量vi和vj的数量积。 求S集合中不同元素的个数是多少。答案对M取模。 heheda告诉yts1999，只要他做出了这道题，她就可以把抱枕借给他玩一会。然而yts1999实在是太弱了不会做，于是向你求助。 Input输入数据包含一行三个整数C,M和n，分别表示a1的值，模数和平面向量的个数，每两个数之间用一个空格隔开。 Output输出一行一个整数表示答案对M取模后的值。 Sample Input 4 5 3Sample Output 2HINT 数列为{0,4,4,3,2,0,2,2}，v1=(4,3),v2=(2,0),v3=(2,2)。 v1&bull;v2 mod M=3, v2&bull;v3 mod M=4, v1&bull;v3 mod M=4。 对于100%的数据，1&le;C&le;10^9,1&le;M&le;10^9,1&le;n&le;3*10^5 source By yts1999 题目分析真是巧，前几天刚集中研(mo)究(bai)了一下Fibonacci数列的相关性质，然后这题就出现了。。。 首先我们手动推(xun)导(zhao)一(gui)下(lv),发现任意两个向量乘完以后是非零首项值为$C^2$的Fibonacci数列中的某一项，更细致的推导可以发现是里面从$[7,4n - 1]$（应该是，要是不对就自己推一遍，反正是$O(n)$的）中的所有奇数项，然后就可以直接扫一遍看看余数情况就行了。。。。 其实上面那个规律是有公式的，姿势链接 代码123456789101112131415161718192021222324252627#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i += 2) #define LL long long intusing namespace std;set&lt;int&gt; s;LL c, M;int n;int main()&#123; scanf("%lld%lld%d", &amp;c, &amp;M, &amp;n); c = c * c % M; LL a = c * 3 % M, b = c * 5 % M; rep(i, 7, (n &lt;&lt; 2) - 1)&#123; LL tem = b; b = (a + b) % M; a = tem; tem = b; b = (a + b) % M; a = tem; s.insert(b); &#125; printf("%d", s.size() % M); return 0;&#125; Problem 4802. -- 欧拉函数4802: 欧拉函数Time Limit: 5 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 990&nbsp;&nbsp;Solved: 367[Submit][Status][Discuss]Description已知N，求phi(N) &lt;/div&gt;Input正整数N。N&lt;=10^18 &lt;/div&gt;Output输出phi(N) Sample Input 8Sample Output 4HINT &lt;/div&gt;source By FancyCoder 题目分析借这道题学习了一下Miller-Robin和Pollard-Rho，感觉技能点++ 其实非常简单，我们交替着来Miller-Robin和Pollard-Rho，最后合并欧拉函数值，注意，这个不是直接乘在一起，一定要小心，而是采用下面这个公式\frac{\varphi(x) * \varphi(y) }{\varphi(gcd(x, y))} * gcd(x, y) 然后本题就结束了，鉴于网上讲解Miller-Robin和Pollard-Rho的文章颇多，而且像我这样的辣鸡都能看着学会，本处不再占用过多篇幅讲解 p.s. BZOJ上的数据太弱了，即使自己过了也不要认为代码完全正确，上面的phi函数合并我都是直接乘在一起的也过了。。。后来才发现这样不对。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#define maxn 10005#define LL long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define F(k) ((mul(k, k, x) + c) % x)using namespace std;int phi[maxn];int pr[maxn];bool vis[maxn];int cnt = 0;void init()&#123; phi[1] = 1; rep(i, 2, maxn - 1) &#123; if (!vis[i]) &#123; pr[++cnt] = i; phi[i] = i - 1; &#125; rep(j, 1, cnt)&#123; if (i * pr[j] &gt;= maxn) break; vis[i * pr[j]] = 1; if (i % pr[j] == 0)&#123; phi[i * pr[j]] = phi[i] * pr[j]; break; &#125; phi[i * pr[j]] = phi[i] * (pr[j] - 1); &#125; &#125;&#125;//Euler Sieve AlgorithmLL mul(LL x, LL y, LL M)&#123; LL ans = 0, con = x; while (y)&#123; if (y &amp; 1) ans = (ans + con) % M; con = (con + con) % M; y &gt;&gt;= 1; &#125; return ans;&#125;//calculate x * y % MLL power(LL x, LL y, LL M)&#123; LL ans = 1, con = x; while (y)&#123; if (y &amp; 1) ans = mul(ans, con, M); con = mul(con, con, M); y &gt;&gt;= 1; &#125; return ans;&#125;//calculate x ^ y % Mint p[37] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151&#125;;const int ct = 36;bool Miller_Robin(LL x)&#123; rep(i, 1, ct) &#123; if (p[i] == x) return true; if (x % p[i] == 0) return false; &#125; int siz = 0; LL _x = x - 1; while (!(_x &amp; 1))&#123; siz++; _x &gt;&gt;= 1; &#125; rep(i, 1, ct)&#123; LL now = power(p[i], _x, x); if (now == 1) continue; rep(j, 1, siz)&#123; if (now == x - 1) goto jump; if (now == 1) return false; now = mul(now, now, x); &#125; if (now != 1) return false; jump:; &#125; return true;&#125;//Miller-Robin AlgorithmLL gcd(LL x, LL y)&#123; return (!y) ? x : gcd(y, x % y);&#125;//GCD AlgorithmLL Pollard_Rho(LL x)&#123; if (x &lt; maxn) return phi[x]; if (Miller_Robin(x)) return x - 1; while (1)&#123; LL c = rand() % x; LL a = rand() % x; LL b = F(a); LL ans = 1; while (a != b)&#123; LL d = gcd(abs(a - b), x); if (d &gt; 1) &#123; //return Pollard_Rho(d) * Pollard_Rho(x / d); int _d = gcd(d, x / d); return Pollard_Rho(d) * Pollard_Rho(x / d) / Pollard_Rho(_d) * _d; &#125; a = F(a); b = F(b), b = F(b); &#125; &#125;&#125;//Pollard-Robin AlgorithmLL n;int main()&#123; init(); scanf("%lld", &amp;n); printf("%lld", Pollard_Rho(n)); return 0;&#125;/*Serious Error,at line 87, 97, 99 we can't calculate phi and merely multiple them together, we should do operations like line 98 shown....Warning at line 87, 110, we should do initial operation to speed up, otherwise the program will get TLE easily....Attention, the program is also a template for Miller-Robin Algorithm and Pollard-Rho Algorithm....*/ 这份代码应该是正确性很高的一份了，这个程序可以通过一个著名强伪随机数$3215031751$的测试 Problem 3872. -- [Poi2014]Ant colony3872: [Poi2014]Ant colonyTime Limit: 30 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 246&nbsp;&nbsp;Solved: 97[Submit][Status][Discuss]Description There is an entrance to the ant hill in every chamber with only one corridor leading into (or out of) it. At each entry, there are g groups of m1,m2,...,mg ants respectively. These groups will enter the ant hill one after another, each successive group entering once there are no ants inside. Inside the hill, the ants explore it in the following way: Upon entering a chamber with d outgoing corridors yet unexplored by the group, the group divides into d groups of equal size. Each newly created group follows one of the d corridors. If d=0, then the group exits the ant hill. If the ants cannot divide into equal groups, then the stronger ants eat the weaker until a perfect division is possible. Note that such a division is always possible since eventually the number of ants drops down to zero. Nothing can stop the ants from allowing divisibility - in particular, an ant can eat itself, and the last one remaining will do so if the group is smaller than d. The following figure depicts m ants upon entering a chamber with three outgoing unexplored corridors, dividing themselves into three (equal) groups of floor(m/3) ants each. A hungry anteater dug into one of the corridors and can now eat all the ants passing through it. However, just like the ants, the anteater is very picky when it comes to numbers. It will devour a passing group if and only if it consists of exactly k ants. We want to know how many ants the anteater will eat. 给定一棵有n个节点的树。在每个叶子节点，有g群蚂蚁要从外面进来，其中第i群有m[i]只蚂蚁。这些蚂蚁会相继进入树中，而且要保证每一时刻每个节点最多只有一群蚂蚁。这些蚂蚁会按以下方式前进： &middot;在即将离开某个度数为d+1的点时，该群蚂蚁有d个方向还没有走过，这群蚂蚁就会分裂成d群，每群数量都相等。如果d=0，那么蚂蚁会离开这棵树。 &middot;如果蚂蚁不能等分，那么蚂蚁之间会互相吞噬，直到可以等分为止，即一群蚂蚁有m只，要分成d组，每组将会有floor(m/d)只，如下图。 一只饥饿的食蚁兽埋伏在一条边上，如果有一群蚂蚁通过这条边，并且数量恰为k只，它就会吞掉这群蚂蚁。请计算一共有多少只蚂蚁会被吞掉。 InputThe first line of the standard input contains three integers n, g, k (2&lt;=n,g&lt;=1000000, 1&lt;=k&lt;=10^9), separated by single spaces. These specify the number of chambers, the number of ant groups and the number of ants the anteater devours at once. The chambers are numbered from 1 to n. The second line contains g integers m[1],m[2],...,m[g](1&lt;=m[i]&lt;=10^9), separated by single spaces, where m[i] gives the number of ants in the i-th group at every entrance to the ant hill. The n-1 lines that follow describe the corridors within the ant hill; the i-th such line contains two integers a[i],b[i] (1&lt;=a[i],b[i]&lt;=n), separated by a single space, that indicate that the chambers no.a[i] and b[i] are linked by a corridor. The anteater has dug into the corridor that appears first on input. 第一行包含三个整数n,g,k,表示点数、蚂蚁群数以及k。 第二行包含g个整数m[1],m[2],...,m[g]，表示每群蚂蚁中蚂蚁的数量。 接下来n-1行每行两个整数，表示一条边，食蚁兽埋伏在输入的第一条边上。 OutputYour program should print to the standard output a single line containing a single integer: the number of ants eaten by the anteater. 一个整数，即食蚁兽能吃掉的蚂蚁的数量。 Sample Input 7 5 3 3 4 1 9 11 1 2 1 4 4 3 4 5 4 6 6 7Sample Output 21 题目分析首先经常做数学题，就知道已知下取整函数的值能求出自变量取值范围，我们就这样从上到下进行树上DP，然后DP到叶子的时候二分答案并累加进最终答案即可，在这样的做法下，DP的返回值是一个二元组，表示可以被吃一次的蚂蚁群的此时可行的数量范围 我为了处理方便，在第一条边中间加了一个点，作为根向下DP 注意当可行区间左边界大于蚂蚁数量最大值时及时跳出，否则会炸long long int 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define LL long long int#define gc() ((p1 == p2 &amp;&amp; (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) #define erep(i, x) for (register int i = h[x]; i; i = e[i].next)using namespace std;char *p1, *p2;char buffer[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = gc(); x = 0; while (!('0' &lt;= ch &amp;&amp; ch &lt;= '9')) ch = gc(); while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0', ch = gc();&#125;int n, m, k;int g[maxn];struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1, deg[maxn];void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt; deg[x]++, deg[y]++;&#125;LL ans = 0;LL dp[maxn][2];void DP(int x, int fa)&#123; LL l = dp[x][0], r = dp[x][1]; if (l &gt; g[m]) return; bool f = 0; erep(i, x)&#123; int op = e[i].to; if (op == fa) continue; f = 1; deg[op]--; if (!deg[op]) dp[op][0] = l, dp[op][1] = r; else dp[op][0] = (LL)deg[op] * l, dp[op][1] = (LL)deg[op] * (r + 1) - 1; DP(op, x); &#125; if (!f) ans += (LL) k * ((upper_bound(g + 1, g + 1 + m, r) - g - 1) - (upper_bound(g + 1, g + 1 + m, l - 1) - g - 1));&#125;int main()&#123; int x, y; read(n), read(m), read(k); rep(i, 1, m) read(g[i]); sort(g + 1, g + 1 + m); read(x), read(y); Add_Edge(n + 1, x), Add_Edge(n + 1, y); rep(i, 2, n - 1)&#123; read(x), read(y); Add_Edge(x, y); &#125; dp[n + 1][0] = dp[n + 1][1] = k; DP(n + 1, n + 1); printf("%lld", ans); return 0;&#125; Problem 4805. -- 欧拉函数求和4805: 欧拉函数求和Time Limit: 15 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 485&nbsp;&nbsp;Solved: 274[Submit][Status][Discuss]Description 给出一个数字N，求sigma(phi(i)),1&lt;=i&lt;=N Input正整数N。N&lt;=2*10^9 Output输出答案。 Sample Input 10Sample Output 32HINT source By FancyCoder 题目分析显然就是一个简单的杜教筛，我们用这个公式做$Dilechlet$卷积，再用它做杜教筛即可： \varphi * 1 = id相信学过莫比乌斯反演的都看得懂。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define maxn 100005#define LL long long int#define rep(i, l, r) for (register int i = l; i &lt;= r; i++) using namespace std;LL phi[maxn];bool vis[maxn];int cnt;int p[maxn];void init()&#123; phi[1] = 1; rep(i, 2, maxn - 1)&#123; if (!vis[i])&#123; phi[i] = i - 1; p[++cnt] = i; &#125; rep(j, 1, cnt) &#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0)&#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; &#125; rep(i, 1, maxn - 1) phi[i] += phi[i - 1];&#125;map&lt;int, LL&gt; save;LL dyh(int x)&#123; if (x &lt; maxn) return phi[x]; if (save.count(x)) return save[x]; LL ans = (LL)x * (x + 1) &gt;&gt; 1; //Error!!! Don't forget long long int rep(i, 2, x)&#123; int next = (x / (x / i)); ans -= ((LL)next - i + 1) * dyh(x / i); i = next; &#125; save[x] = ans; return ans;&#125;int main()&#123; init(); int n; scanf("%d", &amp;n); printf("%lld", dyh(n)); return 0;&#125; 记得开long long int….说了多少遍了….]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东北育才NOIP校内模拟赛总结]]></title>
    <url>%2F2017%2F09%2F09%2F%E4%B8%9C%E5%8C%97%E8%82%B2%E6%89%8DNOIP%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言NOIP即将到来，又是新的轮回，不知今年会怎么样…… 东北育才2017.9.8校内NOIP模拟赛总结题目 名次 题解A.dist题目分析本题应该说是比较基础的题目了，如果没能想到做法，说明那么在基础的知识点上面掌握的并不牢固，如果写挂，说明细节把握不好，不够仔细，需要更加认真 本题的做法有许多，本文只介绍一种： 考虑绝对值的几何意义，我们可以直接把所有点的位置进行排序，然后预处理前缀后缀和，对每个点进行扫描求和，不妨设这个点为第$i$个点，点的位置为$x_i$ 那么这个点贡献的答案就是 (i * x_{i} - pre[i]) + (suf[i] - (n - i + 1) * x_{i}) 这样本题就在$O(n \log n)$内解决了 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 1000005#define LL long long intusing namespace std;int n;LL line[maxn];LL suf[maxn];LL pre[maxn];template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); if (ch == '-') f = 0, ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; //freopen("dist.in", "r", stdin); //freopen("dist.out", "w", stdout); read(n); for (int i = 1; i &lt;= n; i++) read(line[i]); sort(line + 1, line + 1 + n); for (int i = n; i &gt;= 1; i--) suf[i] = suf[i + 1] + line[i]; for (int i = 1; i &lt;= n; i++) pre[i] = pre[i - 1] + line[i]; LL ans = 0; for (int i = 1; i &lt;= n; i++)&#123; ans += suf[i] - line[i] * (n - i + 1) + line[i] * i - pre[i]; &#125; printf("%lld", ans); return 0;&#125; B.fight题目分析考虑相邻位交换，我们假设当前要打的怪物为$i$，下一个为$i + 1$，那么$i$与$i + 1$（假设这是存在的）交换后的状态对答案的贡献减去交换前的贡献，并且我们要求它小于零，即使答案更优，那么就对应着如下的式子（其中$num_i$表示使怪物死亡需要的攻击次数）: \begin{align} \Delta_{ans} &= ((num_i + num_{i + 1}) * A_{i} + num_{i + 1} * A_{i + 1}) - ((num_i + num_{i + 1}) * A_{i + 1} + num_i * A_i) \\ &= A_i * num_{i + 1} - num_i * A_{i + 1}\\ & < 0\\ \end{align}由此，我们知道： \frac{A_i}{num_i} < \frac{A_{i + 1}}{num_{i + 1}}即，我们将每一个怪物的权值定义为它的攻击力除以使其死亡需要的攻击次数，那么我们应该尽可能地先去攻击权值较大的怪物，所以，我们只需要对此排序，扫描一遍即可出解 那么本题就在$O(n \log n)$内解决了 代码注意： 排序的时候要转换类型为double型12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 100005#define LL long long intusing namespace std;int n, ak;LL line[maxn];LL sline[maxn];LL a[maxn];LL d[maxn];LL h[maxn];LL pre[maxn];LL num[maxn];template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); if (ch == '-') f = 0, ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;bool cmp(int x, int y)&#123; return ((double) a[x] / num[x]) &gt; ((double) a[y] / num[y]);&#125;int main()&#123; //freopen("fight.in", "r", stdin); //freopen("fight.out", "w", stdout); read(n), read(ak); for (int i = 1; i &lt;= n; i++) read(a[i]), read(d[i]), read(h[i]); for (int i = 1; i &lt;= n; i++) sline[i] = i; for (int i = 1; i &lt;= n; i++) num[i] = (h[i] - 1) / (ak - d[i]) + 1; sort(sline + 1, sline + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) pre[i] = pre[i - 1] + num[sline[i]]; LL ans = 0; for (int i = 1; i &lt;= n; i++) ans = ans + pre[i] * a[sline[i]]; printf("%lld", ans); return 0;&#125; C.city题目分析题目要求修路以及建房，且修路优先，同时，我们可以发现修路并不是独立的，路的修建方法与最优解有很大的关联，那么我们考察代价的计算方法，去掉这样的关联性，即可使用$Kruskal$最小生成树算法解决问题 我们发现，一个房子的建设代价，由两部分构成，一是自己城市的代价，二是周边城市带来的代价，我们发现，这两部分代价是独立的，而且第一部分我们可以很容易地求出，计算公式为： h[i] * \frac{(a[i] + b[i] - 1) * (a[i] - b[i])}{2}这应该很容易理解 我们下面探讨第二部分的求法，我们发现，对比两个有边直接相连且都需要建房的城市，我们一定要先在$h$值较大的城市建房，为什么呢？我们可以想上一题一样列出公式，对比两种情况下的权值并作差，即可得出这一结论，方法相同，本处不再赘述1 那么我们对于每一条边，都可以求出这条边被连接后整体答案的增加值，我们只要两边的城市互相之间的影响即可，结合上一结论即可推导出公式： r * (b[x] + b[y]) + h[y] * b[x] * (a[y] - b[y]) + h[x] * a[y] * (a[x] - b[x])那么，我们对于已经有边的，减去前面的新建费用；所有没有边的两个城市，我们把边的权值按照上述方法定义，即可去掉边代价的关联性，使用$Kruskal$最小生成树算法即可解决本题 代码注意： 边的规模往往远大于点的规模，安全的做法是分别进行宏定义，不要同时使用一个宏 对于已经建好的边，要减掉新建边的费用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 105#define maxm 100005 //需要注意的地方#define LL long long intusing namespace std;LL a[maxn];LL b[maxn];LL h[maxn];char geo[maxn][maxn];LL n, m, r;struct edge&#123; int x, y; LL len; edge(int x, int y, LL len) : x(x), y(y), len(len)&#123;&#125; edge()&#123;&#125; bool operator &lt; (const edge b) const &#123; return len &lt; b.len; &#125;&#125;e[maxm &lt;&lt; 1];int cnt = 0;void Add_Edge(int fr, int to, LL len) &#123; e[++cnt] = edge(fr, to, len);&#125;int ufs[maxn];int find_root(int x)&#123; return ufs[x] = ((ufs[x] == x) ? x : find_root(ufs[x]));&#125;LL get_len(int x, int y)&#123; if (h[x] &gt; h[y]) swap(x, y); return r * (b[x] + b[y]) + h[y] * b[x] * (a[y] - b[y]) + h[x] * a[y] * (a[x] - b[x]);&#125;void init1()&#123; for (int i = 1; i &lt;= n; i++) ufs[i] = i; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= n; j++)&#123; if (i == j) continue; if (geo[i][j] == 'N') Add_Edge(i, j, get_len(i, j)); else&#123; int x = find_root(i); int y = find_root(j); if (x == y) continue; else ufs[x] = y; &#125; &#125; &#125;&#125;LL ans1 = 0;void work1()&#123; int ct = 0; for (int i = 1; i &lt;= n; i++)&#123; if (ufs[i] == i) ct++; &#125; if (ct != 1)&#123; sort(e + 1, e + cnt + 1); for (int i = 1; i &lt;= cnt; i++)&#123; int x = find_root(e[i].x); int y = find_root(e[i].y); if (x == y) continue; ufs[x] = y; ans1 += e[i].len; &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; for (int j = i + 1; j &lt;= n; j++)&#123; if (geo[i][j] == 'Y') ans1 += get_len(i, j) - r * (b[i] + b[j]); &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; ans1 += h[i] * ((a[i] + b[i] - 1) * (a[i] - b[i]) &gt;&gt; 1); &#125;&#125;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); if (ch == '-') f = 0, ch = getchar(); x = 0; while (isdigit(ch)) x = 10l * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; //freopen("city.in", "r", stdin); //freopen("city.out", "w", stdout); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) read(b[i]); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n; i++) read(h[i]); for (int i = 1; i &lt;= n; i++) scanf("%s", geo[i] + 1); read(r); init1(); work1(); printf("%lld", ans1); return 0;&#125; 总结本套题目前两题难度较低，考察基础的编程思想与方法，最后一题考察图论的相关算法以及贡献法思维，难度较大，总体难度较为适中，命题难度编排合理，适于作为noip模拟题出现 第三题需要考虑的情况较多，尽管我确实把这些情况都进行了考虑，并且进行了正确的讨论，但最后却卡在了宏定义的问题上，导致边数组过小，程序WA了五个点，感觉还是十分可惜的，这样的问题一定要多加注意 1. 但是标程并未使用这一结论，经实际测试本结论正确 &#8617;]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>东北育才学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东北师大附中九月集训NOIP模拟赛总结]]></title>
    <url>%2F2017%2F09%2F09%2F%E4%B8%9C%E5%8C%97%E5%B8%88%E5%A4%A7%E9%99%84%E4%B8%AD%E4%B9%9D%E6%9C%88%E9%9B%86%E8%AE%ADNOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言NOIP即将到来，又是新的轮回，不知今年会怎么样…… # 东北师大附中2017.9.7 NOIP模拟赛总结题目 名次 题解官方题解 A.Cyl题目分析我们看到数据范围以后，就知道这题一定不是暴搜了对吧，然后，我们模拟操作几下，就能够发现，本题实际上就是一个情况讨论题，我们对如下三种形式的数分别进行讨论:$3k + 1, 3k + 2, 3k + 3$，得出在$n$和$m$是这三种数两两组合的情况，然后直接讨论即可，应该比较简单 但是，我们又发现，当$n$, $m$过小时，上面的规律不再使用，因为用于平衡掉余数的空间不够大，它需要往回翻，所以，对于较小的$1, 2, 3$我们再分别特殊手算一下即可 吐槽：本题没说立方体不能有一半在外面啊！！！棱不是接触就行吗？？？ 不然本题就A了。。。 代码1234567891011121314151617181920212223242526#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long intusing namespace std;int main()&#123; LL n, m; scanf("%lld%lld", &amp;n, &amp;m); if (n &gt; m) swap(n, m); if (n == 1)&#123; if (m % 3 == 1) printf("%lld", (m - 1) / 3 * 2); else printf("-1"); &#125; else if (n == 2)&#123; if (m % 3 == 1) printf("%lld", (m - 1) / 3 * 2 + 1); else printf("-1"); &#125; else if (n == 3)&#123; if (m == 3) printf("8"); else if (m % 3 == 1) printf("%lld", (n - 1) / 3 * 2 + (m - 1) / 3 * 2 + (n - 1) % 3 + (m - 1) % 3); else printf("%lld", (n - 1) / 3 * 2 + (m - 1) / 3 * 2 + (n - 1) % 3 + (m - 1) % 3 + 2); &#125; else printf("%lld", (n - 1) / 3 * 2 + (m - 1) / 3 * 2 + (n - 1) % 3 + (m - 1) % 3); return 0;&#125; B.RoundTrip题目分析我们发现这道题好像是一个经典问题，我们显然要先用Tarjan缩点，把图变成一个DAG，然后加边 因为时间不够，所以我乱讨论了一番，十分地麻烦，然后就WA了。。。 实际上有一种很简单的统计方法，我们可以发现，直接分别统计出度与入度为零的点的个数就可以，然后取个MAX，这样保证存在加边方案满足题意（想一想为什么？） 这样本题就解决了。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cctype&gt;#define maxn 100005#define maxm 1000005using namespace std;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt;&#125;int low[maxn];int pre[maxn];int sccno[maxn];bool vis[maxn];int ct = 0;int t;stack&lt;int&gt; s;int Tarjan(int x, int fa)&#123; pre[x] = low[x] = ++t; vis[x] = 1; s.push(x); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa) continue; if (!vis[op]) low[x] = min(low[x], Tarjan(op, x)); else if (!sccno[op]) low[x] = min(low[x], low[op]); &#125; if (low[x] == pre[x])&#123; ++ct; int op = s.top(); s.pop(); while (op != x)&#123; sccno[op] = ct; op = s.top(); s.pop(); &#125; sccno[x] = ct; &#125; return low[x];&#125;int in[maxn];int out[maxn];template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; int x, y; read(n), read(m); for (int i = 1; i &lt;= m; i++)&#123; read(x), read(y); Add_Edge(x, y); &#125; for (int i = 1; i &lt;= n; i++) if (!vis[i]) Tarjan(i, i); if (ct == 1) &#123; printf("0"); return 0; &#125; for (int i = 1; i &lt;= n; i++)&#123; for (int j = h[i]; j; j = e[j].next)&#123; int op = e[j].to; if (sccno[i] == sccno[op]) continue; out[sccno[i]]++; in[sccno[op]]++; &#125; &#125; int ans1 = 0; int ans2 = 0; for (int i = 1; i &lt;= ct; i++)&#123; ans1 += (!out[i]); ans2 += (!in[i]); &#125; printf("%d", max(ans1, ans2)); return 0;&#125; C.Graph题目分析本题真的是一个黑科技啊。。。居然还有这样的操作。。。 我们发现，本题如果暴力处理肯定会挂，于是我们采用特殊的方法，先观察答案路径的性质： 路径上只有两个关键点，且是路径的两个端点 长度最小 于是，我们通过第一条性质，可以对每个点暴力SPFA，搜到一个关键点就停下来，然后更新答案， 用一个栈保存更新过的结点，然后只清空这些栈中的结点距离（其实在下一场的总结中有一种技巧可以避免这样做） 然后就拿了90分。。。后来发现源点忘了入栈了，改过来就A了 —————-上面是我的方(bao)法(li)，不要被它蒙蔽了双眼。。。—————- 正解是二进制分组+多源多汇最短路(你是在跑网络流吗) 我第一次知道最短路还可以这样跑。。。其实大家都觉得二进制分组是看点，但是我觉得这种跑最短路的方法才真的应该铭记。。。 二进制分组就是按照点的标号的某一位的数(0或1）进行左右分组，对每一位都这样做，就必然可以找出答案（因为答案的两个点的标号必然不同） 然后我们新建源点与汇点，连长度为1的边，就可以狂跑最短路啦 其实分组怎么分都行。。。zgz随机化分组随手碾标程。。。 那么代码如下： 代码注意这是我的方(bao)法(li)，不喜勿喷:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cctype&gt;#define maxn 100005#define maxm 1000005using namespace std;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt;&#125;int low[maxn];int pre[maxn];int sccno[maxn];bool vis[maxn];int ct = 0;int t;stack&lt;int&gt; s;int Tarjan(int x, int fa)&#123; pre[x] = low[x] = ++t; vis[x] = 1; s.push(x); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa) continue; if (!vis[op]) low[x] = min(low[x], Tarjan(op, x)); else if (!sccno[op]) low[x] = min(low[x], low[op]); &#125; if (low[x] == pre[x])&#123; ++ct; int op = s.top(); s.pop(); while (op != x)&#123; sccno[op] = ct; op = s.top(); s.pop(); &#125; sccno[x] = ct; &#125; return low[x];&#125;int in[maxn];int out[maxn];template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; int x, y; read(n), read(m); for (int i = 1; i &lt;= m; i++)&#123; read(x), read(y); Add_Edge(x, y); &#125; for (int i = 1; i &lt;= n; i++) if (!vis[i]) Tarjan(i, i); if (ct == 1) &#123; printf("0"); return 0; &#125; for (int i = 1; i &lt;= n; i++)&#123; for (int j = h[i]; j; j = e[j].next)&#123; int op = e[j].to; if (sccno[i] == sccno[op]) continue; out[sccno[i]]++; in[sccno[op]]++; &#125; &#125; int ans1 = 0; int ans2 = 0; for (int i = 1; i &lt;= ct; i++)&#123; ans1 += (!out[i]); ans2 += (!in[i]); &#125; printf("%d", max(ans1, ans2)); return 0;&#125; 这是正解:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/****************************************\* Author : ztx* Title : std-graph* ALG : 最短路* CMT : 按照二进制拆分进行log(n)次最短路* Time : 2016-10-19\****************************************/#include &lt;cstdio&gt;#define Rep(i,l,r) for(i=(l);i&lt;=(r);i++)#define rep(i,l,r) for(i=(l);i&lt; (r);i++)#define Rev(i,r,l) for(i=(r);i&gt;=(l);i--)#define rev(i,r,l) for(i=(r);i&gt; (l);i--)typedef long long ll ;typedef double lf ;int CH , NEG ;template &lt;typename TP&gt;inline void read(TP&amp; ret) &#123; ret = NEG = 0 ; while (CH=getchar() , CH&lt;'!') ; if (CH == '-') NEG = true , CH = getchar() ; while (ret = ret*10+CH-'0' , CH=getchar() , CH&gt;'!') ; if (NEG) ret = -ret ;&#125;template &lt;typename TP&gt;inline void readc(TP&amp; ret) &#123; while (ret=getchar() , ret&lt;'!') ; while (CH=getchar() , CH&gt;'!') ;&#125;template &lt;typename TP&gt;inline void reads(TP *ret) &#123; ret[0]=0;while (CH=getchar() , CH&lt;'!') ; while (ret[++ret[0]]=CH,CH=getchar(),CH&gt;'!') ; ret[ret[0]+1]=0;&#125;#include &lt;cstring&gt;#include &lt;deque&gt;#define maxn 100010LL#define maxm 500010LL#define maxk 233330LLint e[3][(maxm&lt;&lt;1)+maxn], star[maxn], tote = 1;int rstar[maxn], rtote;#define to(p) e[0][p]#define nxt(p) e[1][p]#define len(p) e[2][p]#define ft q.front()#define bk q.back()#define pf(x) q.push_front(x)#define pb(x) q.push_back(x)#define pop q.pop_front()#define infi 0x3f3f3f3fLLinline void AddEdge(int u,int v,int w) &#123; tote ++ , to(tote) = v, len(tote) = w, nxt(tote) = star[u], star[u] = tote;&#125;int n, m, s;int S[maxk];int dis[maxn];bool inq[maxn];std::deque&lt;int&gt;q;inline void work() &#123; int i, k, u, v, w, p, ans; /// tote = 1, memset(star,0,sizeof star); Rep (i,1,m) read(u), read(v), read(w), AddEdge(u,v,w), AddEdge(v,u,w); //puts("!!!!!"); memcpy(rstar,star,sizeof star); rtote = tote; Rep (i,1,s) read(S[i]); //puts("!!!!!"); ans = infi; rep (k,0,20) &#123; /// build the graph memcpy(star,rstar,sizeof rstar); tote = rtote; Rep (i,1,s) if (S[i]&amp;(1&lt;&lt;k)) AddEdge(n+1,S[i],0); else AddEdge(S[i],n+2,0); /// spfa q.clear(); memset(dis,0x3f,sizeof dis); dis[n+1]=0; pb(n+1); while (!q.empty()) for (u=ft,pop,inq[u]=false,p=star[u];p;p=nxt(p)) if (v=to(p),dis[u]+len(p)&lt;dis[v]) if (dis[v]=dis[u]+len(p),!inq[v]) if (inq[v]=true,!q.empty()&amp;&amp;dis[v]&lt;dis[ft]) pf(v); else pb(v); if (dis[n+2] &lt; ans) ans = dis[n+2]; &#125; printf("%d\n", ans);&#125;int main() &#123; #define READ #ifdef READ freopen("graph.in" ,"r",stdin ) ; freopen("graph.out","w",stdout) ; #endif while (scanf("%d%d%d", &amp;n, &amp;m, &amp;s) != EOF &amp;&amp; n+m+s&gt;0) work(); #ifdef READ fclose(stdin) ; fclose(stdout) ; #else getchar() ; getchar() ; #endif return 0 ;&#125; 总结本次题目较为简单， 但未能取得高分，原因有三点：一是题面叙述不够清楚，二是时间安排不够合理，在思考题目上花费了较多时间，导致检查时间不够，三是知识欠缺，未能用正确的方法通过问题 东北师大附中2017.9.9 NOIP模拟赛总结题目 名次 题解A.公约数题目分析自己在做的时候，感觉这题以前好像做过，然后好像是一个不等关系，然后能推出来一堆东西，于是就按照这个思路试了一下，先写了一个找规律的程序，把所有可能的对都打了出来，然后观察了一会，发现数对都是这样的形式（假设$c = gcd(a,b)$）： (a, b) = (a, a + c)但是在后面还有一些不太满足这个规律的，然后就想在二进制意义下各种乱搞证明。。。 于是就。。。浪费了大把的时间 后来还是想回到最开始的思路上，直接用不等关系证明，于是瞬间就推了出来。。。如下（不妨设$x \geq y$）： \begin{align} gcd(x, y) &= x \oplus y\\ gcd(x, y) \oplus y&= x\\ x &\leq gcd(x, y) + y\\ \end{align}所以，我们就知道了：$x = y + gcd(x, y)$ 上面的规律到此就被证明了，于是我们就此以及调和级数定理设计一个“枚举”算法：先枚举gcd，然后里面扫描每一个数，判断是否有$x \oplus (x + gcd) = gcd$即可 这样本题就在$O(n \log n)$内解决了 同时，我们把上面用到的一个不等式： x \oplus y \leq x + y称作异或不等式，便于以后的应用 给我的启示就是，有题快做，一定不要死扣证明，如果实在拿不准就先做别的题，这样才是真正的noip模拟 官方题解 代码居然这么**短。。。1234567891011121314151617#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n, ans;int main()&#123; //freopen("gcd.in", "r", stdin); //freopen("gcd.out", "w", stdout); scanf("%d", &amp;n); for (int d = 1; d &lt;= (n &gt;&gt; 1); d++)&#123; for (int i = d; i &lt;= n - d; i += d)&#123; if ((i ^ (i + d)) == d) ans++; &#125; &#125; printf("%d", ans); return 0;&#125; B.树上路径题目分析本题看上去就是一个点分治，一开始以为二分，然后就反应过来直接点分治就可以，那么具体细节就不说了，还是注意全局变量的可变性，注意清空用完的数组变量等，注意判断点是否已经被访问过，以及注意多重循环嵌套时不要使用重复的循环变量等等。。。 但是，这次这些问题都没有犯，而是犯了STL错误：set决不能使用STL的二分查找，只能使用自己的成员函数，还有一点错误，就是不要考察每个长度，只需要考虑二分后最短的原先存在的长度加上当前正在考虑的这条链的长度是否在范围内就可以，否则复杂度就是$O(n^2\log^2 n)$的了，这种细节都要注意 官方题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;#define maxn 1000005#define INF 2000000005using namespace std;int n, s, t;struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int x, int y, int len)&#123; e[++cnt] = edge(h[x], y, len); h[x] = cnt; e[++cnt] = edge(h[y], x, len); h[y] = cnt;&#125;bool vis[maxn];int siz[maxn];int g;int as;void DFS1(int x, int fa)&#123; bool f = 1; siz[x] = 1; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (vis[op] || op == fa) continue; DFS1(op, x); siz[x] += siz[op]; if (siz[op] &gt; (as &gt;&gt; 1)) f = 0; &#125; if (as - siz[x] &gt; (as &gt;&gt; 1)) f = 0; if (f) g = x;&#125;int d[maxn];set&lt;int&gt; s1;int s2[maxn];int ct2 = 0;void DFS2(int x, int fa)&#123; s2[++ct2] = d[x]; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || vis[op]) continue; d[op] = d[x] + e[i].len; DFS2(op, x); &#125;&#125;int ans = INF;void DAC(int x)&#123; int ns = as; DFS1(x, x); x = g; s1.insert(0); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (vis[op]) continue; d[op] = e[i].len; DFS2(op, x); for (int j = 1; j &lt;= ct2; j++)&#123; set&lt;int&gt; :: iterator it1 = s1.lower_bound(s - s2[j]); int d = s2[j] + (*it1); if (s &lt;= d &amp;&amp; d &lt;= t) ans = min(ans, d); &#125; for (int j = 1; j &lt;= ct2; j++) s1.insert(s2[j]); ct2 = 0; &#125; s1.clear(); vis[x] = 1; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (vis[op]) continue; if (siz[op] &gt; siz[x]) as = ns - siz[x]; else as = siz[op]; DAC(op); &#125;&#125;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; x = 0; while (!isdigit(ch) &amp;&amp; ch != '-') ch = getchar(); if (ch == '-') f = 0, ch = getchar(); while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; //freopen("path.in", "r", stdin); //freopen("path.out", "w", stdout); int x, y, z; read(n), read(s), read(t); for (int i = 1; i &lt; n; i++)&#123; read(x), read(y), read(z); Add_Edge(x, y, z); &#125; as = n; DAC(1); if (ans &lt; INF) printf("%d", ans); else printf("-1"); return 0;&#125; C.飞扬的小鸟题目分析我们一看完题，就可以联想到SCOI的一道修车题，这两道题看上去简直是一毛一样的，于是我也几乎写了一毛一样的代码，然后就华丽的TLE了。。。 后来仔细地看了看，数据范围好像不太一样。。。这道题的范围好像很难承受，于是就水了题解。。。发现这题竟然使用了动态加边的技巧，然而以前从来没写过。。。都不知道怎么动态加边，于是又水了一发标程，于是就学会了 然而调了半天没搞出来，最后发现是点的标号有问题，标的有重复，然后就一直玄学地TLE。。。改完就过了 但是学到了新的东西，还是很开心的，这样动态加边也算是写过了，同时还学到一个东西：在多次SPFA的时候不必重新设定数组，而是新开一个标记数组表示这是第几次SPFA就可以了，可以节约许多的时间 官方题解 代码一开始以为是最大流，顺手就打出来了，然后发现不是，就又写了费用流。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define maxn2 105#define maxm2 205#define maxn 100005#define maxm 10000005#define INF 2000000005using namespace std;/*int n, m, s, t;struct edge&#123; int next, to, flow; edge(int next, int to, int flow) : next(next), to(to), flow(flow)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, int flow)&#123; e[++cnt] = edge(h[fr], to, flow); h[fr] = cnt; e[++cnt] = edge(h[to], fr, 0); h[to] = cnt;&#125;bool BFS()&#123; queue&lt;int&gt; bfs; bfs.push(s); memset(d, 0, sizeof(d)); while (!bfs.empty())&#123; int op = bfs.front();bfs.pop(); for (int i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int k = e[i].to; if (k == s || d[k]) continue; d[k] = d[op] + 1; bfs.push(k); &#125; &#125; if (!d[t]) return false; return true;&#125;int DFS(int x, int a)&#123; if (x == t) return a; int rest = a; for (int i = h[x]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int op = e[i].to if (d[op] != d[x] + 1) continue; int k = DFS(op, min(rest, e[i].flow)); e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; if (!rest) return a; &#125; return a - rest;&#125;void Dinic(int&amp; maxflow)&#123; while (BFS()) maxflow += DFS(s, INF);&#125;*/int n, m, s, t;int p2[maxn2];int geo[maxn2][maxm2];struct edge&#123; int next, to, flow, cost; edge(int next, int to, int flow ,int cost) : next(next), to(to), flow(flow), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, int flow, int cost)&#123; e[++cnt] = edge(h[fr], to, flow, cost); h[fr] = cnt; e[++cnt] = edge(h[to], fr, 0, -cost); h[to] = cnt;&#125;int p[maxn];int d[maxn];bool vis[maxn];int dt[maxn];int ti = 0;int spfa[maxn];int l, r;bool SPFA()&#123; l = 0, r = -1; spfa[++r] = s; vis[s] = 1; d[s] = 0; dt[s] = ++ti; while (l &lt;= r)&#123; int op = spfa[l++]; for (int i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int k = e[i].to; if (dt[k] != ti || d[k] &gt; d[op] + e[i].cost)&#123; p[k] = i; dt[k] = ti; d[k] = d[op] + e[i].cost; if (!vis[k]) spfa[++r] = k, vis[k] = 1; &#125; &#125; vis[op] = 0; &#125; if (dt[t] != ti) return false; return true;&#125;int sum = 0;int rec[maxn];int pos[maxn];void Augment(int&amp; maxflow, int&amp; mincost)&#123; int now = t, flow = INF; while (now != s)&#123; int k = p[now]; flow = min(flow, e[k].flow); now = e[k ^ 1].to; &#125; now = t; while (now != s)&#123; int k = p[now]; e[k].flow -= flow; e[k ^ 1].flow += flow; now = e[k ^ 1].to; &#125; maxflow += flow, mincost += flow * (d[t] - d[s]); now = t; if (!e[p[now]].flow &amp;&amp; now != t - 1)&#123; now = e[p[now] ^ 1].to; rec[pos[now + 1]]++; for (int i = 1; i &lt;= n; i++)&#123; Add_Edge(i, now + 1, 1, rec[pos[now + 1]] * geo[i][pos[now + 1]]); &#125; Add_Edge(now + 1, t, 1, 0); &#125;&#125;void MCMF(int&amp; maxflow, int&amp; mincost)&#123; while (SPFA()) Augment(maxflow, mincost);&#125;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; x = 0; while (!isdigit(ch) &amp;&amp; ch != '-') ch = getchar(); if (ch == '-') f = 0, ch = getchar(); while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; //freopen("flappy.in", "r" ,stdin); //freopen("flappy.out", "w", stdout); int x, y; read(n), read(m); s = 0; for (int i = 1; i &lt;= n; i++) read(p2[i]), sum += p2[i], Add_Edge(s, i, p2[i], 0); for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; read(geo[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; rec[j] = 1; Add_Edge(i, (j - 1) * sum + 1 + n, 1, geo[i][j]); &#125; &#125; for (int i = 1 + n; i &lt;= sum * m + n; i++)&#123; pos[i] = (i - 1 - n) / sum + 1; &#125; t = n + sum * m + 1; for (int j = 1; j &lt;= m; j++)&#123; Add_Edge((j - 1) * sum + 1 + n, t, 1, 0); &#125; int maxflow = 0, mincost = 0; MCMF(maxflow, mincost); printf("%d", mincost); return 0;&#125; 总结本次题目难度不大，但是技巧性强，没能拿到高分的确是一种失误，注意日后的模拟要严格按照真实考试模式进行，尽可能节约时间，并尽快写完，调试代码]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>东北师大附中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总VI]]></title>
    <url>%2F2017%2F09%2F07%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBVI%2F</url>
    <content type="text"><![CDATA[引言I love you, really … don’t forget me … Problem 3697. -- 采药人的路径3697: 采药人的路径Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 1240&nbsp;&nbsp;Solved: 428[Submit][Status][Discuss]Description采药人的药田是一个树状结构，每条路径上都种植着同种药材。 采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。 采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。Input第1行包含一个整数N。 接下来N-1行，每行包含三个整数a_i、b_i和t_i，表示这条路上药材的类型。Output输出符合采药人要求的路径数目。Sample Input 7 1 2 0 3 1 1 2 4 0 5 2 0 6 3 1 5 7 1 Sample Output 1HINT 对于100%的数据，N &le; 100,000。 Source Tags: 树 点分治 题目分析树上链状信息统计问题 本题显然是要使用点分治的，那么主要的问题就是如何表示中间有一个休息站，我们首先定义一下结点的权值：从根到这个点的路径中阳性-阴性的草药的差，则中间有一个休息站就是一个节点的前面有一个与它权值相同的结点，或是另外一条链上有这样的点对，再或者就是两条链上分别有权值互为相反数的点 于是我们分类讨论一下就可以了，另外要特别注意权值为0的点的处理（其实需要特别处理吗？？？好像不需要。。。） 代码注意：注意全局变量的全局性，不要在递归几次以后继续在当前层使用全局变量！！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define LL long long intusing namespace std;struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, int len)&#123; e[++cnt] = edge(h[fr], to, len); h[fr] = cnt; e[++cnt] = edge(h[to], fr, len); h[to] = cnt;&#125;int as;bool vis[maxn];int si[maxn];int g;void find_r(int x, int fa)&#123; si[x] = 0; bool f = 1; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || vis[op]) continue; find_r(op, x); si[x] += si[op]; if (si[op] &gt; as &gt;&gt; 1) f = 0; &#125; si[x]++; if (as - si[x] &gt; as &gt;&gt; 1) f = 0; if (f) g = x;&#125;int s[2][maxn &lt;&lt; 1];int t[maxn &lt;&lt; 1];LL ans = 0;void get_ans(int x, int fa, int now)&#123; t[now + maxn]++; if (t[now + maxn] == 1) ans += s[1][maxn - now]; else ans += s[0][maxn - now] + s[1][maxn - now]; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || vis[op]) continue; get_ans(op, x, now + e[i].len); &#125; t[now + maxn]--;&#125;void update(int x, int fa, int now, int p)&#123; t[now + maxn]++; if (t[now + maxn] == 1) s[0][now + maxn] += p; else s[1][now + maxn] += p; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || vis[op]) continue; update(op, x, now + e[i].len, p); &#125; t[now + maxn]--;&#125;void work(int x, int ns)&#123; as = ns; find_r(x, x); x = g; s[0][maxn]++; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (vis[op]) continue; get_ans(op, x, e[i].len); t[maxn]++; update(op, x, e[i].len, 1); t[maxn]--; &#125; update(x, x, 0, -1); vis[x] = 1; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (vis[op]) continue; if (si[op] &gt; si[x]) work(op, ns - si[x]); else work(op, si[op]); &#125;&#125;int main()&#123; int n, x, y, z; scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (z == 1) Add_Edge(x, y, 1); else Add_Edge(x, y, -1); &#125; work(1, n); printf("%lld", ans); return 0;&#125; Problem 3626. -- [LNOI2014]LCA3626: [LNOI2014]LCATime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 2998&nbsp;&nbsp;Solved: 1178[Submit][Status][Discuss]Description给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。 设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。 有q次询问，每次询问给出l r z，求sigma_{l&lt;=i&lt;=r}dep[LCA(i,z)]。 （即，求在[l,r]区间内的每个节点i与z的最近公共祖先的深度之和） Input第一行2个整数n q。 接下来n-1行，分别表示点1到点n-1的父节点编号。 接下来q行，每行3个整数l r z。 Output输出q行，每行表示一个询问的答案。每个答案对201314取模输出 Sample Input 5 2 0 0 1 1 1 4 3 1 4 2 Sample Output 8 5 HINT 共5组数据，n与q的规模分别为10000,20000,30000,40000,50000。 Source 数据已加强 by saffah Tags: 树 LCA LCA理解 询问拆分法 题目分析批量LCA深度和问题 这题的思路非常好，我们发现一个一个求肯定是不行的对吧， 肯定要把信息记录在树上便于以后的查询，联系LCA的定义，我们可以发现，我们可以把从根到每个在询问区间内的结点的路径上的点的权值都加1，然后直接求当前结点到根的路径权值就可以了 最后为了方便处理，我们使用询问拆分法，把一个询问拆分成两个前缀作差的形式 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define M 201314using namespace std;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int cnt = 1, h[maxn];void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int f[maxn];int son[maxn];int si[maxn];int dfs[maxn];int idfs[maxn];int top[maxn];int d[maxn];int t;void DFS1(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == f[x]) continue; f[op] = x; d[op] = d[x] + 1; DFS1(op); si[x] += si[op]; if (si[op] &gt; si[son[x]]) son[x] = op; &#125; si[x]++;&#125;void DFS2(int x, int tp)&#123; dfs[x] = ++t; idfs[t] = x; top[x] = tp; if (son[x]) DFS2(son[x], tp); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == f[x] || op == son[x]) continue; DFS2(op, op); &#125;&#125;int sum[maxn &lt;&lt; 1];int add[maxn &lt;&lt; 1];int qx, qy, qd;void pushup(int l, int r, int o)&#123; if (l == r) return; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void pushdown(int l, int r, int o)&#123; if (add[o] &amp;&amp; l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; add[o &lt;&lt; 1] += add[o]; sum[o &lt;&lt; 1] += add[o] * (mid + 1 - l); add[o &lt;&lt; 1 | 1] += add[o]; sum[o &lt;&lt; 1 | 1] += add[o] * (r - mid); add[o] = 0; &#125;&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; add[o] += qd; sum[o] += (r - l + 1) * qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; return sum[o]; &#125; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o); return ans;&#125;void init()&#123; DFS1(1); DFS2(1, 1);&#125;int ans[maxn];struct query&#123; int x, z, id, t; query(int x, int z, int id, int t) : x(x), z(z), id(id), t(t)&#123;&#125; query()&#123;&#125;&#125;q[maxn];bool cmp1(query a, query b)&#123; return a.x &lt; b.x;&#125;void modify_path_to_root(int x)&#123; int f1 = top[x]; while (f1 != 1)&#123; qx = dfs[f1], qy = dfs[x], qd = 1; modify(1, n, 1); x = f[f1]; f1 = top[x]; &#125; qx = 1, qy = dfs[x], qd = 1; modify(1, n, 1);&#125;int get_path_to_root(int x)&#123; int f1 = top[x]; int ans = 0; while (f1 != 1)&#123; qx = dfs[f1], qy = dfs[x]; ans += get(1, n, 1); x = f[f1]; f1 = top[x]; &#125; qx = 1, qy = dfs[x]; ans += get(1, n, 1); return ans;&#125;void work()&#123; int cur = 0; for (int i = 0; i &lt; m &lt;&lt; 1; i++)&#123; while (cur &lt; q[i].x)&#123; modify_path_to_root(++cur); &#125; ans[q[i].id] += q[i].t * get_path_to_root(q[i].z); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int x, z, l, r; for (int i = 2; i &lt;= n; i++)&#123; scanf("%d", &amp;x); Add_Edge(x + 1, i); &#125; init(); for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;z); q[i &lt;&lt; 1] = query(l, z + 1, i, -1); q[(i &lt;&lt; 1) + 1] = query(r + 1, z + 1, i, 1); &#125; sort(q, q + (m &lt;&lt; 1), cmp1); work(); for (int i = 0; i &lt; m; i++)&#123; printf("%d\n", ans[i] % M); &#125; return 0;&#125; Problem 3381. -- [Usaco2004 Open]Cave Cows 2 洞穴里的牛之二3381: [Usaco2004 Open]Cave Cows 2 洞穴里的牛之二Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 73&nbsp;&nbsp;Solved: 58[Submit][Status][Discuss]Description&nbsp;&nbsp;&nbsp;&nbsp;洞窟里有一道长长的通道．它由N(1&le;N&le;25000)段道尾相连构成，编号分别为1到N．每个通道有一个阈值，其范围在[1，10^9]依次通过i..j的通道，那奶牛的体重指数就不能超过i..j通道中阈值的最小值．贝茜有Q(1&le;Q&le;25000)个问题，想请教你由i到j的通道的阈值的最小值．Input&nbsp;&nbsp;&nbsp;&nbsp;第1行输入N和Q，接下来N行输入每个通道的阈值，之后Q行每行两个整数，对应问题中的i和j（i&lt;j）．Output&nbsp;&nbsp;&nbsp;对于每个问题，输出其结果．Sample Input 10 4 75 30 100 38 50 51 52 20 81 5 1 10 3 5 6 9 8 10Sample Output 5 38 20 5HINT Source Orange Tags: 数据结构 ST表 题目分析区间静态最小问题直接RMQ即可。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005using namespace std;int n;int line[maxn];int lo[maxn];int mi[maxn];int rmq[maxn][30];void init()&#123; mi[0] = 1; for (int i = 1; i &lt; 30; i++) mi[i] = mi[i - 1] &lt;&lt; 1; lo[0] = lo[1] = 0; for (int i = 2; i &lt;= n; i++) lo[i] = lo[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= n; i++) rmq[i][0] = line[i]; for (int j = 1; mi[j] &lt;= n; j++)&#123; for (int i = 1; i &lt;= n; i++)&#123; if (i + mi[j - 1] &lt;= n) rmq[i][j] = min(rmq[i][j - 1], rmq[i + mi[j - 1]][j - 1]); else rmq[i][j] = rmq[i][j - 1]; &#125; &#125;&#125;void query(int x, int y)&#123; int now = lo[y - x + 1]; printf("%d\n", min(rmq[x][now], rmq[y - mi[now] + 1][now]));&#125;int main()&#123; int x, y, q; scanf("%d%d", &amp;n, &amp;q); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); init(); for(int i = 0; i &lt; q; i++)&#123; scanf("%d%d", &amp;x ,&amp;y); query(x, y); &#125; return 0;&#125; Problem 4146. -- [AMPPZ2014]Divisors4146: [AMPPZ2014]DivisorsTime Limit: 20 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 675&nbsp;&nbsp;Solved: 374[Submit][Status][Discuss]Description给定一个序列a[1],a[2],...,a[n]。求满足i!=j且a[i]|a[j]的二元组(i,j)的个数。 Input第一行包含一个正整数n(1&lt;=n&lt;=2000000)，表示序列长度。 第二行包含n个正整数，依次表示a[1],a[2],...,a[n](1&lt;=a[i]&lt;=2000000)。 Output一个整数，即满足条件的二元组的个数。 Sample Input 5 2 4 5 2 6Sample Output 6HINT 满足条件的6组分别为(1,2),(1,4),(1,5),(4,1),(4,2),(4,5)。 Source 鸣谢Claris上传 Tags: 数学 整除问题 题目分析多基数整除问题处理这样的问题，我们要联想到一个结论：调和级数上界 我们继续考虑这样的思路，那么我们只需要先保存每种数字有多少个，然后从小到大对倍数进行扫描求和即可 代码123456789101112131415161718192021222324252627#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 2000005#define LL long long intusing namespace std;int num[maxn];int line[maxn];int n;int main()&#123; scanf("%d", &amp;n); int tn = n; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;line[i]); num[line[i]]++; &#125; sort(line + 1, line + 1 + n); n = unique(line + 1, line + 1 + n) - line - 1; LL ans = 0; for(int i = 1; i &lt;= n; i++)&#123; for (int j = 1; line[i] * j &lt;= line[n]; j++)&#123; ans += (LL)num[line[i]] * num[j * line[i]]; &#125; &#125; printf("%lld", ans - tn); return 0;&#125; Problem 4390. -- [Usaco2015 dec]Max Flow4390: [Usaco2015 dec]Max FlowTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 270&nbsp;&nbsp;Solved: 169[Submit][Status][Discuss]DescriptionFarmer John has installed a new system of N&minus;1 pipes to transport milk between the N stalls in his barn (2&le;N&le;50,000), conveniently numbered 1&hellip;N. Each pipe connects a pair of stalls, and all stalls are connected to each-other via paths of pipes. FJ is pumping milk between KK pairs of stalls (1&le;K&le;100,000). For the iith such pair, you are told two stalls sisi and titi, endpoints of a path along which milk is being pumped at a unit rate. FJ is concerned that some stalls might end up overwhelmed with all the milk being pumped through them, since a stall can serve as a waypoint along many of the KK paths along which milk is being pumped. Please help him determine the maximum amount of milk being pumped through any stall. If milk is being pumped along a path from sisi to titi, then it counts as being pumped through the endpoint stalls sisi and titi, as well as through every stall along the path between them. 给定一棵有N个点的树，所有节点的权值都为0。 有K次操作，每次指定两个点s,t，将s到t路径上所有点的权值都加一。 请输出K次操作完毕后权值最大的那个点的权值。 InputThe first line of the input contains NN and KK. The next N&minus;1 lines each contain two integers x and y (x&ne;y，x&ne;y) describing a pipe between stalls x and y. The next K lines each contain two integers ss and t describing the endpoint stalls of a path through which milk is being pumped.OutputAn integer specifying the maximum amount of milk pumped through any stall in the barn.Sample Input 5 10 3 4 1 5 4 2 5 4 5 4 5 4 3 5 4 3 4 3 1 3 3 5 5 4 1 5 3 4Sample Output 9HINT Source Platinum鸣谢Claris提供译文 Tags: 树 树上差分 题目分析树上链状信息维护问题 我也不知道这种问题应该称作什么。。。其实树剖即可解决，但为了体现本题的价值，我们使用树上差分，就是LCA与其父亲各减一，两个端点加一，注意LCA为根时的情况 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2000000005#define maxn 200005using namespace std;int n, k; struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int d[maxn];int fa[maxn][30];void DFS(int x)&#123; for (int i = 1; i &lt; 30; i++)&#123; fa[x][i] = fa[fa[x][i - 1]][i - 1]; &#125; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x][0]) continue; fa[op][0] = x; d[op] = d[x] + 1; DFS(op); &#125;&#125;int get_lca(int x, int y)&#123; if (x == y) return x; if (d[x] &lt; d[y]) swap(x, y); int k = d[x] - d[y]; int con = 0; while (k)&#123; if (k &amp; 1) x = fa[x][con]; con++; k &gt;&gt;= 1; &#125; if (x == y) return y; while (true)&#123; int s = 0; while (fa[x][s] != fa[y][s]) s++; if (s == 0) return fa[x][0]; s--; x = fa[x][s]; y = fa[y][s]; &#125;&#125;int val[maxn];int ans = -INF;void get(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x][0]) continue; get(op); val[x] += val[op]; &#125; ans = max(ans, val[x]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); int x, y; for (int i = 1; i &lt; n; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; fa[1][0] = 0; DFS(1); for (int i = 0; i &lt; k; i++)&#123; scanf("%d%d", &amp;x, &amp;y); int lca = get_lca(x, y); val[lca]--, val[fa[lca][0]]--; val[x]++, val[y]++; &#125; get(1); printf("%d", ans); return 0;&#125; Problem 4896. -- [Thu Summer Camp2016]补退选4896: [Thu Summer Camp2016]补退选Time Limit: 20 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 505&nbsp;&nbsp;Solved: 165[Submit][Status][Discuss]DescriptionX是T大的一名老师，每年他都要教授许多学生基础的C++知识。在T大，每个学生在每学期的开学前都需要选课，每 次选课一共分为三个阶段：预选，正选，补退选；其中&quot;补退选&quot;阶段最忙碌。在补退选阶段，学生即可以选课，也 可以退课。对于X老师来说，在补退选阶段可能发生以下两种事件： 1:一个姓名为S的学生选了他的课（姓名S将出现在X的已选课学生名单中） 2:一个姓名为S的学生退了他的课（姓名S将从X的已选课学生名单中移除） 同时，X老师对于有哪些学生选了他的课非常关心，所以他会不定时的查询已选课学生名单，每次查询的格式如下 ：最早在哪个事件之后，姓名以S为前缀的学生数量超过了vX老师看你骨骼惊奇，所以想用这个问题考考你，你当 然不会畏惧，所以勇敢的接下了这个任务。 注意1：学生的姓名可能相同，如果有p个姓名相同的学生都选了X老师的课，则他们的姓名将出现在X老师的名单上p次。 注意2：只有已经选了课的学生才会退课，如果姓名为S的学生退课，则在他退课之前X老师的名单上一定有姓名S。 注意3：选课，退课和查询都被定义为&quot;事件&quot;，&quot;事件&quot;的编号从1开始Input 第一行包含一个正整数n，表示一共发生了n个事件。 接下来n行，每行描述一个事件；每行第一个正整数k表示事件类型： 1.如果k=1，表示选课事件，接下来一个字符串S，表示一个姓名为S的学生选了X老师的课 2.如果k=2，表示退课事件，接下来一个字符串S，表示一个姓名为S的学生退了X老师的课 3.如果k=3，表示查询事件，接下来一个字符串S以及三个非负整数a,b,c，表示X老师想知道最早在第几个事件之后 ，姓名以S为前缀的学生数量超过了(a*|ANS|+b)%c，|ANS|表示上次查询事件的答案的绝对值，如果当前是第一次 查询，则|ANS|=0；如果任何时刻都没有超过该值，则答案为-1。注：输入中的所有字符串均只包含小写字母。 Output 对于每个查询事件，输出一行表示该查询答案。 Sample Input 6 1 lcaq 3 lca 0 0 5 1 lcq 3 lc 0 1 5 2 lcaq 3 lc 0 1 5Sample Output 1 3 3HINT n&lt;=100000，字符串长度 &lt;= 60，输入中的所有字符串只会包含前 10 个小写字母Source 鸣谢Sengxian上传 Tags: 二分答案 字符串 可持久化Trie 题目分析多版本信息维护问题清华夏令营好题，我们首先肯定能想到可持久化Trie对吧，实际上确实可以这样写，我们多维护一个maxval成员变量，表示这个节点的历史最大值是多少，然后直接二分查找即可 但是还有人好像是用vector直接暴力存储的，个人感觉不是很好。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 5000005#define sigma 12using namespace std;int ch[maxn][sigma];int maxnum[maxn];int h[maxn];int val[maxn];int cnt = 0;char s[maxn];int len;int k;int ord[maxn];void insert(int v)&#123; int now = ++cnt; h[k] = cnt; int pre = h[k - 1]; for (int i = 0; i &lt;= len; i++)&#123; memcpy(ch[now], ch[pre], sizeof(ch[pre])); maxnum[now] = maxnum[pre]; val[now] = val[pre]; val[now] += v; if (val[now] &gt; maxnum[now]) maxnum[now] = val[now]; if (i &lt; len)&#123; ch[now][s[i] - 'a'] = ++cnt; pre = ch[pre][s[i] - 'a']; now = ch[now][s[i] - 'a']; &#125; &#125;&#125;char qs[maxn];int lenq;int qd;bool query(int pos)&#123; int now = h[pos]; for (int i = 0; i &lt; lenq; i++)&#123; now = ch[now][qs[i] - 'a']; if (!now) return false; &#125; if (maxnum[now] &gt; qd) return true; return false;&#125;int binary_search(int l, int r)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (query(mid)) return binary_search(l, mid); else return binary_search(mid + 1, r);&#125;int ans = 0;int main()&#123; int n, a, b, c, op; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;op); if (op == 1)&#123; ord[++k] = i; scanf("%s", s); len = strlen(s); insert(1); &#125; else if (op == 2)&#123; ord[++k] = i; scanf("%s", s); len = strlen(s); insert(-1); &#125; else &#123; scanf("%s%d%d%d", qs, &amp;a, &amp;b, &amp;c); lenq = strlen(qs); qd = ((long long int)a * abs(ans) + b) % (long long int)c; ans = binary_search(1, k + 1); if (ans == k + 1) ans = -1; else ans = ord[ans]; printf("%d\n", ans); &#125; &#125; return 0;&#125; Problem 4757. -- [Usaco2017 Jan]Building a Tall Barn4757: [Usaco2017 Jan]Building a Tall BarnTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 129&nbsp;&nbsp;Solved: 38[Submit][Status][Discuss]DescriptionFarmer John is building a brand new, N-story barn, with the help of his KK cows (1≤N≤K≤1012 and N ≤10^5). To build it as quickly as possible, he needs your help to figure out how to allocate work a mong the cows.Each cow must be assigned to work on exactly one specific floor out of the N total flo ors in the barn, and each floor must have at least one cow assigned to it. The iith floor requires a iai units of total work, and each cow completes one unit of work per hour, so if cc cows work on flo or i, it will be completed in ai/c units of time. For safety reasons, floor ii must be completed bef ore construction can begin on floor i+1Please compute the minimum total time in which the barn can b e completed, if the cows are allocated to work on floors in an optimal fashion. Output this number r ounded to the nearest integer; it is guaranteed that the solution will be more than 0.1 from the bou ndary between two integers. 给定长度为N的序列ai，对每个ai分配ci使得ci&gt;0(ci为整数)且ci之和等于K，求出最小的ai/ci之和 InputThe first line of input contains N and K. The next N lines contain a1…aN, each a positive integer of size at most 1012 OutputPlease output the minimum time required to build the barn, rounded to the nearest integer. Sample Input 2 5 10 4Sample Output 5HINT source Platinum Tags: 二分答案 调整思想 单调性 题目分析我们发现，题目中固定的东西只有所有$a_i$以及所有$c_i$的和，所以我们肯定是要在这两个已知条件的基础上进行推导，我们可以尝试进行调整，即只对其中两个$a_i$进行分析，假设这两个变量分别为$a_i$与$a_j$ 并且分配给这两个变量的$c$的值分别为$c_i$与$c_j$，那么我们把第一个$c$加一，第二个$c$减一会发生什么呢？由于我们要求的是最小的和，那么如果交换以后，这个和变小了，那么我们就可以接受它 所以，我们现在的想法就是，如何进行这样的调动使得最后的总和最小 我们定义每一个$a_i$的调动价值为$F(i) = \frac{a_i}{c_i}- \frac{a_i}{c_i + 1}$，可以发现，从这个调动价值小的$a_i$那里分配一个$c$给该值较大的$a_j$是划算的，这是因为，有$F(i) - F(j) &lt; 0$，而且，这样做完以后，我们可以发现$F(i)$增大而$F(j)$减小，这说明当所有$a_i$的调动价值都十分接近的时候达到最优，于是，我们可以反复进行这样的交换，直到所有的$a_i$之间的调动价值都趋于相等 除此以外，我们还发现，当调动价值增加的时候，$c$是减小的，但是为了使答案最优，我们应该让每个$c$都尽可能大才行，所以我们就可以根据这个单调性二分答案 那么，我们就可以考虑二分最小的调动价值，并由此解出所有的$c _ i$，计算看它们的和是否超过$k$，再由此二分，最后我们就能得到一个相对正确的值 那么这个值的意义是什么呢？我们得到这个值以后，按照这个值求出的$c _ i$就是最优的分配方案，直接按这个方案计算答案就可以了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 1000005#define INF 2000000005#define LL long long int#define eps 1e-13using namespace std;int n;LL k;double a[maxn];LL cal(double x)&#123;return (LL)((sqrt(1+4*x)-1)/2);&#125;bool judge(double x)&#123; LL ans = 0; for (int i = 1; i &lt;= n; i++)&#123; ans += cal(a[i]/x); &#125; if (ans &lt;= k - n) return true; return false;&#125;double work(double l, double r)&#123; if (r - l &lt; eps) return l; double mid = ((r - l) / 2) + l; if (judge(mid)) return work(l, mid); else return work(mid, r);&#125;int main()&#123; scanf("%d%lld", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%lf", &amp;a[i]); double l=eps,r=1e12,mid; for(int i=1;i&lt;=200;i++) &#123; mid=(l+r)/2; if(judge(mid)) r=mid; else l=mid; &#125; int i; for(i=1,l=0;i&lt;=n;++i)l+=a[i]/(double)(cal(a[i]/r) + 1); printf("%lld", (LL)(l + 0.5)); return 0;&#125; 然而本题好像特别玄学，细节许多，很不容易过。。。 Problem 3211. -- 花神游历各国3211: 花神游历各国Time Limit: 5 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 4036&nbsp;&nbsp;Solved: 1476[Submit][Status][Discuss]Description InputOutput每次x=1时，每行一个整数，表示这次旅行的开心度 Sample Input 4 1 100 5 5 5 1 1 2 2 1 2 1 1 2 2 2 3 1 1 4 Sample Output 101 11 11 HINT 对于100%的数据， n ≤ 100000，m≤200000 ,data[i]非负且小于10^9 Tags: 数据结构 平摊分析 线段树 题目分析这种带特殊操作还搞不了几次就不能再搞或是时常搞不了的题目应该非常显然就是平摊分析线段树了吧。。。我们暴力进行操作，多维护一个最大值，递归进子区间且里面的最大值小于等于$1$的时候就不用再搞了，复杂度基本上就是$O(n\log (\log n) * \log n)$的吧。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 1000005#define LL long long intusing namespace std;int n, m;LL line[maxn];LL maxnum[maxn &lt;&lt; 1];LL sum[maxn &lt;&lt; 1];int qx, qy;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void init(int l, int r, int o)&#123; if (l == r)&#123; maxnum[o] = sum[o] = line[l]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void modify(int l, int r, int o)&#123; if (l == r)&#123; maxnum[o] = sum[o] = (LL) sqrt(maxnum[o]); return; &#125; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; //if (maxnum[o] == 1) return; //Error：明显就是往TLE写的节奏 if (maxnum[o] &lt;= 1) return; else &#123; int mid = ((r - l) &gt;&gt; 1) + l; modify(l, mid, o &lt;&lt; 1); modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o); return; &#125; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;LL get(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; LL ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int main()&#123; int x; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;line[i]); init(1, n, 1); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;qx, &amp;qy); if (x == 1) printf("%lld\n", get(1, n, 1)); else if (x == 2) modify(1, n, 1); &#125; return 0;&#125; 基本就是不要出现个上面代码里的那个SB错误，同时也别忘了开long long Problem 1856. -- [Scoi2010]字符串 1856: [Scoi2010]字符串 Time Limit: 5 Sec&nbsp;&nbsp;Memory Limit: 64 MBSubmit: 1792&nbsp;&nbsp;Solved: 1020[Submit][Status][Discuss]Descriptionlxhgww最近接到了一个生成字符串的任务，任务需要他把n个1和m个0组成字符串，但是任务还要求在组成的字符串中，在任意的前k个字符中，1的个数不能少于0的个数。现在lxhgww想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？ Input输入数据是一行，包括2个数字n和m Output输出数据是一行，包括1个数字，表示满足要求的字符串数目，这个数可能会很大，只需输出这个数除以20100403的余数 Sample Input 2 2 Sample Output 2 HINT 【数据范围】 对于30%的数据，保证1&lt;=m&lt;=n&lt;=1000 对于100%的数据，保证1&lt;=m&lt;=n&lt;=1000000 source Day2 Tags: 数学 组合数学 Catalan 数形结合思想 题目分析这道题并没有能够自己做出来。。。感觉还是很不爽的，说到底，问题还是在于我没有弄清问题的本质。。。当初刚学Catalan的时候，我看到一句 “可以证明通项a_n=C_{2n}^{n}-C_{2n}^{n-1}”， 就没有再去思考它。。。 好了回到本题，这样的题目不由得让我们回想起出栈入栈的问题，如果我们把$1$看做入栈，$0$看做出栈，那么所求的就是合法的栈操作序列方案数，而这个模型大家应该都很熟悉，这就是Catalan问题，本题不同的就在于出入栈次数不等，即最后栈中可能有剩余元素 然后我当时就不会了。。。 实际上，本题的证明思路和Catalan通项的其中一种证明方法十分相像，那就是数形结合法，我们考虑下面这个图： 这个图中的意思就是：每当有一个$1$，我们就向右上走一步，有一个$0$，我们就向右下走一步 我们可以发现，对于普通的Catalan问题，我们最后的终点就是$(2n, 0)$，而在这个问题中，我们则是走到$(n + m, n - m)$，那么我们下面就考虑如何通过这个方法求出答案 首先，我们知道从$(0, 0)$任意走到$(n + m, n - m)$的方案数为$C_{n + m}^{n}$，这个应该还是十分显然的，但是其中肯定有许多不合法情况，什么样的情况不合法呢？那就是走到$x$轴以下的方案，都是不合法的（只要越过一次就不合法） 所以，我们现在就要考虑如何求出不合法方案数。考虑对应法，即我们要把不合法情况与一些容易求出答案的方案对应在一起，下面就是脑洞时间：我们作直线$y = -1$，把起点设为$(0, -2)$，那么，不合法的方案数就是在满足上述条件下任意走的方案数，即$C_{n + m}^{n + 1}$，就相当于多了一个$1$而少了一个$0$ 这是为什么呢？我们可以考虑从$(0, 0)$出发的不合法方案，我们把这样的方案在最后一次越过$y = -1$之前的部分对称到下面去，后面的部分与对应后的方案重合（可以参考上面的图理解），这样，显然原来的不合法方案与新图的任意走的方案是一一对应的，问题就转化为了十分简单的形式，结论就得到了证明 那么本题就这样解决了，上面的结论退化一下，就是Catalan通项的数形结合证明法 代码12345678910111213141516171819202122232425262728#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 2000005#define M 20100403#define LL long long intusing namespace std;LL fac[maxn];LL ifac[maxn];LL inv[maxn];void init()&#123; fac[0] = 1; for (int i = 1; i &lt; maxn; i++) fac[i] = fac[i - 1] * i % M; inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (M - M / i * inv[M % i] % M) % M; ifac[0] = 1; for (int i = 1; i &lt; maxn; i++) ifac[i] = ifac[i - 1] * inv[i] % M;&#125;int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); init(); printf("%lld", fac[n + m] * ifac[n + 1] % M * ifac[m] % M * (n + 1 - m) % M); return 0;&#125; 注意不要把内存开炸。。。 Problem 3993. -- [SDOI2015]星际战争3993: [SDOI2015]星际战争Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSec&nbsp;&nbsp;Special JudgeSubmit: 1607&nbsp;&nbsp;Solved: 726[Submit][Status][Discuss]Description&nbsp;3333年，在银河系的某星球上，X军团和Y军团正在激烈地作战。在战斗的某一阶段，Y军团一共派遣了N个巨型机器人进攻X军团的阵地，其中第i个巨型机器人的装甲值为Ai。当一个巨型机器人的装甲值减少到0或者以下时，这个巨型机器人就被摧毁了。X军团有M个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人Bi的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y军团看到自己的巨型机器人被X军团一个一个消灭，他们急需下达更多的指令。为了这个目标，Y军团需要知道X军团最少需要用多长时间才能将Y军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。Input第一行，两个整数，N、M。 第二行，N个整数，A1、A2…AN。 第三行，M个整数，B1、B2…BM。 接下来的M行，每行N个整数，这些整数均为0或者1。这部分中的第i行的第j个整数为0表示第i个激光武器不可以攻击第j个巨型机器人，为1表示第i个激光武器可以攻击第j个巨型机器人。&lt;/div&gt;&lt;/div&gt;Output&nbsp;一行，一个实数，表示X军团要摧毁Y军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过10-3即视为正确。Sample Input 2 2 3 10 4 6 0 1 1 1Sample Output 1.300000HINT &nbsp;【样例说明1】 战斗开始后的前0.5秒，激光武器1攻击2号巨型机器人，激光武器2攻击1号巨型机器人。1号巨型机器人被完全摧毁，2号巨型机器人还剩余8的装甲值； 接下来的0.8秒，激光武器1、2同时攻击2号巨型机器人。2号巨型机器人被完全摧毁。 对于全部的数据，1&lt;=N, M&lt;=50，1&lt;=Ai&lt;=105，1&lt;=Bi&lt;=1000，输入数据保证X军团一定能摧毁Y军团的所有巨型机器人 source Round 1 感谢yts1999上传 Tags: 图论 网络流 二分答案 精度误差 题目分析对于这样的题目，我们从数据范围和题目形式上来看就知道应该是网络流（因为操作比较随意，状态表示很复杂），同时题目要求最小值，我们在建出网络流图以后就知道应该二分答案，然后判断机器人的边是否都被跑满，然后由此继续二分最后得到答案 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define maxn 105#define maxm 30005#define eps 1e-7#define INF 2000000005using namespace std;int n, m, s, t;struct edge&#123; int next, to; long double flow; edge(int next, int to, long double flow) : next(next), to(to), flow(flow)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, long double flow)&#123; e[++cnt] = edge(h[fr], to, flow); h[fr] = cnt; e[++cnt] = edge(h[to], fr, 0); h[to] = cnt;&#125;int d[maxn];bool BFS()&#123; queue&lt;int&gt; bfs; bfs.push(s); memset(d, 0, sizeof(d)); while (!bfs.empty())&#123; int op = bfs.front();bfs.pop(); for (int i = h[op]; i; i = e[i].next)&#123; if (e[i].flow &lt; eps) continue; int k = e[i].to; if (k == s || d[k]) continue; bfs.push(k); d[k] = d[op] + 1; &#125; &#125; if (!d[t]) return false; return true;&#125;long double DFS(int x, long double a)&#123; if (x == t) return a; long double rest = a; for (int i = h[x]; i; i = e[i].next)&#123; if (e[i].flow &lt; eps) continue; int op = e[i].to; if (d[op] != d[x] + 1) continue; long double k = DFS(op, min(e[i].flow, rest)); e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; if (rest &lt; eps) return a; &#125; return a - rest;&#125;void Dinic(long double&amp; maxflow)&#123; while(BFS()) maxflow += DFS(s, INF);&#125;int geo[maxn][maxn];long double a[maxn];long double b[maxn];long double sum = 0;void rebuild(long double x)&#123; cnt = 1; memset(h, 0, sizeof(h)); for (int i = 1; i &lt;= m; i++) Add_Edge(s, i, x * b[i]); for (int i = 1; i &lt;= n; i++) Add_Edge(i + m, t, a[i]); for (int i = 1; i &lt;= m; i++)&#123; for (int j = 1; j &lt;= n; j++)&#123; if (geo[i][j]) Add_Edge(i, j + m, INF); &#125; &#125;&#125;bool judge(long double x)&#123; rebuild(x); long double maxflow = 0; Dinic(maxflow); if (fabs(sum - maxflow) &lt; eps) return true; return false;&#125;long double work(long double l, long double r)&#123; if (r - l &lt; eps) return l; long double mid = (r + l) / 2.0; if (judge(mid)) return work(l, mid); else return work(mid, r);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; i++) scanf("%Lf", &amp;a[i]), sum += a[i]; for (int i = 1; i &lt;= m; i++) scanf("%Lf", &amp;b[i]); for (int i = 1; i &lt;= m; i++)&#123; for (int j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;geo[i][j]); &#125; &#125; printf("%Lf", work(0, INF) ); return 0;&#125; 注意本题的精度误差问题，所有的类型要用long double而不是double，同时也要注意二分时的判定方法，要使用fabs判断误差，不要直接减。。。 总结本期题型： 树上链状信息统计问题 批量LCA深度和问题 区间静态最小问题 多基数整除问题 树上链状信息维护问题 多版本信息维护问题 调整思想 平摊分析线段树 数形结合思想 网络流最大流模型]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总V]]></title>
    <url>%2F2017%2F09%2F07%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBV%2F</url>
    <content type="text"><![CDATA[引言How can I stay with you … forever ? … Problem 3400. -- [Usaco2009 Mar]Cow Frisbee Team 奶牛沙盘队3400: [Usaco2009 Mar]Cow Frisbee Team 奶牛沙盘队Time Limit: 3 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 290&nbsp;&nbsp;Solved: 195[Submit][Status][Discuss]Description&nbsp;&nbsp;&nbsp;&nbsp;农夫顿因开始玩飞盘之后，约翰也打算让奶牛们享受飞盘的乐趣．他要组建一只奶牛飞盘 队．他的N(1&le;N&le;2000)只奶牛，每只部有一个飞盘水准指数Ri(1&le;Ri&le;100000)．约翰要选出1只或多于1只奶牛来参加他的飞盘队．由于约翰的幸运数字是F(1&le;F&le;1000)，他希望所有奶牛的飞盘水准指数之和是幸运数字的倍数． &nbsp;&nbsp;&nbsp;&nbsp;帮约翰算算一共有多少种组队方式．Input&nbsp;&nbsp;&nbsp;&nbsp;第1行输入N和F，之后N行输入Ri．Output&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;组队方式数模10^8取余的结果．Sample Input 4 5 1 2 8 2Sample Output 3HINT &nbsp;&nbsp;&nbsp;&nbsp;组队方式有(2，3)，(3，4)，(1，2，4)共三种Source Silver Tags: 动态规划 数位DP 题目分析模数数位DP问题 记录两维：当前考虑的奶牛和当前的余数，直接转移即可 代码1234567891011121314151617181920212223242526272829#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 2005#define M 100000000using namespace std;int dp[maxn][maxn];bool vis[maxn][maxn];int ski[maxn];int n, f;int DP(int pos, int rest)&#123; if (pos == n) return (!rest) ? 1 : 0; if (vis[pos][rest]) return dp[pos][rest]; vis[pos][rest] = 1; int&amp; ans = dp[pos][rest]; return ans = (DP(pos + 1, (rest + ski[pos]) % f) + DP(pos + 1, rest)) % M;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;f); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;ski[i]), ski[i] %= f; int ans = 0; for (int i = 0; i &lt; n; i++)&#123; ans = (ans + DP(i + 1, ski[i])) % M; &#125; printf("%d", ans); return 0;&#125; Problem 4817. -- [Sdoi2017]树点涂色4817: [Sdoi2017]树点涂色Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 481&nbsp;&nbsp;Solved: 279[Submit][Status][Discuss]DescriptionBob有一棵n个点的有根树，其中1号点是根节点。Bob在每个点上涂了颜色，并且每个点上的颜色不同。定义一条路 径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。Bob可能会进行这几种操作： 1 x: 把点x到根节点的路径上所有的点染上一种没有用过的新颜色。 2 x y: 求x到y的路径的权值。 3 x y: 在以x为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。 Bob一共会进行m次操作 Input第一行两个数n,m。 接下来n-1行，每行两个数a,b，表示a与b之间有一条边。 接下来m行，表示操作，格式见题目描述 1&lt;=n,m&lt;=100000 Output每当出现2,3操作，输出一行。 如果是2操作，输出一个数表示路径的权值 如果是3操作，输出一个数表示权值的最大值 Sample Input 5 6 1 2 2 3 3 4 3 5 2 4 5 3 3 1 4 2 4 5 1 5 2 4 5Sample Output 3 4 2 2HINT Source 鸣谢infinityedge上传 Tags: 数据结构 LCT LCT思想 题目分析树上动态维护问题 本题是一个LCT类比的思路，就是用access操作类比题目中的染色操作，为什么这样类比呢？因为这样做，我们可以清楚地知道那些链是同色的，在改变颜色以及统计答案时都会比较方便，如果只是使用树链剖分，我们就不会知道一条链的哪些地方颜色发生了中断，就无法维护信息了 几乎是人生第一次正式的使用LCT，练习了一下，于是就发生了一个大错误，调了我一半夜，凌晨3点才调完。。。那就是每个splay的顶端并非链的顶端，我们要更新的话，要用链的顶端，这样就要在splay上一直向左跑才行。。。然而我很晚才发现这件事情。。。 直接扒自己的LOJ题解。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int cnt = 1, h[maxn];void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int fa[maxn];int son[maxn];int d[maxn];int si[maxn];int top[maxn];int dfs[maxn];int idfs[maxn];int t;void DFS1(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x]) continue; fa[op] = x; d[op] = d[x] + 1; DFS1(op); si[x] += si[op]; if (si[op] &gt; si[son[x]]) son[x] = op; &#125; si[x]++;&#125;void DFS2(int x, int tp)&#123; top[x] = tp; dfs[x] = ++t; idfs[t] = x; if (son[x]) DFS2(son[x], tp); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == son[x] || op == fa[x]) continue; DFS2(op, op); &#125;&#125; int maxnum[maxn &lt;&lt; 1];int add[maxn &lt;&lt; 1];int qx, qy, qd;void pushdown(int l, int r, int o)&#123; if (add[o] != 0 &amp;&amp; l != r)&#123; add[o &lt;&lt; 1] += add[o]; maxnum[o &lt;&lt; 1] += add[o]; add[o &lt;&lt; 1 | 1] += add[o]; maxnum[o &lt;&lt; 1 | 1] += add[o]; add[o] = 0; &#125;&#125;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]);&#125;void init(int l, int r, int o)&#123; if (l == r) &#123; maxnum[o] = d[idfs[l]] + 1; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; maxnum[o] += qd; add[o] += qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return maxnum[o]; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans = max(ans, get(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = max(ans, get(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;int f[maxn];int ch[maxn][2];void init()&#123; for (int i = 1; i &lt;= n; i++) f[i] = fa[i];&#125;bool is_root(int x)&#123; return (!f[x] || (ch[f[x]][0] != x &amp;&amp; ch[f[x]][1] != x));&#125;void rotate(int t)&#123; if(is_root(t))return; int k=f[t]; if(!is_root(k))&#123; ch[f[k]][ch[f[k]][0]==k?0:1]=t; &#125; int d=(ch[k][0]==t)?0:1; f[t]=f[k]; ch[k][d]=ch[t][d^1]; f[ch[k][d]]=k; ch[t][d^1]=k; f[k]=t;&#125;void splay(int t)&#123; while(!is_root(t))&#123; int fa=f[t]; if(!is_root(fa))&#123; int ffa=f[fa]; int f1=(ch[ffa][0]==fa)?0:1; int f2=(ch[fa][0]==t)?0:1; if(f1^f2) rotate(t); else rotate(fa); &#125; rotate(t); &#125;&#125;void access(int x)&#123; int tmp = 0; while (true)&#123; splay(x); if (ch[x][1])&#123; int _x = ch[x][1]; while (ch[_x][0])&#123; _x = ch[_x][0]; &#125; qx = dfs[_x], qy = dfs[_x] + si[_x] - 1, qd = 1; modify(1, n, 1); &#125; ch[x][1] = tmp; tmp = x; if (!f[x]) return; int _x = x; while (ch[_x][0])&#123; _x = ch[_x][0]; &#125; qx = dfs[_x], qy = dfs[_x] + si[_x] - 1, qd = -1; modify(1, n, 1); x = f[x]; &#125;&#125;void modify(int x)&#123; access(x);&#125;void query(int x, int y, int i)&#123; qx = qy = dfs[x]; int a = get(1, n, 1); qx = qy = dfs[y]; int b = get(1, n, 1); int f1 = top[x], f2 = top[y]; while (f1 != f2)&#123; if (d[f1] &gt; d[f2])&#123; x = fa[f1]; f1 = top[x]; &#125; else&#123; y = fa[f2]; f2 = top[y]; &#125; &#125; int lca = (d[x] &gt; d[y]) ? y : x; int c = fa[lca]; qx = qy = dfs[lca]; lca = get(1, n, 1); qx = qy = dfs[c]; if (c) c = get(1, n, 1); else c = 0; if (lca == c) printf("%d\n", a + b - (c &lt;&lt; 1) + 1); else printf("%d\n", a + b - (c &lt;&lt; 1) - 1);&#125;void query(int x)&#123; qx = dfs[x], qy = dfs[x] + si[x] - 1; printf("%d\n", get(1, n, 1));&#125;void init_all()&#123; DFS1(1); DFS2(1, 1); init(1, n, 1); init();&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int x, y, op; for (int i = 0; i &lt; n - 1; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; init_all(); for (int i = 0; i &lt; m; i++)&#123; scanf("%d", &amp;op); if (op == 1)&#123; scanf("%d", &amp;x); modify(x); &#125; else if (op == 2)&#123; scanf("%d%d", &amp;x, &amp;y); query(x, y, i); &#125; else if (op == 3)&#123; scanf("%d", &amp;x); query(x); &#125; &#125; return 0;&#125; Problem 3732. -- Network3732: NetworkTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 1900&nbsp;&nbsp;Solved: 909[Submit][Status][Discuss]Description给你N个点的无向图 (1 &lt;= N &lt;= 15,000)，记为：1&hellip;N。 图中有M条边 (1 &lt;= M &lt;= 30,000) ，第j条边的长度为： d_j ( 1 &lt; = d_j &lt; = 1,000,000,000). 现在有 K个询问 (1 &lt; = K &lt; = 20,000)。 每个询问的格式是：A B，表示询问从A点走到B点的所有路径中，最长的边最小值是多少？&lt;/div&gt;Input第一行： N, M, K。 第2..M+1行: 三个正整数：X, Y, and D (1 &lt;= X &lt;=N; 1 &lt;= Y &lt;= N). 表示X与Y之间有一条长度为D的边。 第M+2..M+K+1行: 每行两个整数A B,表示询问从A点走到B点的所有路径中，最长的边最小值是多少？Output&nbsp;对每个询问，输出最长的边最小值是多少。Sample Input 6 6 8 1 2 5 2 3 4 3 4 3 1 4 8 2 5 7 4 6 2 1 2 1 3 1 4 2 3 2 4 5 1 6 2 6 1Sample Output 5 5 5 4 4 7 4 5HINT 1 &lt;= N &lt;= 15,000 1 &lt;= M &lt;= 30,000 1 &lt;= d_j &lt;= 1,000,000,000 1 &lt;= K &lt;= 15,000 Source Tags: 图论 瓶颈路 最小生成树 LCA 题目分析图上两点瓶颈路问题 我们先求一发最小生成树，然后直接在树上进行倍增LCA，本题即可解决 为什么这样是对的呢？我们可以思考Kruskal的思想，从最小的边逐个加入，那么一定满足瓶颈路这个要求 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005#define INF 2000000005using namespace std;int n, m, k;struct edge&#123; int x, y, len; edge(int x, int y, int len) : x(x), y(y), len(len)&#123;&#125; edge()&#123;&#125; bool operator &lt; (const edge b) const&#123; return len &lt; b.len; &#125;&#125;e[maxn &lt;&lt; 1];int cnt = 0;void Add_Edge(int x, int y, int len)&#123; e[++cnt] = edge(x, y, len);&#125;struct edge2&#123; int next, to, len; edge2(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge2()&#123;&#125;&#125;e2[maxn &lt;&lt; 1];int cnt2 = 1, h[maxn];void Add_Edge2(int x, int y, int len)&#123; e2[++cnt2] = edge2(h[x], y, len); h[x] = cnt2; e2[++cnt2] = edge2(h[y], x, len); h[y] = cnt2;&#125;int ufs[maxn];int find_root(int x)&#123; return ufs[x] = (ufs[x] == x) ? x : find_root(ufs[x]);&#125;int d[maxn];int fa[maxn][30];int val[maxn][30];void DFS(int x)&#123; for (int i = 1; i &lt; 30; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1]; for (int i = 1; i &lt; 30; i++) val[x][i] = max(val[x][i - 1], val[fa[x][i - 1]][i - 1]); for (int i = h[x]; i; i = e2[i].next)&#123; int op = e2[i].to; if (op == fa[x][0]) continue; fa[op][0] = x; d[op] = d[x] + 1; val[op][0] = e2[i].len; DFS(op); &#125;&#125;void init()&#123; val[1][0] = 0; fa[1][0] = 1; DFS(1);&#125;int query(int x, int y)&#123; if (x == y) return 0; if (d[x] &lt; d[y]) swap(x, y); int k = d[x] - d[y]; int now = 0; int ans = -INF; while (k)&#123; if (k &amp; 1) ans = max(ans, val[x][now]), x = fa[x][now]; now++; k &gt;&gt;= 1; &#125; if (x == y) return ans; while(1)&#123; int now = 0; while (fa[x][now] != fa[y][now]) now++; if (now == 0) return ans = max(ans, max(val[x][0], val[y][0])); now--; ans = max(ans, max(val[x][now], val[y][now])); x = fa[x][now]; y = fa[y][now]; &#125;&#125;void work()&#123; for (int i = 1; i &lt;= n; i++) ufs[i] = i; sort(e + 1, e + 1 + cnt); int ct = 0; for (int i = 1; i &lt;= m; i++)&#123; if (ct == n - 1) break; edge op = e[i]; int x = find_root(op.x); int y = find_root(op.y); if (x == y) continue; ufs[x] = y; ct++; Add_Edge2(op.x, op.y, op.len); &#125; int x, y; init(); for (int i = 1; i &lt;= k; i++)&#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", query(x, y)); &#125;&#125;int main()&#123; int x, y, len; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;len); Add_Edge(x, y, len); &#125; work(); return 0;&#125; Problem 3702. -- 二叉树3702: 二叉树Time Limit: 15 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 561&nbsp;&nbsp;Solved: 251[Submit][Status][Discuss]Description现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有n个叶子节点，满足这些权值为1..n的一个排列)。可以任意交换每个非叶子节点的左右孩子。 要求进行一系列交换，使得最终所有叶子节点的权值按照中序遍历写出来，逆序对个数最少。 Input第一行n 下面每行，一个数x 如果x==0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息， 如果x!=0，表示这个节点是叶子节点，权值为x。 Output一行，最少逆序对个数。 Sample Input 3 0 0 3 1 2 Sample Output 1HINT 对于100%的数据：2&lt;=n&lt;=200000。Source Tags: 数据结构 线段树 线段树合并 题目分析线段树合并问题 我们很容易发现，逆序对最少，我们只需要对两侧分别调整，而合并的时候看看两个整体哪个放前面会使逆序对最少即可， 这就是一种整体局部无关性的思想 那么，我们只需要使用线段树合并，即可容易地做到这一点 代码第一次写线段树合并。。。好激动(≧▽≦)/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long int#define maxn 1000005using namespace std;int n;int ch[maxn][2];int cnt = 1;struct node&#123; node *l, *r; int val; node(int val) : val(val)&#123;&#125; node()&#123;&#125;&#125;;node* save[maxn];void merge(node*&amp; x, node* y)&#123; if (y == NULL) return; if (x != NULL) x -&gt; val += y -&gt; val; else &#123; x = y; return; &#125; merge(x -&gt; l, y -&gt; l); merge(x -&gt; r, y -&gt; r);&#125;void insert(int l, int r, int x, node*&amp; ans, int v)&#123; if (ans == NULL) ans = new node(v); else ans -&gt; val += v; if (l == r) return; int mid = ((r - l) &gt;&gt; 1) + l; if (x &lt;= mid) insert(l, mid, x, ans -&gt; l, v); else insert(mid + 1, r, x, ans -&gt; r, v);&#125;LL find_rank(int l, int r, int x, node* now)&#123; if (now == NULL) return 0; int mid = ((r - l) &gt;&gt; 1) + l; if (x &lt;= mid) return find_rank(l, mid, x, now -&gt; l); else return ((now -&gt; l == NULL) ? 0 : now -&gt; l -&gt; val) + find_rank(mid + 1, r, x, now -&gt; r);&#125;void build(int o)&#123; int x; scanf("%d", &amp;x); if (x == 0)&#123; ch[o][0] = ++cnt; build(cnt); ch[o][1] = ++cnt; build(cnt); &#125; else insert(1, n, x, save[o], 1);&#125;void get_sum(int l, int r, node* x, node* y, LL&amp; sum)&#123; if (l == r)&#123; sum += find_rank(1, n, l, x); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (y -&gt; l != NULL) get_sum(l, mid, x, y -&gt; l, sum); if (y -&gt; r != NULL) get_sum(mid + 1, r, x, y -&gt; r, sum);&#125;void insert_all(int l, int r, node*&amp; x, node* y)&#123; if (l == r)&#123; insert(1, n, l, x, y -&gt; val); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (y -&gt; l != NULL) insert_all(l, mid, x, y -&gt; l); if (y -&gt; r != NULL) insert_all(mid + 1, r, x, y -&gt; r);&#125;LL ans = 0;void work(int o)&#123; int l = ch[o][0], r = ch[o][1]; if (l)&#123; work(l); work(r); LL sl = save[l] -&gt; val, sr = save[r] -&gt; val; LL sum = 0; if (sl &lt; sr) get_sum(1, n, save[r], save[l], sum); else get_sum(1, n, save[l], save[r], sum); ans += min(sum, sl * sr - sum); if (sl &lt; sr)&#123; merge(save[r], save[l]); save[o] = save[r]; &#125; else&#123; merge(save[l], save[r]); save[o] = save[l]; &#125; &#125;&#125;int main()&#123; scanf("%d", &amp;n); build(1); work(1); printf("%lld", ans); return 0;&#125; Problem 3669. -- [Noi2014]魔法森林3669: [Noi2014]魔法森林Time Limit: 30 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 2909&nbsp;&nbsp;Solved: 1822[Submit][Status][Discuss]Description为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个N节点M条边的无向图，节点标号为1..N，边标号为1..M。初始时小E同学在号节点1，隐士则住在号节点N。小E需要通过这一片魔法森林，才能够拜访到隐士。 魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。 只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边Ei包含两个权值Ai与Bi。若身上携带的A型守护精灵个数不少于Ai，且B型守护精灵个数不少于Bi，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。 由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。 &lt;/div&gt;Input第1行包含两个整数N,M，表示无向图共有N个节点，M条边。 接下来M行，第行包含4个正整数Xi,Yi,Ai,Bi，描述第i条无向边。其中Xi与Yi为该边两个端点的标号，Ai与Bi的含义如题所述。 注意数据中可能包含重边与自环。 Output输出一行一个整数：如果小E可以成功拜访到隐士，输出小E最少需要携带的守护精灵的总个数；如果无论如何小E都无法拜访到隐士，输出&ldquo;-1&rdquo;（不含引号）。 &lt;/div&gt;Sample Input 【输入样例1】 4 5 1 2 19 1 2 3 8 12 2 4 12 15 1 3 17 8 3 4 1 17 【输入样例2】 3 1 1 2 1 1 Sample Output 【输出样例1】 32 【样例说明1】 如果小E走路径1→2→4，需要携带19+15=34个守护精灵； 如果小E走路径1→3→4，需要携带17+17=34个守护精灵； 如果小E走路径1→2→3→4，需要携带19+17=36个守护精灵； 如果小E走路径1→3→2→4，需要携带17+15=32个守护精灵。 综上所述，小E最少需要携带32个守护精灵。 【输出样例2】 -1 【样例说明2】 小E无法从1号节点到达3号节点，故输出-1。 HINT 2&lt;=n&lt;=50,000 0&lt;=m&lt;=100,000 1&lt;=ai ,bi&lt;=50,000 Source Tags: 图论 二维属性 瓶颈路 动点SPFA LCT 题目分析动点SPFA/二维瓶颈路问题 正解显然是LCT，然而还有另一种方法，就是动点SPFA，把边按其中一维排序后逐个加入，然后只对当前存在的边跑SPFA，这样就过了。。。 代码注意动点SPFA的写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define maxn 1000005#define INF 2000000005using namespace std;int n, m;int f[maxn];struct edge&#123; int x, y, a, b; edge(int x, int y, int a, int b) : x(x), y(y), a(a), b(b)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];vector&lt;int&gt; save[maxn];bool cmp(edge a, edge b)&#123; return a.a &lt; b.a;&#125;queue&lt;int&gt; spfa;int now;int ans = INF;bool in[maxn];bool have[maxn];void SPFA()&#123; while (!spfa.empty())&#123; int op = spfa.front();spfa.pop(); for (int i = 0; i &lt; save[op].size(); i++)&#123;int t = save[op][i];if (!have[t]) continue;int k = (e[t].x == op) ? e[t].y : e[t].x;if (e[t].a &gt; now) continue;if (f[k] &gt; max(f[op], e[t].b))&#123; f[k] = max(f[op], e[t].b); if (!in[k])&#123; spfa.push(k); in[k] = 1; &#125; if (k == n) ans = min(ans, now + f[k]);&#125; &#125; in[op] = 0; &#125;&#125;void work()&#123; for (int i = 0; i &lt; m; i++)&#123; edge op = e[i]; have[i] = 1; int a = op.x, b = op.y; if (a == b) continue; spfa.push(b);spfa.push(a); now = op.a; SPFA(); &#125; printf("%d", ans);&#125;bool vis[maxn];bool judge()&#123; queue&lt;int&gt; bfs; bfs.push(1); vis[1] = 1; while (!bfs.empty())&#123; int op = bfs.front(); bfs.pop(); for (int i = 0; i &lt; save[op].size(); i++)&#123; int k = save[op][i];int t = (e[k].x == op) ? e[k].y : e[k].x;if (vis[t]) continue;vis[t] = 1;bfs.push(t); &#125; &#125; if (!vis[n]) return false; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) f[i] = INF; f[1] = 0; int x, y, z, w; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;z, &amp;w); e[i] = edge(x, y, z, w); &#125; sort(e, e + m, cmp); for (int i = 0; i &lt; m; i++)&#123; save[e[i].x].push_back(i); save[e[i].y].push_back(i); &#125; if (!judge())&#123; printf("-1"); return 0; &#125; work(); return 0;&#125; Problem 3629. -- [JLOI2014]聪明的燕姿3629: [JLOI2014]聪明的燕姿Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 1562&nbsp;&nbsp;Solved: 580[Submit][Status][Discuss]Description阴天傍晚车窗外 未来有一个人在等待 向左向右向前看 爱要拐几个弯才来 我遇见谁会有怎样的对白 我等的人他在多远的未来 我听见风来自地铁和人海 我排着队拿着爱的号码牌 城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于S。 所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。Input输入包含k组数据（k&lt;=100）对于每组数据，输入包含一个号码牌SOutput对于每组数据，输出有两行，第一行包含一个整数m，表示有m个等的人，第二行包含相应的m个数，表示所有等的人的号码牌。注意：你输出的号码牌必须按照升序排列。Sample Input 42Sample Output 3 20 26 41HINT 对于100%的数据，有S&lt;=2*10*9 Source Tags: 数学 质因子分析 DFS 题目分析质因子分析DFS问题省选题真是谁都能黑啊。。。世道好轮回，省选绕过谁 本题即是传说中的对于质因子进行DFS暴力搜索的题目，然而我太弱，WA了无数次。。。 主要就是注意如何剪枝以及避免错误吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define maxn 100005#define INF 2000000005#define pb push_back#define LL long long intusing namespace std;int p[maxn][32];int save[maxn][32];int si[maxn];int cnt;bool vis[maxn];void init()&#123; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++][1] = i; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j][1] &gt;= maxn) break; vis[i * p[j][1]] = 1; if (i % p[j][1] == 0) break; &#125; &#125; for (int i = 0; i &lt; cnt; i++)&#123; save[i][0] = p[i][0] = 1; save[i][1] = p[i][1]; for (int j = 2; j &lt; 32; j++)&#123; if ((LL)p[i][j - 1] * save[i][1] &gt;= INF) &#123; si[i] = j; break; &#125; save[i][j] = p[i][j] = p[i][j - 1] * save[i][1]; &#125; for (int j = 1; j &lt; si[i]; j++)&#123; if ((LL)p[i][j - 1] + p[i][j] &gt;= INF)&#123; si[i] = j; break; &#125; p[i][j] += p[i][j - 1]; &#125; &#125;&#125;bool judge(int x)&#123; int con = (int) sqrt(x); for (int i = 0; i &lt; cnt; i++)&#123; if (save[i][1] &gt; con) return true; if (x % save[i][1] == 0) return false; &#125; return true;&#125;vector&lt;int&gt; ans;void DFS(int pos, int rest, int now)&#123; if (rest &lt; p[pos][1])&#123; if (rest == 1) ans.pb(now); return; &#125; if ((LL)rest &lt; (LL)p[pos][1] * p[pos][1] &amp;&amp; rest &lt; ((p[pos][2] &gt; 0) ? p[pos][2] : INF))&#123; if (judge(rest - 1)) ans.pb(now * (rest - 1)); return; &#125; /*if (pos == cnt &amp;&amp; rest - 1 &gt;= maxn)&#123; if (judge(rest - 1)) ans.pb(now * (rest - 1)); return; &#125;*/ for (int i = 0; i &lt; si[pos]; i++)&#123; if (p[pos][i] &gt; rest) return; if (rest % p[pos][i] == 0) DFS(pos + 1, rest / p[pos][i], now * save[pos][i]); &#125;&#125;bool f = 0;void work(int x)&#123; if (!f)&#123; DFS(0, x, 1); sort(ans.begin(), ans.end()); if (ans.size() == 0)&#123; printf("0"); &#125; else&#123; printf("%d\n", ans.size()); printf("%d", ans[0]); for (int i = 1; i &lt; ans.size(); i++) printf(" %d", ans[i]); ans.clear(); &#125; f = 1; return; &#125; DFS(0, x, 1); sort(ans.begin(), ans.end()); if (ans.size() == 0)&#123; printf("\n0"); &#125; else&#123; printf("\n%d\n", ans.size()); printf("%d", ans[0]); for (int i = 1; i &lt; ans.size(); i++) printf(" %d", ans[i]); ans.clear(); &#125;&#125;int main()&#123; init(); int n; while (scanf("%d", &amp;n) == 1) work(n); return 0;&#125; Problem 4552. -- [Tjoi2016&Heoi2016]排序4552: [Tjoi2016&Heoi2016]排序Time Limit: 60 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 1187&nbsp;&nbsp;Solved: 622[Submit][Status][Discuss]Description在2016年，佳媛姐姐喜欢上了数字序列。因而他经常研究关于序列的一些奇奇怪怪的问题，现在他在研究一个难题 ，需要你来帮助他。这个难题是这样子的：给出一个1到n的全排列，现在对这个全排列序列进行m次局部排序，排 序分为两种：1:(0,l,r)表示将区间[l,r]的数字升序排序2:(1,l,r)表示将区间[l,r]的数字降序排序最后询问第q 位置上的数字。Input输入数据的第一行为两个整数n和m。n表示序列的长度，m表示局部排序的次数。1 &lt;= n, m &lt;= 10^5第二行为n个整 数，表示1到n的一个全排列。接下来输入m行，每一行有三个整数op, l, r, op为0代表升序排序，op为1代表降序 排序, l, r 表示排序的区间。最后输入一个整数q，q表示排序完之后询问的位置, 1 &lt;= q &lt;= n。1 &lt;= n &lt;= 10^5 ，1 &lt;= m &lt;= 10^5 Output&nbsp;输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第q位置上的数字。Sample Input 6 3 1 6 2 5 3 4 0 1 4 1 3 6 0 2 4 3Sample Output 5HINT Source Tags: 二分答案 线段树 线段树特殊操作 题目分析线段树特殊操作问题这题谁能想到是二分答案。。。虽然想到后好像挺合理的样子。。。 我们二分答案，然后即可把所有比它大的数看做1，其余的数看做0，然后升降序排序就变成了区间修改问题，最后根据所求位置上的数是0还是1判断左右二分 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;struct mod&#123; int op, l, r; mod(int op, int l, int r) : op(op), l(l), r(r)&#123;&#125; mod()&#123;&#125;&#125;save[maxn];int n, m, q;int line[maxn];int sum[maxn &lt;&lt; 1];int set[maxn &lt;&lt; 1];int qx, qy, qd;void pushdown(int l, int r, int o)&#123; if (set[o] != -1 &amp;&amp; l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; set[o &lt;&lt; 1] = set[o]; sum[o &lt;&lt; 1] = set[o] * (mid + 1 - l); set[o &lt;&lt; 1 | 1] = set[o]; sum[o &lt;&lt; 1 | 1] = set[o] * (r - mid); set[o] = -1; &#125;&#125;void pushup(int l, int r, int o)&#123; if (l == r) return; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void init(int l, int r, int o)&#123; set[o] = -1; if (l == r)&#123; if (qd &lt; line[l]) sum[o] = 1; else sum[o] = 0; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; set[o] = qd; sum[o] = (r - l + 1) * set[o]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;bool judge(int x)&#123; qd = x; init(1, n, 1); for (int i = 1; i &lt;= m; i++)&#123; if (save[i].op)&#123; qx = save[i].l, qy = save[i].r; int num = get(1, n, 1); qx = save[i].l, qy = qx + num - 1, qd = 1; if (qx &lt;= qy) modify(1, n, 1); qx = qy + 1, qy = save[i].r, qd = 0; if (qx &lt;= qy) modify(1, n, 1); &#125; else&#123; qx = save[i].l, qy = save[i].r; int num = get(1, n, 1); qx = qy - num + 1, qy = save[i].r, qd = 1; if (qx &lt;= qy) modify(1, n, 1); qx = save[i].l, qy = qy - num, qd = 0; if (qx &lt;= qy) modify(1, n, 1); &#125; &#125; qx = qy = q; int judgement = get(1, n, 1); if (judgement == 1) return false; else return true;&#125;int work(int l, int r)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (judge(mid)) return work(l, mid); else return work(mid + 1, r);&#125;int main()&#123; int op, l, r; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); for (int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;op, &amp;l, &amp;r), save[i] = mod(op, l, r); scanf("%d", &amp;q); printf("%d", work(1, n)); return 0;&#125; Problem 4281. -- [ONTAK2015]Związek Harcerstwa Bajtockiego4281: [ONTAK2015]Związek Harcerstwa BajtockiegoTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 256 MBSubmit: 207&nbsp;&nbsp;Solved: 87[Submit][Status][Discuss]Description给定一棵有n个点的无根树，相邻的点之间的距离为1，一开始你位于m点。之后你将依次收到k个指令，每个指令包含两个整数d和t，你需要沿着最短路在t步之内（包含t步）走到d点，如果不能走到，则停在最后到达的那个点。请在每个指令之后输出你所在的位置。 Input第一行包含三个正整数n,m,k(1&lt;=m&lt;=n&lt;=1000000,1&lt;=k&lt;=1000000)。 接下来n-1行，每行包含两个正整数x,y(1&lt;=x,y&lt;=n)，描述一条树边。 接下来k行，每行两个整数d,t(1&lt;=d&lt;=n,0&lt;=t&lt;=10^9)，描述一条指令。 Output输出一行，包含k个正整数，即执行每条指令后你所在的位置。 Sample Input 3 1 2 1 2 2 3 3 4 1 1Sample Output 3 2HINT Source By Claris Tags: 树 LCA问题 模拟 题目分析模拟操作问题我们只需要倍增预处理祖先然后直接模拟跑LCA即可。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;int n, m, k;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int fa[maxn][25];int d[maxn];void DFS(int x)&#123; for (int i = 1; i &lt; 25; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1]; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x][0]) continue; fa[op][0] = x; d[op] = d[x] + 1; DFS(op); &#125;&#125;int find_lca(int x, int y)&#123; int lca; if (d[x] &lt; d[y]) swap(x, y); int k = d[x] - d[y]; int now = 0; while (k)&#123; if (k &amp; 1) x = fa[x][now]; now++; k &gt;&gt;= 1; &#125; if (x == y) return x; while (1)&#123; now = 0; while (fa[x][now] != fa[y][now]) now++; if (now == 0) return fa[x][0]; now--; x = fa[x][now]; y = fa[y][now]; &#125;&#125;int move(int x, int y, int v)&#123; int lca = find_lca(x, y); int all = d[x] + d[y] - 2 * d[lca]; if (v &gt;= all) return y; if (v &lt;= d[x] - d[lca])&#123; int now = 0; while (v)&#123; if (v &amp; 1) x = fa[x][now]; now++; v &gt;&gt;= 1; &#125; return x; &#125; int now = 0; v = all - v; while (v)&#123; if (v &amp; 1) y = fa[y][now]; now++; v &gt;&gt;= 1; &#125; return y;&#125;int ans;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); int x, y; for (int i = 1; i &lt;= n - 1; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; d[1] = 1; fa[1][0] = 1; DFS(1); ans = m; for (int i = 1; i &lt;= k; i++)&#123; scanf("%d%d", &amp;x, &amp;y); ans = move(ans, x, y); printf("%d ", ans); &#125; return 0;&#125; Problem 3670. -- [Noi2014]动物园3670: [Noi2014]动物园Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 2935&nbsp;&nbsp;Solved: 1587[Submit][Status][Discuss]Description近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。 某天，园长给动物们讲解KMP算法。 园长：&ldquo;对于一个字符串S，它的长度为L。我们可以在O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？&rdquo; 熊猫：&ldquo;对于字符串S的前i个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]。&rdquo; 园长：&ldquo;非常好！那你能举个例子吗？&rdquo; 熊猫：&ldquo;例S为abcababc，则next[5]=2。因为S的前5个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0，next[4] = next[6] = 1，next[7] = 2，next[8] = 3。&rdquo; 园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)的时间内求出next数组。 下课前，园长提出了一个问题：&ldquo;KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。例如S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质&lsquo;既是后缀又是前缀&rsquo;，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质&lsquo;既是后缀又是前缀&rsquo;，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2。&rdquo; 最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出num数组呢？ 特别地，为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出对1,000,000,007取模的结果即可。 &lt;/div&gt;Input第1行仅包含一个正整数n ，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。数据保证S 中仅含小写字母。输入文件中不会包含多余的空行，行末不会存在多余的空格。Output包含 n 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,007 取模的结果。输出文件中不应包含多余的空行。 Sample Input 3 aaaaa ab abcababcSample Output 36 1 32 HINT n&le;5,L&le;1,000,000Source Tags: 字符串 KMP变式 题目分析KMP变式问题 这道题其实是一道很好的题目，能加强对KMP的理解 其实fail函数有两种实现，一种是代表包含自己前一个位置但不含自己的最长border长度，另一种是自己也算在内的最长border长度 这两者的处理方式并不相同，所以一定要想清楚KMP的原理 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define M 1000000007#define maxn 1000005#define LL long long intusing namespace std;char t[maxn];int lent;int f[maxn];int f1[maxn];int num[maxn];int f2[maxn];void init()&#123; f[0] = -1; f1[0] = -1; num[0] = 0; for (int i = 1; i &lt; lent; i++)&#123; int k = f[i - 1]; while (k &gt; -1 &amp;&amp; t[k + 1] != t[i]) k = f[k]; f[i] = ((t[k + 1] == t[i]) ? k + 1 : -1); num[i] = ((t[k + 1] == t[i]) ? num[k + 1] + 1 : 0); k = f1[i - 1]; while (k &gt; -1 &amp;&amp; t[k + 1] != t[i]) k = f[k]; f1[i] = ((t[k + 1] == t[i]) ? k + 1 : -1); while (f1[i] &gt; -1 &amp;&amp; ((f1[i] + 1) &lt;&lt; 1) &gt; i + 1) f1[i] = f[f1[i]]; f2[i] = (f1[i] == -1) ? 0 : (num[f1[i]] + 1); &#125;&#125;void work()&#123; LL ans = 1; for (int i = 0; i &lt; lent; i++) ans = ans * (f2[i] + 1) % M; printf("%lld\n", ans);&#125;int main()&#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%s", t); lent = strlen(t); init(); work(); &#125; return 0;&#125; Problem 3530. -- [Sdoi2014]数数3530: [Sdoi2014]数数Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 1082&nbsp;&nbsp;Solved: 555[Submit][Status][Discuss]Description我们称一个正整数N是幸运数，当且仅当它的十进制表示中不包含数字串集合S中任意一个元素作为其子串。例如当S=(22，333，0233)时，233是幸运数，2333、20233、3223不是幸运数。 &nbsp;&nbsp;&nbsp; 给定N和S，计算不大于N的幸运数个数。 Input &nbsp;&nbsp;&nbsp; 输入的第一行包含整数N。&nbsp;&nbsp;&nbsp; 接下来一行一个整数M，表示S中元素的数量。&nbsp;&nbsp;&nbsp; 接下来M行，每行一个数字串，表示S中的一个元素。 &lt;/p&gt;&lt;/div&gt;Output&nbsp;&nbsp;&nbsp; 输出一行一个整数，表示答案模109+7的值。 Sample Input 20 3 2 3 14 Sample Output 14HINT &nbsp;下表中l表示N的长度，L表示S中所有串长度之和。 1 &lt; =l &lt; =1200&nbsp;, 1 &lt; =M &lt; =100&nbsp;,1 &lt; =L &lt; =1500Source Round 1 day 1 Tags: 动态规划 数位DP AC自动机 题目分析多串匹配型数位DP问题 本题首先显然是AC自动机，然而情况多，真的很难一遍写对。。。 大概的坑有如下： 集合中的数字开头可以为0 AC自动机中可能包含其他串的结点也不能走到 要注意开始标记的作用，为了避免，要循环累计答案 另外本题LOJ数据弱，第二点没处理也能过，然而BZOJ上就过不了。。。 好了不说了。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 4005#define M 1000000007using namespace std;bool val[maxn];int ch[maxn][12];int cnt = 0;int f[maxn];char s[maxn];int m;char num[maxn];int ct = 0;int len;void insert()&#123; int now = 0; for (int i = 0; i &lt; len; i++)&#123; if (!ch[now][s[i] - '0']) ch[now][s[i] - '0'] = ++cnt; now = ch[now][s[i] - '0']; &#125; val[now] = 1;&#125;void init()&#123; f[0] = 0; queue&lt;int&gt; bfs; for (int i = 0; i &lt; 10; i++)&#123; if (ch[0][i]) f[ch[0][i]] = 0, bfs.push(ch[0][i]); &#125; while (!bfs.empty())&#123; int op = bfs.front(); bfs.pop(); for (int i = 0; i &lt; 10; i++)&#123; if (!ch[op][i]) ch[op][i] = ch[f[op]][i]; else &#123; int k = f[op]; while (k &amp;&amp; !ch[k][i]) k = f[k]; f[ch[op][i]] = (!ch[k][i]) ? 0 : ch[k][i]; if (val[f[ch[op][i]]]) val[ch[op][i]] = 1; bfs.push(ch[op][i]); &#125; &#125; &#125; ct = strlen(num); for (int i = 0; i &lt; ct; i++) num[i] -= '0';&#125;int dp[maxn][maxn][2];bool vis[maxn][maxn][2];int DP(int pos, int loc, int op)&#123; if (val[loc]) return 0; if (pos == ct) return 1; if (vis[pos][loc][op]) return dp[pos][loc][op]; vis[pos][loc][op] = 1; int&amp; ans = dp[pos][loc][op]; if (op)&#123; for (int i = 0; i &lt; num[pos]; i++)&#123; ans = (ans + DP(pos + 1, ch[loc][i], 0)) % M; &#125; ans = (ans + DP(pos + 1, ch[loc][num[pos]], 1)) % M; return ans; &#125; for (int i = 0; i &lt; 10; i++)&#123; ans = (ans + DP(pos + 1, ch[loc][i], 0)) % M; &#125; return ans;&#125;int main()&#123; scanf("%s%d", num, &amp;m); for (int i = 1; i &lt;= m; i++)&#123; scanf("%s", s); len = strlen(s); insert(); &#125; init(); int ans = 0; for (int i = 1; i &lt; ct; i++)&#123; for (int j = 1; j &lt; 10; j++)&#123; ans = (ans + DP(i + 1, ch[0][j], 0)) % M; &#125; &#125; for (int i = 1; i &lt; num[0]; i++) ans = (ans + DP(1, ch[0][i], 0)) % M; ans = (ans + DP(1, ch[0][num[0]], 1)) % M; printf("%d", ans); return 0;&#125; 总结本期的题型有： 模数数位DP问题 树上动态维护问题 图上两点瓶颈路问题 线段树合并问题 动点SPFA/二维瓶颈路问题 质因子分析DFS问题 线段树特殊操作问题 模拟操作问题 KMP变式问题 多串匹配型数位DP问题]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总IV]]></title>
    <url>%2F2017%2F09%2F07%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBIV%2F</url>
    <content type="text"><![CDATA[引言I’m alone still… Problem 1339. -- [Baltic2008]Mafia1339: [Baltic2008]MafiaTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 419&nbsp;&nbsp;Solved: 263[Submit][Status][Discuss]Description匪徒准备从一个车站转移毒品到另一个车站,警方准备进行布控. 对于每个车站进行布控都需要一定的代价,现在警方希望使用最小的代价控制一些车站,使得去掉这些车站后，匪徒无法从原定的初始点到达目标点Input第一行输入N,M代表车站的总个数,及有多少条双向边连接它们. 2]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总III]]></title>
    <url>%2F2017%2F09%2F07%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBIII%2F</url>
    <content type="text"><![CDATA[引言Time passes so fast, but… 题解Problem 4726. -- [POI2017]Sabota?4726: [POI2017]Sabota?Time Limit: 20 Sec&nbsp;&nbsp;Memory Limit: 128 MBSec&nbsp;&nbsp;Special JudgeSubmit: 576&nbsp;&nbsp;Solved: 241[Submit][Status][Discuss]Description某个公司有n个人, 上下级关系构成了一个有根树。其中有个人是叛徒(这个人不知道是谁)。对于一个人, 如果他 下属(直接或者间接, 不包括他自己)中叛徒占的比例超过x，那么这个人也会变成叛徒，并且他的所有下属都会变 成叛徒。你要求出一个最小的x，使得最坏情况下，叛徒的个数不会超过k。 Input第一行包含两个正整数n,k(1&lt;=k&lt;=n&lt;=500000)。 接下来n-1行，第i行包含一个正整数p[i+1]，表示i+1的父亲是p[i+1](1&lt;=p[i+1]&lt;=i)。 Output输出一行一个实数x，误差在10^-6以内都被认为是正确的。 Sample Input 9 3 1 1 2 2 2 3 7 3Sample Output 0.6666666667HINT 答案中的x实际上是一个无限趋近于2/3但是小于2/3的数 因为当x取2/3时，最坏情况下3，7，8，9都是叛徒，超过了k=3。 Source 鸣谢Claris上传 Tags: 树型DP 限制性问题 题目分析树型DP问题 比较经典的树型DP，一种比较容易想到的方法就是使用二分法，但是这种方法比较卡常，因为正解不是这个。。。 正解就是直接DP一次，求出当前结点在刚好被占领（即自己成为叛徒）的前提下，它的比例最大是多少，因为我们要考虑最坏情况，然后对所有绝对不能被占领（即子树大小大于k）的结点取一个DP值的MAX即为答案 代码正解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500050; struct edge&#123; int to,nxt; &#125;e[maxn&lt;&lt;1]; int head[maxn],cnt,n,K,size[maxn]; double dp[maxn]; inline void addedge(int x,int y)&#123; e[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt; &#125; void dfs(int x)&#123; size[x]++; bool flag=false; for(int i=head[x];i;i=e[i].nxt) dfs(e[i].to),size[x]+=size[e[i].to],flag=true; if(!flag) &#123; dp[x]=1; return ; &#125; for(int i=head[x];i;i=e[i].nxt) &#123; int y=e[i].to; dp[x]=max(dp[x],min(dp[y],(double)size[y]/(double)(size[x]-1))); &#125; // printf("%d %.7lf\n",x,dp[x]);&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;K); int x; for(int i=2;i&lt;=n;i++) scanf("%d",&amp;x),addedge(x,i); dfs(1); double ans=0; for(int i=1;i&lt;=n;i++) if(size[i]&gt;K&amp;&amp;ans&lt;dp[i]) ans=dp[i]; printf("%.7lf",ans); &#125; 二分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define M 500010#define LL long long#define MOD 1000000007#define inf 2147483647#define eps 1e-7#define llinf 4000000000000000000ll#define For(i, x, y) for(int i = (x); i &lt; (y); i ++)#define rep(i, x, y) for(int i = (x); i &lt;= (y); i ++)#define drep(i, x, y) for(int i = (x); i &gt;= (y); i --)inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;inline LL llread()&#123; char ch=getchar();LL x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;vector&lt;int&gt; G[M];int n, k;int Size[M], fa[M], mx[M];inline void add(int x, int y)&#123; G[x].push_back(y);&#125;inline void get_size()&#123; rep(i, 1, n) Size[i] = 1; drep(i, n, 1) Size[fa[i]] += Size[i]; rep(i, 1, n) Size[i] --;&#125;inline bool check(double x)&#123; rep(i, 1, n) mx[i] = 0; drep(i, n, 1)&#123; if(Size[i]) if(mx[i] / (double)Size[i] - x &gt; eps) mx[i] = Size[i] + 1; mx[i] = max(mx[i], 1); mx[fa[i]] = max(mx[fa[i]], mx[i]); &#125; if(mx[1] &lt;= k) return true; return false;&#125;int main()&#123; //freopen("0input.in", "r", stdin); n = read(), k = read(); rep(i, 2, n) add(fa[i] = read(), i); get_size();// rep(i, 1, n) printf("%d\n", Size[i]); double l = 0.0, r = 1.0, ans; while(abs(r - l) &gt; eps)&#123; double mid = (l + r) / 2.0; if(check(mid)) r = (ans = mid); else l = mid; &#125; printf("%.9lf", ans); return 0;&#125; p.s. 其实上面两个代码都不是我写的。。。我写的二分卡不过去。。。 Problem 3004. -- 吊灯3004: 吊灯Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 123&nbsp;&nbsp;Solved: 64[Submit][Status][Discuss]Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alice家里有一盏很大的吊灯。所谓吊灯，就是由很多个灯泡组成。只有一个灯泡是挂在天花板上的，剩下的灯泡都是挂在其他的灯泡上的。也就是说，整个吊灯实际上类似于一棵树。其中编号为1的灯泡是挂在天花板上的，剩下的灯泡都是挂在编号小于自己的灯泡上的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，Alice想要办一场派对，她想改造一下这盏吊灯，将灯泡换成不同的颜色。她希望相同颜色的灯泡都是相连的，并且每一种颜色的灯泡个数都是相同的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alice希望你能告诉她，总共有哪些方案呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alice是一个贪心的孩子，如果她发现方案不够多，或者太多了，就会很不高兴，于是她会尝试调整。对于编号为x(x&ne;1)的灯泡，如果原来是挂在编号为f[x]的灯泡上，那么Alice会把第x个灯泡挂到第 ( f[x] + 19940105 ) mod (x-1) + 1 个灯泡上。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于九在古汉语中表示极大的数，于是，Alice决定只调整9次。对于原始状态和每一次调整过的状态，Alice希望你依次告诉她每种状态下有哪些方案。Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一行一个整数n，表示灯泡的数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来一行，有n-1个整数Ui，第i个数字表示第i+1个灯泡挂在了Ui个的下面。保证编号为1的灯泡是挂在天花板上的。数字之间用逗号&lsquo;，&rsquo;隔开且最后一个数字后面没有逗号。Output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于10种状态下的方案，需要按照顺序依次输出。 对于每一种状态，需要先输出单独的一行，表示状态编号，如样例所示。 之后若干行，每行1个整数，表示划分方案中每种颜色的灯泡个数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 按升序输出。 &nbsp;Sample Input 6 1,2,3,4,5 Sample Output Case #1: 1 2 3 6 Case #2: 1 2 6 Case #3: 1 3 6 Case #4: 1 3 6 Case #5: 1 3 6 Case #6: 1 2 6 Case #7: 1 2 3 6 Case #8: 1 6 Case #9: 1 2 6 Case #10: 1 3 6 HINT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于100%的数据，n&lt;=1.2*106。Source Tags: 树 划分问题 思维题 题目分析树上等大小划分问题 前几天noip模拟赛几乎一毛一样的题。。。 首先可以知道，对于一种大小，如果可行，则只有一种安排的方案 然后，如果存在一个结点的所有儿子结点的子树大小模块大小的和大于这个结点的子树大小模块大小的值，那么无解 进一步观察，我们可以发现，如果一个结点的子树可以被正好地划分为一些大小为块大小的块，那么这个点的子树大小一定是块大小的倍数 所以，我们只要保证这样的结点的数量大于点等于块的数量就行了（其实不能大于），因为每一个块，都对应且仅对应一个这样的结点 代码注意不要使用DFS来求siz数组，否则会T。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define maxn 1300005using namespace std;int n, m, k;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int save[maxn];int ct = 0;void preprocess()&#123; int con = (int) sqrt(n); for (int i = 1; i &lt;= con; i++)&#123; if (n % i == 0) save[ct++] = i, save[ct++] = n / i; &#125; if (con * con == n) ct--; sort(save, save + ct);&#125;int f[maxn];int siz[maxn];void DFS(int x)&#123; siz[x] = 1; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == f[x]) continue; DFS(op); siz[x] += siz[op]; &#125;&#125;void init()&#123; memset(h, 0, sizeof(h)); cnt = 1; for (int i = 2; i &lt;= n; i++) Add_Edge(i, f[i]); //DFS(1); for (int i = 1; i &lt;= n; i++) siz[i] = 1; for (int i = n; i &gt;= 2; i--) siz[f[i]] += siz[i];&#125;int num[maxn];void work()&#123; memset(num, 0, sizeof(num)); for (int i = 1; i &lt;= n; i++) num[siz[i]]++; for (int i = 0; i &lt; ct; i++)&#123; int now = 0; for (int j = 0; j &lt;= n; j += save[i]) now += num[j]; if (now &gt;= n / save[i]) printf("%d\n", save[i]); &#125;&#125;void transform()&#123; for (int i = 2; i &lt;= n; i++) f[i] = (f[i] + 19940105) % (i - 1) + 1;&#125;template &lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; read(n); preprocess(); for (int i = 2; i &lt;= n; i++) read(f[i]); for (int k = 0; k &lt; 10; k++)&#123; printf("Case #%d:\n", k + 1); init(); work(); transform(); &#125; return 0;&#125; Problem 2662. -- [BeiJing wc2012]冻结 2662: [BeiJing wc2012]冻结 Time Limit: 3 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 1010&nbsp;&nbsp;Solved: 544[Submit][Status][Discuss]Description&nbsp; &ldquo;我要成为魔法少女！&rdquo;&nbsp;&nbsp; &nbsp; &ldquo;那么，以灵魂为代价，你希望得到什么？&rdquo; &ldquo;我要将有关魔法和奇迹的一切，封印于卡片之中&bdquo;&bdquo;&rdquo;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符 卡）带来的便捷。 &nbsp; 现在，不需要立下契约也可以使用魔法了！你还不来试一试？ &nbsp; 比如，我们在魔法百科全书（Encyclopedia&nbsp; of&nbsp; Spells）里用&ldquo;freeze&rdquo;作为关 键字来查询，会有很多有趣的结果。 例如，我们熟知的Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。 当然， 更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小 巫见大巫了。 这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、&bdquo;&bdquo; 当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。 &nbsp; 我们考虑最简单的旅行问题吧：&nbsp; 现在这个大陆上有 N 个城市，M 条双向的 道路。城市编号为 1~N，我们在 1 号城市，需要到 N 号城市，怎样才能最快地 到达呢？ &nbsp; 这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、 Floyd-Warshall等算法来解决。 &nbsp; 现在，我们一共有 K 张可以使时间变慢 50%的 SpellCard，也就是说，在通 过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是： &nbsp; 1. 在一条道路上最多只能使用一张 SpellCard。 &nbsp; 2. 使用一张SpellCard 只在一条道路上起作用。 &nbsp; 3. 你不必使用完所有的 SpellCard。 &nbsp;&nbsp; &nbsp; 给定以上的信息，你的任务是：求出在可以使用这不超过 K 张时间减速的 SpellCard 之情形下，从城市1 到城市N最少需要多长时间。 Input 第一行包含三个整数：N、M、K。 接下来 M 行，每行包含三个整数：Ai、Bi、Timei，表示存在一条 Ai与 Bi之 间的双向道路，在不使用 SpellCard 之前提下，通过它需要 Timei的时间。 Output输出一个整数，表示从1 号城市到 N号城市的最小用时。 Sample Input 4 4 1 1 2 4 4 2 6 1 3 8 3 4 8 Sample Output 7 【样例1 解释】 在不使用 SpellCard 时，最短路为 1à2à4，总时间为 10。现在我们可 以使用 1 次 SpellCard，那么我们将通过 2à4 这条道路的时间减半，此时总 时间为7。 HINT 对于100%的数据：1&nbsp; &le;&nbsp; K&nbsp; &le;&nbsp; N &le;&nbsp; 50，M&nbsp; &le;&nbsp; 1000。 &nbsp; 1&le;&nbsp; Ai，Bi &le;&nbsp; N，2 &le;&nbsp; Timei&nbsp; &le;&nbsp; 2000。 为保证答案为整数，保证所有的 Timei均为偶数。 所有数据中的无向图保证无自环、重边，且是连通的。&nbsp;&nbsp;&nbsp; &nbsp;&lt;/p&gt;&lt;/div&gt;Source Tags: 图论 最短路 拆点法 题目分析拆点/边法问题 这道题一开始SB直接写的最短路，然后把最短路上的边由大到小进行处理，很显然这样是错的对吧。。。 但是不知为什么，刚发现这样是错误的，就想到了正解。。。可能突然发现边减半以后就是那个样子，不受其他条件影响，所以突然想这样搞，看数据范围好像也确实是这样搞的。。。 正解就是我们把点拆开，使点拥有当前经过了多少减半边的信息，这样就会有（$n * ( k + 1)$)个点，然后随便连一下边，本题就搞定了。。。 所以有的时候灵感就在于一瞬间。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#define maxn 1000005#define INF 2000000005using namespace std;int n, m, k;struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, int len)&#123; e[++cnt] = edge(h[fr], to, len); h[fr] = cnt;&#125;struct add&#123; int x, y, len; add(int x, int y, int len) : x(x), y(y), len(len)&#123;&#125; add()&#123;&#125;&#125;save[maxn];int d[maxn];bool vis[maxn];void SPFA()&#123; queue&lt;int&gt; spfa; spfa.push(0); vis[0] = 1; d[0] = 0; for (int i = 1; i &lt; n * (k + 1); i++) d[i] = INF; while (!spfa.empty())&#123; int op = spfa.front(); spfa.pop(); for (int i = h[op]; i; i = e[i].next)&#123; int k = e[i].to; if (d[k] &gt; d[op] + e[i].len)&#123; d[k] = d[op] + e[i].len; if (!vis[k]) spfa.push(k), vis[k] = 1; &#125; &#125; vis[op] = 0; &#125; int minnum = INF; for (int i = 0; i &lt;= k; i++) minnum = min(minnum, d[(n - 1) * (k + 1) + i]); printf("%d", minnum);&#125;void build()&#123; for (int i = 1; i &lt;= m; i++)&#123; int op1 = (save[i].x - 1) * (k + 1); int op2 = (save[i].y - 1) * (k + 1); for (int num = 0; num &lt; k; num++)&#123; Add_Edge(op1 + num, op2 + num + 1, save[i].len &gt;&gt; 1); Add_Edge(op2 + num, op1 + num + 1, save[i].len &gt;&gt; 1); Add_Edge(op1 + num, op2 + num, save[i].len); Add_Edge(op2 + num, op1 + num, save[i].len); &#125; Add_Edge(op1 + k, op2 + k, save[i].len); Add_Edge(op2 + k, op1 + k, save[i].len); &#125;&#125;template &lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; int x, y, w; read(n), read(m), read(k); for (int i = 1; i &lt;= m; i++)&#123; read(x), read(y), read(w); save[i] = add(x, y, w); &#125; build(); SPFA(); return 0;&#125; Problem 4723. -- [POI2017]Flappy Bird4723: [POI2017]Flappy BirdTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 394&nbsp;&nbsp;Solved: 160[Submit][Status][Discuss]Description《飞扬的小鸟》是一款风靡的小游戏。在游戏中，小鸟一开始位于(0,0)处，它的目标是飞到横坐标为X的某个位置 上。每一秒，你可以选择点击屏幕，那么小鸟会从(x,y)飞到(x+1,y+1)，或者不点击，那么小鸟会飞到(x+1,y-1) 。在游戏中还有n个障碍物，用三元组(x[i],a[i],b[i])描述，表示在直线x=x[i]上，y&lt;=a[i]或者y&gt;=b[i]的部分 都是障碍物，碰到或者擦边都算游戏失败。请求出小鸟从(0,0)飞到目的地最少需要点击多少次屏幕。 Input第一行包含两个整数n(0&lt;=n&lt;=500000),X(1&lt;=n&lt;=10^9)。 接下来n行，每行三个整数x[i],a[i],b[i](0&lt;x[i]&lt;X，-10^9&lt;=a[i]&lt;b[i]&lt;=10^9)。 数据保证x[i]&lt;x[i+1]。 Output如果无论如何都飞不到目的地，输出NIE，否则输出点击屏幕的最少次数。 Sample Input 4 11 4 1 4 7 -1 2 8 -1 3 9 0 2Sample Output 5HINT Source 鸣谢Claris上传 Tags: 限制性问题 思维题 题目分析上下界最优问题 首先%%%JCY大佬直接用手机1A Orz。。。 而我这垃圾最后写不过还去要的数据。。。 主要是想到把问题化成解析几何问题，求出直线方程，这样会方便许多，然后直接求出大于号形的可活动的范围，然后为了使点击次数最少，直接沿着界下面的那条边一直点即可 注意没有障碍物的情况，这是线段树会炸。。。然而本题其实后缀极值就可以。。。 除此以外还有挺多的情况，比如一开始就在界的外面什么的，这些都不成立 代码注意：线段树不能在$n=0$的时候使用！！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 1000005#define INF 2000000005#define LL long long intusing namespace std;int n, X;struct obj&#123; LL pos, up, low; obj(LL pos, LL up, LL low) : pos(pos), up(up) ,low(low)&#123;&#125; obj()&#123;&#125;&#125;save[maxn];LL maxnum[maxn &lt;&lt; 1];LL minnum[maxn &lt;&lt; 1];int qx, qy, qd;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]); minnum[o] = min(minnum[o &lt;&lt; 1], minnum[o &lt;&lt; 1 | 1]);&#125;void init(int l, int r, int o)&#123; if (l == r) &#123; maxnum[o] = save[l].up - save[l].pos + 1; minnum[o] = save[l].low + save[l].pos - 1; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;LL find_min(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return minnum[o]; int mid =((r - l) &gt;&gt; 1) + l; LL ans = INF; if (qx &lt;= mid) ans = min(ans, find_min(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = min(ans, find_min(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;LL find_max(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return maxnum[o]; int mid = ((r - l) &gt;&gt; 1) + l; LL ans = -INF; if (qx &lt;= mid) ans = max(ans, find_max(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = max(ans, find_max(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;void work()&#123; LL ans = 0; LL now = 0; LL nowy = 0; for (int i = 1; i &lt;= n; i++)&#123; qx = i, qy = n; int mx = find_max(1, n, 1); int mi = find_min(1, n, 1); if (now + mx &gt; nowy || nowy &gt; -now + mi) &#123; printf("NIE"); return; &#125; if ((LL)mi - mx &lt; (save[i].pos &lt;&lt; 1)) &#123; printf("NIE"); return; &#125; else if (mi - mx == (save[i].pos &lt;&lt; 1))&#123; if ((save[i].pos + save[i].pos + mx) &amp; 1) &#123; printf("NIE"); return; &#125; &#125; LL rec = (nowy - (now + mx)) &gt;&gt; 1; if (now + rec &gt; save[i].pos)&#123; nowy -= save[i].pos - now; now = save[i].pos; &#125; else&#123; now += rec; nowy -= rec; ans += save[i].pos - now; nowy += save[i].pos - now; now = save[i].pos; &#125; &#125; printf("%lld", ans);&#125;template &lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); bool f = 1; if (ch == '-') f = 0, ch = getchar(); x = 0; while (isdigit(ch)) x = 10L * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; read(n), read(X); for (int i = 1; i &lt;= n; i++)&#123; read(save[i].pos), read(save[i].up), read(save[i].low); &#125; if (n == 0) &#123; printf("0"); return 0; &#125; init(1, n, 1); work(); return 0;&#125; Problem 4724. -- [POI2017]Podzielno4724: [POI2017]PodzielnoTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 293&nbsp;&nbsp;Solved: 129[Submit][Status][Discuss]DescriptionB进制数，每个数字i(i=0,1,...,B-1)有a[i]个。你要用这些数字组成一个最大的B进制数X(不能有前导零，不需要 用完所有数字)，使得X是B-1的倍数。q次询问，每次询问X在B进制下的第k位数字是什么(最低位是第0位)。 Input第一行包含两个正整数B(2&lt;=B&lt;=10^6),q(1&lt;=q&lt;=10^5)。 第二行包含B个正整数a[0],a[1],a[2],...,a[B-1](1&lt;=a[i]&lt;=10^6)。 接下来q行，每行一个整数k(0&lt;=k&lt;=10^18)，表示一个询问。 Output输出q行，每行一个整数，依次回答每个询问，如果那一位不存在，请输出-1。 Sample Input 3 3 1 1 1 0 1 2Sample Output 0 2 -1HINT Source 鸣谢Claris上传 Tags: 进制问题 思维题 题目分析进制问题 初始想法，题目要求即是所有位上的数字之和为$B-1$的倍数，所以我们肯定是要先让位数最多，然后再让大的数字尽可能多，但是这样要考虑的就太多了，不好处理 我们先把每个数都预留一个出去，这样剩下的数就全都可以选了，因为余数可以用预留的数抵消，剩下的数字两两配对 这样，我们就至少可以选$n - 1$个数了，如果所有数字的和是$B-1$的倍数，那么显然全都可以选 所以我们也同时证明了这样选一定是最优的（构法证明），因为所有数字的和不是$B-1$的倍数时，本来就是至多选$n-1$个 所以数字也就随之固定了，直接前缀和处理二分查找即可回答询问 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 1000005#define LL long long intusing namespace std;int n, k;LL line[maxn];template &lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; LL x; read(n), read(k); LL sum = 0; for (int i = 0; i &lt; n; i++) read(line[i]), sum = (sum + line[i] * i % (n - 1)) % (n - 1); if (sum) line[sum]--; /*for (int i = n - 1; i &gt;= 0; i--)&#123; sline[i] = line[i] + sline[i + 1]; &#125; reverse(sline, sline + n); for (int i = 1; i &lt;= k; i++)&#123; scanf("%d", &amp;x); printf("%d\n", n - 1 - (lower_bound(sline, sline + n, x) - sline)); &#125;*/ for (int i = 1; i &lt; n; i++) line[i] += line[i - 1]; for (int i = 0; i &lt; k; i++)&#123; read(x); x++; int pos = lower_bound(line, line + n, x) - line; if (pos &gt;= n) printf("-1\n"); else printf("%d\n", pos); &#125; return 0;&#125; Problem 4407. -- 于神之怒加强版4407: 于神之怒加强版Time Limit: 80 Sec&nbsp;&nbsp;Memory Limit: 512 MBSubmit: 779&nbsp;&nbsp;Solved: 368[Submit][Status][Discuss]Description给下N,M,K.求 Input输入有多组数据，输入数据的第一行两个正整数T,K，代表有T组数据，K的意义如上所示，下面第二行到第T+1行，每行为两个正整数N,M，其意义如上式所示。 Output如题 Sample Input 1 2 3 3 Sample Output 20 HINT 1&lt;=N,M,K&lt;=5000000,1&lt;=T&lt;=2000 题解：JudgeOnline/upload/201603/4407.rar Source 命题人：成都七中张耀楠，鸣谢excited上传。 Tags: 数学 数论 莫比乌斯反演 题目分析莫比乌斯反演基础题 一道水题，只要直接莫比乌斯反演套路即可解决，如果觉得本题有难度，请移步《莫比乌斯反演总结》 其实只要想到那个大函数可以线性筛就行了，不懂的看一遍上面的总结然后自己推公式 然而忘了线性筛T了一发。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define LL long long int#define M 1000000007#define maxn 5000005using namespace std;int p[maxn];int cnt = 0;bool vis[maxn];int n, k;LL F[maxn];LL mi[maxn];LL fast_power(int x, int y)&#123; LL ans = 1, con = x; while (y)&#123; if (y &amp; 1) ans = ans * con % M; con = con * con % M; y &gt;&gt;= 1; &#125; return ans;&#125;void init()&#123; F[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; F[i] = (fast_power(i, k) - 1 + M) % M; mi[i] = fast_power(i, k); &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (p[j] * i &gt;= maxn) break; vis[i * p[j]] = 1; F[i * p[j]] = F[i] * F[p[j]] % M; if (i % p[j] == 0) &#123; F[i * p[j]] = F[i] * mi[p[j]] % M; break; &#125; &#125; &#125; /*for (int i = 1; i &lt; maxn; i++)&#123; for (int j = 1; i * j &lt; maxn; j++)&#123; F[i * j] = (F[i * j] + mu[i] * mi[j] % M) % M; &#125; &#125;*/ for (int i = 1; i &lt; maxn; i++) F[i] = (F[i] + F[i - 1]) % M;&#125;void work(int n, int m)&#123; LL ans = 0; for (int i = 1; i &lt;= min(n, m); i++)&#123; int next = min(n / (n / i), m / (m / i)); ans = (ans + ((F[next] - F[i - 1]) % M + M) % M * (m / i) % M * (n / i) % M) % M; i = next; &#125; printf("%lld\n", ans);&#125;int main()&#123; int T, n, m; scanf("%d%d", &amp;T, &amp;k); init(); while (T--)&#123; scanf("%d%d", &amp;n, &amp;m); work(n, m); &#125; return 0;&#125; Problem 1922. -- [Sdoi2010]大陆争霸1922: [Sdoi2010]大陆争霸Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 64 MBSubmit: 1965&nbsp;&nbsp;Solved: 869[Submit][Status][Discuss]Description在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的 克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭 的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。 幻想历 8012年 1月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同 时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。 幻想历 8012年 3月2日，位于杰森国东部小镇神谕镇的克里斯国教徒发动 起义。 幻想历 8012年 3月7日，神谕镇的起义被杰森国大军以残酷手段镇压。 幻想历 8012年 3月8日，克里斯国对杰森国宣战。由数十万大军组成的克 里斯军团开至两国边境，与杰森军团对峙。 幻想历 8012年 4月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存 的克里斯国教徒得到解放。 战争随后进入胶着状态，旷日持久。战况惨烈，一时间枪林弹雨，硝烟弥漫， 民不聊生。 幻想历 8012年 5月12日深夜，斯普林·布拉泽降下神谕：“Trust me, earn eternal life.”克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机 会发动奇袭，一举击败杰森国。具体地说，杰森国有 N 个城市，由 M条单向道 路连接。神谕镇是城市 1而杰森国的首都是城市 N。你只需摧毁位于杰森国首都 的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。 为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困 难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个 城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个 城市，你就必须破坏掉维持这个城市结界的所有结界发生器。 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间 引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会 一起被破坏。你需要知道：摧毁杰森国所需的最短时间。 Input第一行两个正整数 N, M。 接下来 M行，每行三个正整数 ui, vi, wi，表示有一条从城市ui到城市 vi的单 向道路，自爆机器人通过这条道路需要 wi的时间。 之后 N 行，每行描述一个城市。首先是一个正整数 li，维持这个城市结界所 使用的结界发生器数目。之后li个1~N 之间的城市编号，表示每个结界发生器的 位置。如果 Li = 0，则说明该城市没有结界保护，保证L1 = 0 。 Output仅包含一个正整数 ，击败杰森国所需的最短时间。 Sample Input 6 6 1 2 1 1 4 3 2 3 1 2 5 2 4 6 2 5 3 2 0 0 0 1 3 0 2 3 5 Sample Output 5 HINT 对于 20%的数据，满足 N≤15，M≤50； 对于 50%的数据，满足 N≤500，M≤6,000； 对于 100%的数据，满足 N≤3,000，M≤70,000，1≤wi≤108 。 输入数据保证一定有解，且不会存在维持某个城市结界的结界发生器在这个 城市内部。 连接两个城市的道路可能不止一条， 也可能存在一个城市自己到自己的道路。Source 第一轮Day1 Tags: 图论 最短路 限制性问题 题目分析带限制最短路问题 高二的小伙伴们做的题。。。 本题其实是不错的，可以很好地增进对各种最短路算法的深层理解 本题就是一个最短路，但是绝对不能用SPFA，因为SPFA会重复入队，这样用一个点更新被它搞掉结界的城市的距离的时候就不是它真正的最短距离，就会发生错误（除非每次入队都更新一遍，但是那样不太好是吧，复杂度比较玄学，反正我没写。。。） 所以，我们就要使用堆优化的Dijkstra解决本题，但是我们必须开两个距离数组，一个是它的可进入时间，另一个是抵达时间，这两个取MAX才是进入它的真正时间 如果我就是想开一个呢？为什么不行？ 这是因为，一个城市可能它还没有被访问到，但是它的结界已经被干掉了，这时它的距离数组便是最后一个解放了它的城市的距离 但是在最短路更新到它的时候，我们又会把这个距离变小，并且难以维护抵达它的时间，这个问题好像很难解决，所以这样就发生了错误 同时，我们也能明白一个事实，Dijkstra每次更新的最短路的长度不一定是所有待更新的最短路中长度最短的 最后还有一点，用STL代替当作堆的时候，我们不能直接插入数字，而是要维护结构体，因为如果插入数字，那么数字的排序方法一定关联了外部数组，而外部数组又常常是变化的（比如距离数组），所以就会发生STL内部的错误，而且这样的错误很难被发现，所以一定要小心 总结一下，本题的知识点有如下三点： SPFA最短路更新时会重复入队，所以距离数组在算法结束之前并非真正的最短距离 Dijkstra算法每次更新的最短路的长度不一定是所有待更新的最短路中长度最短的 使用STL对数据进行维护时，尽量不要插入排序方法与外部元素关联的元素，否则会发生内部错误 还是很不错的O(∩_∩)O~ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define pb push_back#define maxn 3005#define maxm 100005#define INF 2000000000000000005L#define LL long long int#define Pii pair&lt;LL, LL&gt;using namespace std;int n, m;int deg[maxn];struct edge&#123; int next, to, len; edge(int next, int to, int len) : next(next), to(to), len(len)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, int len)&#123; e[++cnt] = edge(h[fr], to, len); h[fr] = cnt;&#125;LL d[maxn];LL d2[maxn];bool vis[maxn];vector&lt;int&gt; save[maxn];priority_queue&lt;Pii, vector&lt;Pii&gt;, greater&lt;Pii&gt; &gt; heap;void Dijkstra()&#123; for (int i = 2; i &lt;= n; i++) d[i] = INF; heap.push(Pii(0, 1)); while (!heap.empty())&#123; int op = heap.top().second;heap.pop(); if (vis[op]) continue; vis[op] = 1; LL mx = max(d[op], d2[op]); for (int i = h[op]; i; i = e[i].next)&#123; int k = e[i].to; if (d[k] &gt; mx + e[i].len)&#123; d[k] = mx + e[i].len; if (deg[k]) continue; heap.push(Pii(max(d[k], d2[k]), k)); &#125; &#125; for (int j = 0; j &lt; save[op].size(); j++)&#123; deg[save[op][j]]--; d2[save[op][j]] = max(d2[save[op][j]], mx); if (!deg[save[op][j]]) heap.push(Pii(max(d[save[op][j]], d2[save[op][j]]), save[op][j])); &#125; &#125; printf("%lld", max(d[n], d2[n]));&#125;template &lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;int main()&#123; int x, y, w, op; read(n), read(m); for (int i = 1; i &lt;= m; i++)&#123; read(x), read(y), read(w); if (x == y) continue; Add_Edge(x, y, w); &#125; for (int i = 1; i &lt;= n; i++)&#123; read(deg[i]); for (int j = 0; j &lt; deg[i]; j++)&#123; read(op); save[op].pb(i); &#125; &#125; Dijkstra(); return 0;&#125; Problem 1168. -- [Baltic2008]Gloves1168: [Baltic2008]GlovesTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 413&nbsp;&nbsp;Solved: 120[Submit][Status][Discuss]Description手套被放在了两个抽屉里, 所有的左手套放在左边的抽屉里, 所有的右手套放在右边的抽屉里．手套一共有N种颜色, 已知两个抽屉每种颜色的手套各有多少只, 如果随便在左边拿一只, 右边拿一只 很可能会造成拿到一只红色的左手套和一只蓝色右手套... 现想知道应该从左边的抽屉取出多少只左手套(设为x) 右边的抽屉取出多少只右手套(设为y), 满足至少可以找到一对匹配的手套(即颜色相同), 并且x + y最小 如果有多个(x, y)满足x + y最小, 你希望满足x尽可能的小不妨设 每个抽屉里每只手套被取出的概率是等价的．输入文件输入文件第一行中有一个正整数N,表示颜色的种数．第二行有N个非负整数, 表示左抽屉中每种颜色的左手套的个数．第三行有N个非负整数, 表示右抽屉中每种颜色的右手套的个数．输出文件你需要输出满足题目条件的(x, y)．Input输入文件第一行中有一个正整数N,表示颜色的种数．第二行有N个非负整数, 表示左抽屉中每种颜色的左手套的个数．第三行有N个非负整数, 表示右抽屉中每种颜色的右手套的个数．Output输出满足题目条件的(x, y)．Sample Input 4 0 7 1 6 1 5 0 6Sample Output 2 8HINT 100%的测试数据, N &lt;= 20, 0 &lt;= ai, bi &lt;= 108． Source Tags: 凸壳扫描 单调栈 题目分析凸壳扫描问题 看到本题时内心一惊，这。。。这不是抽屉原理吗？？？那应该非常的水吧？？？ 然而本题卡了半天，才知道世界上还有这么多变态的题目 本题题解大概就是把各种颜色分成两个集合，然后用单调栈扫描 但其实有着无数的细节。。。内心是崩溃的。。。需要绕好半天才能想明白 把题解挂上吧： 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; struct point&#123;int x,y;&#125;p[1&lt;&lt;20|1]; int n,a[21],b[21],cnt,q[1&lt;&lt;20|1],t=1,x,sa,sb; LL s=1e10; void dfs(int x,int l,int r) &#123; if(x==n+1)&#123;p[++cnt].x=l,p[cnt].y=r;return;&#125; dfs(x+1,l+a[x],r),dfs(x+1,l,r+b[x]); &#125; bool operator &lt;(point a,point b)&#123;return a.x==b.x?a.y&gt;b.y:a.x&lt;b.x;&#125; int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]); int tot=n; n=0; for(int i=1;i&lt;=tot;i++) if(!a[i]||!b[i]) sa+=a[i],sb+=b[i]; else a[++n]=a[i],b[n]=b[i]; dfs(1,0,0); sort(p+1,p+cnt+1); for(int i=1;i&lt;=cnt;i++) &#123; while(t&amp;&amp;p[q[t]].y&lt;=p[i].y)t--; q[++t]=i; &#125; for(int i=1;i&lt;=t;i++) &#123; LL tmp=(LL)(p[q[i-1]].x+p[q[i]].y+2); if(tmp&lt;s)s=tmp,x=p[q[i-1]].x+1; else if(tmp==s&amp;&amp;p[q[i-1]].x+1&lt;x)x=p[q[i-1]].x+1; &#125; printf("%d %lld\n",x+sa,s-(LL)x+(LL)sb); &#125; Problem 1340. -- [Baltic2007]Escape逃跑问题1340: [Baltic2007]Escape逃跑问题Time Limit: 5 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 323&nbsp;&nbsp;Solved: 145[Submit][Status][Discuss]Description战犯们企图逃离监狱，他们详细地计划了如何逃出监狱本身，逃出监狱之后他们希望在附近的一个村子里找到掩护。村子（下图中的B）和监狱（图中的A）中间有一个峡谷，这个峡谷也是有士兵守卫的。守卫峡谷的士兵们坐在岗哨上很少走动，每个士兵的观察范围是100米。士兵所处位置决定了战犯们能否安全通过峡谷，安全通过的条件就是在任何时刻战犯们距离最近的士兵大于100米。给定峡谷的长、宽和每个士兵在峡谷中的坐标，假定士兵的位置一直保持不变，请你写一个程序计算战犯们能否不被士兵发现，顺利通过峡谷。如果不能，那么战犯们最少需要消灭几个士兵才能安全通过峡谷（无论士兵是否被另一个士兵看到，他都可以被消灭）。 &lt;/div&gt;Input第一行有三个整数L、W和N，分别表示峡谷的长度、宽度和士兵的人数。接下来的N行，每行两个整数Xi和Yi，表示第i个士兵在峡谷的坐标（0]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libre Online Judge阶段性汇总II]]></title>
    <url>%2F2017%2F09%2F03%2FLibre-Online-Judge%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBII%2F</url>
    <content type="text"><![CDATA[引言题解第二篇MDZZ写题解太累了555 #2036. 「SHOI2015」自动刷题机 题目分析应该挺容易看出来的，二分答案即可，关于二分为什么正确，请自行思考 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define maxn 100005#define INF (LL)4000000000000000005#define LL long long intusing namespace std;LL n,k;LL line[maxn];LL rec = -1;int judge(LL x)&#123; LL now = 0; LL cnt = 0; for (LL i = 0; i &lt; n; i++)&#123; now += line[i]; if (now &gt;= x)&#123; now = 0; cnt++; &#125; (now &lt; 0) ? now = 0 : now = now; &#125; if (k == cnt) return 0; return cnt &lt; k ? -1 : 1;&#125;LL getmax(LL l, LL r)&#123; if (l == r)&#123; if (judge(l) == 0) return l; return rec; &#125; LL mid = ((r - l) &gt;&gt; 1) + l; int d = judge(mid); if (d &gt;= 0)&#123; if (d == 0) rec = mid; return getmax(mid + 1, r); &#125; else return getmax(l, mid);&#125;LL getmin(LL l, LL r)&#123; if (l == r) return l; LL mid = ((r - l) &gt;&gt; 1) + l; if (judge(mid) &lt;= 0) return getmin(l, mid); else return getmin(mid + 1, r);&#125;int main()&#123; scanf("%lld%lld", &amp;n, &amp;k); for (LL i = 0; i &lt; n; i++) scanf("%lld", &amp;line[i]); LL ansmin = getmin(1, INF); LL ansmax = getmax(1, INF); if (ansmin == -1 || judge(ansmin)!=0 || ansmax == -1 || judge(ansmax)!=0) printf("-1"); else printf("%lld %lld", ansmin, ansmax); return 0;&#125; #2194. 「SDOI2014」数数 题目分析本题首先显然是AC自动机，然而情况多，真的很难一遍写对。。。 大概的坑有如下： 集合中的数字开头可以为0 AC自动机中可能包含其他串的结点也不能走到 要注意开始标记的作用，为了避免，要循环累计答案 另外本题LOJ数据弱，第二点没处理也能过，然而BZOJ上就过不了。。。 好了不说了。。。 真正的AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 4005#define M 1000000007using namespace std;bool val[maxn];int ch[maxn][12];int cnt = 0;int f[maxn];char s[maxn];int m;char num[maxn];int ct = 0;int len;void insert()&#123; int now = 0; for (int i = 0; i &lt; len; i++)&#123; if (!ch[now][s[i] - '0']) ch[now][s[i] - '0'] = ++cnt; now = ch[now][s[i] - '0']; &#125; val[now] = 1;&#125;void init()&#123; f[0] = 0; queue&lt;int&gt; bfs; for (int i = 0; i &lt; 10; i++)&#123; if (ch[0][i]) f[ch[0][i]] = 0, bfs.push(ch[0][i]); &#125; while (!bfs.empty())&#123; int op = bfs.front(); bfs.pop(); for (int i = 0; i &lt; 10; i++)&#123; if (!ch[op][i]) ch[op][i] = ch[f[op]][i]; else &#123; int k = f[op]; while (k &amp;&amp; !ch[k][i]) k = f[k]; f[ch[op][i]] = (!ch[k][i]) ? 0 : ch[k][i]; if (val[f[ch[op][i]]]) val[ch[op][i]] = 1;//注意这个地方很重要！！！ bfs.push(ch[op][i]); &#125; &#125; &#125; ct = strlen(num); for (int i = 0; i &lt; ct; i++) num[i] -= '0';&#125;int dp[maxn][maxn][2];bool vis[maxn][maxn][2];int DP(int pos, int loc, int op)&#123; if (val[loc]) return 0; if (pos == ct) return 1; if (vis[pos][loc][op]) return dp[pos][loc][op]; vis[pos][loc][op] = 1; int&amp; ans = dp[pos][loc][op]; if (op)&#123; for (int i = 0; i &lt; num[pos]; i++)&#123; ans = (ans + DP(pos + 1, ch[loc][i], 0)) % M; &#125; ans = (ans + DP(pos + 1, ch[loc][num[pos]], 1)) % M; return ans; &#125; for (int i = 0; i &lt; 10; i++)&#123; ans = (ans + DP(pos + 1, ch[loc][i], 0)) % M; &#125; return ans;&#125;int main()&#123; scanf("%s%d", num, &amp;m); for (int i = 1; i &lt;= m; i++)&#123; scanf("%s", s); len = strlen(s); insert(); &#125; init(); int ans = 0; for (int i = 1; i &lt; ct; i++)&#123; for (int j = 1; j &lt; 10; j++)&#123; ans = (ans + DP(i + 1, ch[0][j], 0)) % M; &#125; &#125; for (int i = 1; i &lt; num[0]; i++) ans = (ans + DP(1, ch[0][i], 0)) % M; ans = (ans + DP(1, ch[0][num[0]], 1)) % M; printf("%d", ans); return 0;&#125; #2234. 「JLOI2014」聪明的燕姿 题目分析省选题真是谁都能黑啊。。。世道好轮回，省选绕过谁 本题即是传说中的对于质因子进行DFS暴力搜索的题目，然而我太弱，WA了无数次。。。 主要就是注意如何剪枝以及避免错误吧 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define maxn 100005#define INF 2000000005#define pb push_back#define LL long long intusing namespace std;int p[maxn][32];int save[maxn][32];int si[maxn];int cnt;bool vis[maxn];void init()&#123; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++][1] = i; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j][1] &gt;= maxn) break; vis[i * p[j][1]] = 1; if (i % p[j][1] == 0) break; &#125; &#125; for (int i = 0; i &lt; cnt; i++)&#123; save[i][0] = p[i][0] = 1; save[i][1] = p[i][1]; for (int j = 2; j &lt; 32; j++)&#123; if ((LL)p[i][j - 1] * save[i][1] &gt;= INF) &#123; si[i] = j; break; &#125; save[i][j] = p[i][j] = p[i][j - 1] * save[i][1]; &#125; for (int j = 1; j &lt; si[i]; j++)&#123; if ((LL)p[i][j - 1] + p[i][j] &gt;= INF)&#123; si[i] = j; break; &#125; p[i][j] += p[i][j - 1]; &#125; &#125;&#125;bool judge(int x)&#123; int con = (int) sqrt(x); for (int i = 0; i &lt; cnt; i++)&#123; if (save[i][1] &gt; con) return true; if (x % save[i][1] == 0) return false; &#125; return true;&#125;vector&lt;int&gt; ans;void DFS(int pos, int rest, int now)&#123; if (rest &lt; p[pos][1])&#123; if (rest == 1) ans.pb(now); return; &#125; if ((LL)rest &lt; (LL)p[pos][1] * p[pos][1] &amp;&amp; rest &lt; ((p[pos][2] &gt; 0) ? p[pos][2] : INF))&#123; if (judge(rest - 1)) ans.pb(now * (rest - 1)); return; &#125; /*if (pos == cnt &amp;&amp; rest - 1 &gt;= maxn)&#123; if (judge(rest - 1)) ans.pb(now * (rest - 1)); return; &#125;*/ for (int i = 0; i &lt; si[pos]; i++)&#123; if (p[pos][i] &gt; rest) return; if (rest % p[pos][i] == 0) DFS(pos + 1, rest / p[pos][i], now * save[pos][i]); &#125;&#125;bool f = 0;void work(int x)&#123; if (!f)&#123; DFS(0, x, 1); sort(ans.begin(), ans.end()); if (ans.size() == 0)&#123; printf("0"); &#125; else&#123; printf("%d\n", ans.size()); printf("%d", ans[0]); for (int i = 1; i &lt; ans.size(); i++) printf(" %d", ans[i]); ans.clear(); &#125; f = 1; return; &#125; DFS(0, x, 1); sort(ans.begin(), ans.end()); if (ans.size() == 0)&#123; printf("\n0"); &#125; else&#123; printf("\n%d\n", ans.size()); printf("%d", ans[0]); for (int i = 1; i &lt; ans.size(); i++) printf(" %d", ans[i]); ans.clear(); &#125;&#125;int main()&#123; init(); int n; while (scanf("%d", &amp;n) == 1) work(n); return 0;&#125; 其实细节还是很多的，可能是因为我太弱了。。。 #2236. 「JLOI2014」松鼠的新家 题目分析树链剖分 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;int n;int line[maxn];struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int d[maxn];int fa[maxn];int si[maxn];int top[maxn];int dfs[maxn];int idfs[maxn];int son[maxn];int t = 0;void DFS1(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x]) continue; d[op] = d[x] + 1; fa[op] = x; DFS1(op); si[x] += si[op]; if (si[op] &gt; si[son[x]]) son[x] = op; &#125; si[x]++;&#125;void DFS2(int x, int tp)&#123; dfs[x] = ++t; idfs[t] = x; top[x] = tp; if (son[x]) DFS2(son[x], tp); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x] || op == son[x]) continue; DFS2(op, op); &#125;&#125;int sum[maxn &lt;&lt; 1];int add[maxn &lt;&lt; 1];int qx, qy, qd;void pushdown(int l, int r, int o)&#123; if (add[o] != 0 &amp;&amp; l != r)&#123; int mid = ((r - l) &gt;&gt; 1) + l; add[o &lt;&lt; 1] += add[o]; sum[o &lt;&lt; 1] += (mid + 1 - l) * add[o]; add[o &lt;&lt; 1 | 1] += add[o]; sum[o &lt;&lt; 1 | 1] += (r - mid) * add[o]; add[o] = 0; &#125;&#125;void pushup(int l, int r, int o)&#123; if (l == r) return; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) &#123; add[o] += qd; sum[o] += qd * (r - l + 1); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); if (l == r) return sum[o]; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) return get(l, mid, o &lt;&lt; 1); else return get(mid + 1, r, o &lt;&lt; 1 | 1);&#125;void Add(int x, int y, int v)&#123; int f1 = top[x], f2 = top[y]; qd = v; while (f1 != f2)&#123; if (d[f1] &gt; d[f2])&#123; qx = dfs[f1], qy = dfs[x]; modify(1, n, 1); x = fa[f1]; f1 = top[x]; &#125; else&#123; qx = dfs[f2], qy = dfs[y]; modify(1, n, 1); y = fa[f2]; f2 = top[y]; &#125; &#125; if (d[x] &lt; d[y]) swap(x, y); qx = dfs[y], qy = dfs[x]; modify(1, n, 1);&#125;void Add(int x, int y)&#123; Add(x, y, 1); Add(y, y, -1);&#125;void init()&#123; DFS1(1); DFS2(1, 1);&#125;int main()&#123; int x, y; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); for (int i = 1; i &lt;= n - 1; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; init(); for (int i = 1; i &lt;= n - 1; i++)&#123; Add(line[i], line[i + 1]); &#125; for (int i = 1; i &lt;= n; i++)&#123; qx = dfs[i]; printf("%d\n", get(1, n, 1)); &#125; return 0;&#125; #2245. 「NOI2014」魔法森林 题目分析正解显然是LCT，然而还有另一种方法，就是动点SPFA，把边按其中一维排序后逐个加入，然后只对当前存在的边跑SPFA，这样就过了。。。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define maxn 1000005#define INF 2000000005using namespace std;int n, m;int f[maxn];struct edge&#123; int x, y, a, b; edge(int x, int y, int a, int b) : x(x), y(y), a(a), b(b)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];vector&lt;int&gt; save[maxn];bool cmp(edge a, edge b)&#123; return a.a &lt; b.a;&#125;queue&lt;int&gt; spfa;int now;int ans = INF;bool in[maxn];bool have[maxn];void SPFA()&#123; while (!spfa.empty())&#123; int op = spfa.front();spfa.pop(); for (int i = 0; i &lt; save[op].size(); i++)&#123; int t = save[op][i]; if (!have[t]) continue; int k = (e[t].x == op) ? e[t].y : e[t].x; if (e[t].a &gt; now) continue; if (f[k] &gt; max(f[op], e[t].b))&#123; f[k] = max(f[op], e[t].b); if (!in[k])&#123; spfa.push(k); in[k] = 1; &#125; if (k == n) ans = min(ans, now + f[k]); &#125; &#125; in[op] = 0; &#125;&#125;void work()&#123; for (int i = 0; i &lt; m; i++)&#123; edge op = e[i]; have[i] = 1; int a = op.x, b = op.y; if (a == b) continue; spfa.push(b);spfa.push(a); now = op.a; SPFA(); &#125; printf("%d", ans);&#125;bool vis[maxn];bool judge()&#123; queue&lt;int&gt; bfs; bfs.push(1); vis[1] = 1; while (!bfs.empty())&#123; int op = bfs.front(); bfs.pop(); for (int i = 0; i &lt; save[op].size(); i++)&#123; int k = save[op][i]; int t = (e[k].x == op) ? e[k].y : e[k].x; if (vis[t]) continue; vis[t] = 1; bfs.push(t); &#125; &#125; if (!vis[n]) return false; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) f[i] = INF; f[1] = 0; int x, y, z, w; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;z, &amp;w); e[i] = edge(x, y, z, w); &#125; sort(e, e + m, cmp); for (int i = 0; i &lt; m; i++)&#123; save[e[i].x].push_back(i); save[e[i].y].push_back(i); &#125; if (!judge())&#123; printf("-1"); return 0; &#125; work(); return 0;&#125; 动点SPFA写的。。。 #2246. 「NOI2014」动物园 题目分析这道题其实是一道很好的题目，能加强对KMP的理解 其实fail函数有两种实现，一种是代表包含自己前一个位置但不含自己的最长border长度，另一种是自己也算在内的最长border长度 这两者的处理方式并不相同，所以一定要想清楚KMP的原理 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define M 1000000007#define maxn 1000005#define LL long long intusing namespace std;char t[maxn];int lent;int f[maxn];int f1[maxn];int num[maxn];int f2[maxn];void init()&#123; f[0] = -1; f1[0] = -1; num[0] = 0; for (int i = 1; i &lt; lent; i++)&#123; int k = f[i - 1]; while (k &gt; -1 &amp;&amp; t[k + 1] != t[i]) k = f[k]; f[i] = ((t[k + 1] == t[i]) ? k + 1 : -1); num[i] = ((t[k + 1] == t[i]) ? num[k + 1] + 1 : 0); k = f1[i - 1]; while (k &gt; -1 &amp;&amp; t[k + 1] != t[i]) k = f[k]; f1[i] = ((t[k + 1] == t[i]) ? k + 1 : -1); while (f1[i] &gt; -1 &amp;&amp; ((f1[i] + 1) &lt;&lt; 1) &gt; i + 1) f1[i] = f[f1[i]]; f2[i] = (f1[i] == -1) ? 0 : (num[f1[i]] + 1); /*k = f[i + 1]; int pre = i + 1; while (k &amp;&amp; (k &lt;&lt; 1) &gt; i + 1) k = f[k], pre = f[pre]; f2[i + 1] = num[pre];*/ &#125;&#125;void work()&#123; LL ans = 1; for (int i = 0; i &lt; lent; i++) ans = ans * (f2[i] + 1) % M; printf("%lld\n", ans);&#125;int main()&#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%s", t); lent = strlen(t); init(); work(); &#125; return 0;&#125; #6030. 「雅礼集训 2017 Day1」矩阵 题目分析题目描述上类似于POI某年的tab那道题，都是一些矩阵上的思维题，本题可以发现，如果我们拥有了一个行，它里面的格子全都是黑色的，那么我们就可以随(wei)便(suo)染(yu)色(wei)了对吧，但是如果我们没有这样的一行，我们就必须要考虑如何让它出现，我们可以知道，把一整行染黑的代价是这一行中白色的个数，但是这一行所对应的列（就是转置矩阵的对应的那个行）必须要有至少一个黑格才行，如果没有就要让它再额外的染一次才行，这样就有一个额外的代价 而当我们把某行全染黑了以后，我们把整个矩阵染黑的代价是多少呢？那就是含有白色的列的个数 我们把这两部分代价合起来考虑，如果我们要让某一行全黑，那么假设一开始它不是全黑的，那么我们一定要使用它这一行里面白色格子的数量这些代价来染（仅考虑可以被全染黑的情况），此外，由于此时除了这一行外，没有全黑的行，那么刚才为了给这一行全染黑，刚才行的每个白格对应的列都会有至少一个白格，这样相当于每个白格需要耗费二的代价（1+1），但是如果原先就是黑色的，那么当且仅当这个黑格对应的列没有白格才不会产生代价，否则还是要加上一的代价（属于后半部分的代价）（0+1） 什么时候无解呢？回到上面提到过的： 我们可以知道，把一整行染黑的代价是这一行中白色的个数，但是这一行所对应的列（就是转置矩阵的对应的那个行）必须要有至少一个黑格才行，如果没有就要让它再额外的染一次才行，这样就有一个额外的代价 即，如果没有这样的黑格，我们就要想办法让这行对应的那个列出现至少一个黑格，这样就变成了，只要矩阵中有至少一个黑格，就不是无解的，想一想为什么（我们把这一个黑格对应的行直接染到需要的那个列上，再用那个列去染最开始的那一行即可） 所以，综上所述： 当且仅当没有黑格时， 无解 有一行全黑时，答案等于含有白格的列的个数 没有任何一行全黑时，答案等于所有行的代价的最小值，行的代价的计算式是：这一行对应的额外代价（0或1）+刚才提到的黑白格分别产生的代价 其实易证这样一定是最少的步数 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1005#define INF 2000000005using namespace std;char geo[maxn][maxn];int n;int save[maxn];int if_col_full[maxn];int if_col_empty[maxn];void work()&#123; bool have = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (geo[i][j] == '#')&#123; have = 1; goto jump; &#125; &#125; &#125; jump : if (!have) &#123; printf("-1\n"); return; &#125; for (int j = 0; j &lt; n; j++)&#123; if_col_empty[j] = 1; if_col_full[j] = 1; for (int i = 0; i &lt; n; i++)&#123; if (geo[i][j] == '#') if_col_empty[j] = 0; else if_col_full[j] = 0; &#125; &#125; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (geo[i][j] == '.') save[i] += 2; else save[i] += (if_col_full[j] ^ 1); &#125; save[i] += if_col_empty[i]; if (save[i] == 0)&#123; printf("0"); return; &#125; &#125; int ans = INF; for (int i = 0; i &lt; n; i++)&#123; ans = min(ans, save[i]); &#125; printf("%d", ans);&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%s", geo[i]); work(); return 0;&#125; #6062. 「2017 山东一轮集训 Day2」Pair 题目分析这题刚做的时候看错题了。。。以为只能对应位置匹配。。。 如果不是对应位置，本题就比较显然了，我们先把和大于等于$h$的限制转化，化为差的形式，这样就是把${b_i}$变成了${h-b_i}$，设这个新的数列为${c_i}$，我们可以想象把${a_i}$和${c_i}$放在一起排好了序，然后统计所有前缀中属于数列${a_i}$的元素个数与属于数列${c_i}$的元素个数的差（除了最后一个最大的前缀），如果这个差的最大值小于等于零，那么可以匹配（想一想为什么） 而这些可以使用线段树进行维护，那么本题就解决了 AC代码（注意代码实现与题目分析并不一致，但本质相同）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 300005using namespace std;int sum[maxn &lt;&lt; 1];int minnum[maxn &lt;&lt; 1];int qx, qy, qd;void insert(int l, int r, int o)&#123; if (l == r)&#123; sum[o] += qd; minnum[o] += qd; return ; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) insert(l, mid, o &lt;&lt; 1); else insert(mid + 1, r, o &lt;&lt; 1 | 1); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; minnum[o] = min(minnum[o &lt;&lt; 1], sum[o &lt;&lt; 1] + minnum[o &lt;&lt; 1 | 1]);&#125;int a[maxn];int b[maxn];int c[maxn];int n, m, h;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;h); for (int i = 1; i &lt;= m; i++) scanf("%d", &amp;b[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= m; i++) b[i] = h - b[i]; for (int i = 1; i &lt;= m; i++) c[i] = b[i]; for (int i = 1; i &lt;= n; i++) c[i + m] = a[i]; sort(c + 1, c + 1 + n + m); int k = unique(c + 1, c + 1 + n + m) - c; for (int i = 1; i &lt;= m; i++) b[i] = lower_bound(c + 1, c + 1 + k, b[i]) - c; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(c + 1, c + 1 + k, a[i]) - c; for (int i = 1; i &lt;= m; i++)&#123; qx = b[i], qd = 1; insert(1, k, 1); qx = a[i], qd = -1; insert(1, k, 1); &#125; int ans = 0; ans += (minnum[1] &gt;= 0); for (int i = m + 1; i &lt;= n; i++)&#123; qx = a[i - m] , qd = 1; insert(1, k, 1); qx = a[i], qd = -1; insert(1, k, 1); ans += (minnum[1] &gt;= 0); &#125; printf("%d", ans); return 0;&#125; #6075. 「2017 山东一轮集训 Day6」重建 题目分析根据题意，我们显然是要先求出经过不同边数下，每种边数的对应的最短路（关键点和全部点分别求），我们这样就可以枚举经过的边数，钦定它为真正的最短路，然后求出c的对应范围（在两个点集中）并判断是否有解即可，其实还是很巧妙的 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 100005#define LL long long int#define LD long double #define eps 1e-9using namespace std;struct edge&#123; int next, to; LL cost; edge(int next, int to, LL cost) : next(next), to(to), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, LL cost)&#123; e[++cnt] = edge(h[fr], to, cost); h[fr] = cnt; e[++cnt] = edge(h[to], fr, cost); h[to] = cnt;&#125;int n, m, s, t, k;int save[maxn];int ct;LL d1[maxn][2];LL d2[maxn][2];int d = 0;LL INF;void init()&#123; INF = 1; for (int i = 0; i &lt; 18; i++) INF = 10 * INF; for (int i = 1; i &lt;= n; i++) d1[i][0] = d1[i][1] = d2[i][0] = d2[i][1] = INF; d1[s][0] = d1[s][1] = d2[s][0] = d2[s][1] = 0;&#125;void update()&#123; for (int i = 1; i &lt;= n; i++) d1[i][d ^ 1] = INF; for (int i = 1; i &lt;= ct; i++) d2[save[i]][d ^ 1] = INF; for (int i = 1; i &lt;= n; i++)&#123; for (int j = h[i]; j; j = e[j].next)&#123; int op = e[j].to; if (d1[op][d ^ 1] &gt; d1[i][d] + e[j].cost) d1[op][d ^ 1] = d1[i][d] + e[j].cost; &#125; &#125; for (int i = 1; i &lt;= ct; i++)&#123; for (int j = h[save[i]]; j; j = e[j].next)&#123; int op = e[j].to; if (d2[op][d ^ 1] &gt; d2[save[i]][d] + e[j].cost) d2[op][d ^ 1] = d2[save[i]][d] + e[j].cost; &#125; &#125; d ^= 1;&#125;LL inf[maxn][2];void work()&#123; init(); for (int i = 1; i &lt;= n; i++)&#123; update(); inf[i][0] = (d1[t][d] &lt; INF) ? d1[t][d] : -1; inf[i][1] = (d2[t][d] &lt; INF) ? d2[t][d] : -1; &#125; bool f = 0; LD ans = -1; for (int i = 1; i &lt; n; i++)&#123; if (inf[i][0] == -1) continue; if (!f)&#123; if (inf[i][0] == inf[i][1])&#123; printf("Infinity\n"); return; &#125; &#125; f = 1; if (inf[i][1] == -1 || inf[i][0] != inf[i][1]) continue; LD minnum = -INF; LD maxnum = INF; for (int j = 1; j &lt; i; j++)&#123; if (inf[j][0] == -1) continue; maxnum = min(maxnum, (LD)(inf[j][0] - inf[i][1]) / (i - j)); &#125; for (int j = i + 1; j &lt;= n; j++)&#123; if (inf[j][0] == -1) continue; minnum = max(minnum, (LD)(inf[j][0] - inf[i][1]) / (i - j)); &#125; if (minnum - maxnum &gt; eps) continue; ans = max(ans, maxnum); &#125; if (ans + 1 &lt; eps) printf("Impossible\n"); else printf("%lld\n", (LL)ans);&#125;void recover()&#123; ct = 0; cnt = 1; memset(h, 0, sizeof(h));&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); int x, y; LL z; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%lld", &amp;x, &amp;y, &amp;z); Add_Edge(x, y, z); &#125; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++)&#123; scanf("%d", &amp;x); save[++ct] = x; &#125; work(); recover(); &#125; return 0;&#125; #6136. 「2017 山东三轮集训 Day4」Left 题目分析我们考虑对这道题递归和分解，使得我们每次只去分析一个小过程，这样就会简便很多，我们可以观察规律，发现 $n$阶网络最后每两组中的数($k∗ 2,k∗2+1$)一定不在$n-1$阶网络的同一侧 ，这样我们可以对每层$O(2^n)$进行处理，同时使用贪心法 ，如果当前的这个组没被标记（即是否已经决定开或关），就让它关着，然后用自身的状态以及网络特征，尽可能多的更新其他的组，可以证明这样做是完全正确的，把两个排列放在一起（置换），用2-SAT的思路进行连边，同时每两组内的数($k∗2, k∗2+1$)也连边，根据题目性质，只能形成偶环，无论怎么染色都不会矛盾（即无解），所以，我们对每一层都进行这样的处理，同时更新上下的序列，就可以在$O(T∗n∗2^n)$的复杂度内解决本题，而这是完全可以接受的 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 13using namespace std;int up[1 &lt;&lt; maxn];int low[1 &lt;&lt; maxn];int ori[1 &lt;&lt; maxn];int line[1 &lt;&lt; maxn];int ans[(maxn &lt;&lt; 1) - 1][1 &lt;&lt; maxn];bool vis[(maxn &lt;&lt; 1) - 1][1 &lt;&lt; maxn];int temp[1 &lt;&lt; maxn];int judge[1 &lt;&lt; maxn];int n, x, con, con2; //con = n - 1 - (x - 1);void BFS(int j)&#123; int side = line[j ^ 1]; int _j = up[side]; if (vis[con][_j &gt;&gt; 1]) return; vis[con][_j &gt;&gt; 1] = 1; ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ ((line[j] &amp; (1 &lt;&lt; con)) &gt;&gt; con) ^ ((line[j ^ 1] &amp; (1 &lt;&lt; con)) &gt;&gt; con) ^ 1;//WA的原因，原先的写法如下： //ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ (line[j] &amp; 1) ^ (line[j ^ 1] &amp; 1) ^ 1; //中间测试时是这样写的： //ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ (line[j] &amp; (1 &lt;&lt; con)) ^ (line[j ^ 1] &amp; (1 &lt;&lt; con)) ^ 1; BFS(low[ori[_j ^ 1]]);&#125;/*void BFS2(int j)&#123; int side = ori[j ^ 1]; int _j = low[side]; if (vis[con2][_j &gt;&gt; 1]) return; vis[con2][_j &gt;&gt; 1] = 1; ans[con2][_j &gt;&gt; 1] = ans[con2][j &gt;&gt; 1] ^ 1; BFS2(j ^ 1);&#125;*//*int shift_left(int n, int x)&#123; int a = n &amp; ((1 &lt;&lt; x) - 1); int b = n - a; a = (a &lt;&lt; 1) | (a &gt;&gt; (x - 1)) &amp; ((1 &lt;&lt; x) - 1); return a | b;&#125;*/int shift_right(int n, int x)&#123; int a = n &amp; ((1 &lt;&lt; x) - 1); int b = n - a; a = (a &gt;&gt; 1) | (a &lt;&lt; (x - 1)) &amp; ((1 &lt;&lt; x) - 1); return a | b;&#125;void solve()&#123; if (x == 1)&#123; for (int i = 0; i &lt; (1 &lt;&lt; n); i += 2)&#123; ans[con][i &gt;&gt; 1] = 1 ^ (line[i] == ori[i]); &#125; return; &#125; for(int i = 0; i &lt; (1 &lt;&lt; n); i += 1 &lt;&lt; x)&#123; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) low[line[j]] = j; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) up[ori[j]] = j; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (!vis[con][j &gt;&gt; 1])&#123; vis[con][j &gt;&gt; 1] = 1; ans[con][j &gt;&gt; 1] = 0; BFS(low[ori[j]]), BFS(low[ori[j + 1]]); &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (ans[con][j &gt;&gt; 1])&#123; temp[shift_right(j, x)] = ori[j ^ 1]; judge[ori[j ^ 1]] = 0; temp[shift_right(j ^ 1, x)] = ori[j]; judge[ori[j]] = 1; &#125; else&#123; temp[shift_right(j, x)] = ori[j]; judge[ori[j]] = 0; temp[shift_right(j ^ 1, x)] = ori[j ^ 1]; judge[ori[j ^ 1]] = 1; &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) ori[j] = temp[j]; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2) ans[con2][j &gt;&gt; 1] = judge[line[j]]; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (ans[con2][j &gt;&gt; 1])&#123; temp[shift_right(j, x)] = line[j ^ 1]; temp[shift_right(j ^ 1, x)] = line[j]; &#125; else&#123; temp[shift_right(j, x)] = line[j]; temp[shift_right(j ^ 1, x)] = line[j ^ 1]; &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) line[j] = temp[j]; /*for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (!vis[con2][j &gt;&gt; 1])&#123; vis[con2][j &gt;&gt; 1] = 1; ans[con2][j &gt;&gt; 1] = 0; BFS2(up[line[j]]), BFS2(up[line[j + 1]]); &#125; &#125; */ &#125; x--; con++; con2--; solve();&#125;int main()&#123; while (scanf("%d", &amp;n) == 1 &amp;&amp; n != 0)&#123; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) scanf("%d", &amp;line[i]); for (int i = 0; i &lt; 1 &lt;&lt; n; i++) ori[i] = i; con = 0; con2 = (n - 1) &lt;&lt; 1; x = n; solve(); for (int i = 0; i &lt; (n &lt;&lt; 1) - 1; i++)&#123; for (int j = 0; j &lt; 1 &lt;&lt; (n - 1); j++)&#123; printf("%d", ans[i][j]); &#125; printf("\n"); &#125; printf("\n"); memset(vis, 0, sizeof(vis)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用图表汇总]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%B8%B8%E7%94%A8%E5%9B%BE%E8%A1%A8%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[引言存放以前编写的图表汇总，便于查找 常用图表大全 首先，作为搞OI的一员，我们怎么可能会不知道大名鼎鼎的ASCII码呢？然而我就是有很多都不知道。另外普及一下，ASCII=American Standard Code for Information Interchange 下表中前32个（0~31）为控制字符，第33个（32）为空格，第128个（127）为DEL（delete） 大家不妨在看表前思考两个问题： 怎么在markdown中打出下表，是手打吗？ 怎么在markdown表格中打出‘|’（逻辑或）这个字符 怎么在markdown表格中打空格？ 第一个问题显然是要编程序啦。。。 第二个问题如果不明白可以看这个：用Markdown写Hexo博客时如何转义竖杠 | ? - 知乎 第三个还是要参考知乎啦：在Markdown 语言中,如何实现段首空格的显示 ? - 知乎 我想会有明白我在说什么的人 ASCII码表（十进制） ASCII码 字符 ASCII码 字符 0 ^@ 64 @ 1 ^A 65 A 2 ^B 66 B 3 ^C 67 C 4 ^D 68 D 5 ^E 69 E 6 ^F 70 F 7 ^G 71 G 8 ^H 72 H 9 ^I 73 I 10 ^J 74 J 11 ^K 75 K 12 ^L 76 L 13 ^M 77 M 14 ^N 78 N 15 ^O 79 O 16 ^P 80 P 17 ^Q 81 Q 18 ^R 82 R 19 ^S 83 S 20 ^T 84 T 21 ^U 85 U 22 ^V 86 V 23 ^W 87 W 24 ^X 88 X 25 ^Y 89 Y 26 ^Z 90 Z 27 ^[ 91 [ 28 ^\ 92 \ 29 ^] 93 ] 30 ^^ 94 ^ 31 ^_ 95 _ 32 96 ` 33 ! 97 a 34 “ 98 b 35 # 99 c 36 $ 100 d 37 % 101 e 38 &amp; 102 f 39 ‘ 103 g 40 ( 104 h 41 ) 105 i 42 * 106 j 43 + 107 k 44 , 108 l 45 - 109 m 46 . 110 n 47 / 111 o 48 0 112 p 49 1 113 q 50 2 114 r 51 3 115 s 52 4 116 t 53 5 117 u 54 6 118 v 55 7 119 w 56 8 120 x 57 9 121 y 58 : 122 z 59 ; 123 { 60 &lt; 124 \ 61 = 125 } 62 &gt; 126 ~ 63 ? 127  下面就是OI界的常用工具，注意是优先级越高的运算符越先结合，此处越高的含义指的是表中的位置越高（即优先级序号越小） 运算符优先级表 优先级 运算符 结合性 1 ()&nbsp;&nbsp;[] 从左到右 2 ! &nbsp;&nbsp;+（正）&nbsp;&nbsp;-（负）&nbsp;&nbsp; ~&nbsp;&nbsp; ++&nbsp;&nbsp; - - &nbsp;&nbsp; 从右到左 3 *&nbsp;&nbsp; / &nbsp;&nbsp;% 从左到右 4 +（加）&nbsp;&nbsp; -（减） 从左到右 5 &lt;&lt;&nbsp;&nbsp; &gt;&gt; &nbsp;&nbsp;&gt;&gt;&gt; 从左到右 6 &lt; &nbsp;&nbsp;&lt;= &nbsp;&nbsp;&gt;=&nbsp;&nbsp; instanceof 从左到右 7 == &nbsp;&nbsp; != 从左到右 8 &amp; 从左到右 9 ^ 从左到右 10 &#124; 从左到右 11 &amp;&amp; 从左到右 12 &#124;&#124; 从左到右 13 ?&nbsp;&nbsp;: 从右到左 14 =&nbsp;&nbsp; += &nbsp;&nbsp;-= &nbsp;&nbsp;*=&nbsp;&nbsp; /= &nbsp;&nbsp;%= &nbsp;&nbsp;&amp;= &nbsp;&nbsp;&#124;=&nbsp;&nbsp; ^= &nbsp;&nbsp; ~=&nbsp;&nbsp; &lt;&lt;= &nbsp;&nbsp;&gt;&gt;=&nbsp;&nbsp; &gt;&gt;&gt;= 从右到左]]></content>
      <tags>
        <tag>图表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libre Online Judge模板库]]></title>
    <url>%2F2017%2F08%2F29%2FLibre-Online-Judge%E6%A8%A1%E6%9D%BF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[引言储存一些代码模板 并查集12345678910111213141516171819202122232425#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define M 998244353#define maxn 4000005#define LL long long intusing namespace std;int ufs[maxn];int n, m;inline int find_root(int x)&#123; return ufs[x] = (ufs[x] == x) ? x : find_root(ufs[x]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int op, x, y; for (int i = 1; i &lt;= n; i++) ufs[i] = i; LL ans = 0; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 0) ufs[find_root(x)] = find_root(y); else ans = ((ans &lt;&lt; 1) % M + (find_root(x) == find_root(y))) % M; &#125; printf("%lld", ans); return 0;&#125; 乘法逆元123456789101112131415161718192021#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 3000005#define LL long long intusing namespace std;LL inv[maxn];LL n, p;void work()&#123; inv[1] = 1; printf("1\n"); for (int i = 2; i &lt;= n; i++)&#123; inv[i] = (p - (p / i) * inv[p % i] % p) % p; printf("%lld\n", inv[i]); &#125;&#125;int main()&#123; scanf("%lld%lld", &amp;n, &amp;p); work(); return 0;&#125; 最大异或和1234567891011121314151617181920212223242526272829#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 55#define LL long long intusing namespace std;LL line[maxn];int n;void work()&#123; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (j == i || line[i] ^ line[j] &gt; line[j]) continue; line[j] ^= line[i]; &#125; &#125; LL ans = 0; for (int i = 0; i &lt; n; i++) ans ^= line[i]; printf("%lld", ans);&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%lld", &amp;line[i]); &#125; sort(line, line + n); reverse(line, line + n); work(); return 0;&#125; 子串查找(KMP)123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 1000005using namespace std;int f[maxn];char t[maxn];int lent;char s[maxn];int lens;void init()&#123; for (int i = 1; i &lt; lent; i++)&#123; int k = f[i]; while (k &amp;&amp; t[k] != t[i]) k = f[k]; f[i + 1] = (t[k] == t[i]) ? k + 1 : 0; &#125;&#125;void work()&#123; int now = 0; int ans = 0; for (int i = 0; i &lt; lens; i++)&#123; while (now &amp;&amp; s[i] != t[now]) now = f[now]; if (s[i] == t[now]) now++; if (now == lent) ans++, now = f[now]; &#125; printf("%d", ans);&#125;int main()&#123; scanf("%s%s", s, t); lent = strlen(t); lens = strlen(s); init(); work(); return 0;&#125; 普通平衡树(Treap)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2000000005#define maxn 1000005using namespace std;struct node&#123; node* ch[2]; int val, num, size, p; void maintain()&#123; size = 0; size += (ch[0] == NULL) ? 0 : ch[0] -&gt; size; size += (ch[1] == NULL) ? 0 : ch[1] -&gt; size; size += num; &#125; int cmp(int _val)&#123; if (_val == val) return -1; return val &lt; _val; &#125; int find_pre(int x)&#123; int d = cmp(x); if (d == 0 || d == -1) return (ch[0] == NULL) ? -INF : ch[0] -&gt; find_pre(x); else return max(val, (ch[1] == NULL) ? -INF : ch[1] -&gt; find_pre(x)); &#125; int find_suf(int x)&#123; int d = cmp(x); if (d == 1 || d == -1) return (ch[1] == NULL) ? INF : ch[1] -&gt; find_suf(x); else return min(val, (ch[0] == NULL) ? INF : ch[0] -&gt; find_suf(x)); &#125; node (int val, int num, int p) : val(val), num(num), p(p), size(1)&#123;ch[0] = ch[1] = NULL;&#125; node()&#123;&#125;&#125;;node* root;bool vis[maxn];int Rand()&#123; int p = rand() % maxn; while (vis[p]) p = rand() % maxn; vis[p] = 1; return p;&#125;void rotate(node*&amp; o, int d)&#123; node* k = o -&gt; ch[d]; o -&gt; ch[d] = k -&gt; ch[d ^ 1]; k -&gt; ch[d ^ 1] = o; k -&gt; maintain(); o -&gt; maintain(); o = k;&#125;void insert(node*&amp; now, int x)&#123; if (now == NULL) now = new node(x, 1, Rand()); else if (now -&gt; val == x) now -&gt; num++; else &#123; int d = now -&gt; cmp(x); insert(now -&gt; ch[d], x); if (now -&gt; ch[d] -&gt; p &gt; now -&gt; p) rotate(now, d); &#125; now -&gt; maintain();&#125;void remove(node*&amp; now, int x)&#123; if (now == NULL) return; else if (now -&gt; val == x)&#123; if (now -&gt; num == 1)&#123; if (now -&gt; ch[0] == NULL &amp;&amp; now -&gt; ch[1] == NULL)&#123; now = NULL; return; &#125; int d = ((now -&gt; ch[0] == NULL) ? -INF : now -&gt; ch[0] -&gt; p) &lt; ((now -&gt; ch[1] == NULL) ? -INF : now -&gt; ch[1] -&gt; p); rotate(now, d); remove(now -&gt; ch[d ^ 1], x); &#125; else now -&gt; num--; &#125; else remove(now -&gt; ch[now -&gt; cmp(x)], x); now -&gt; maintain();&#125;int get_rank(node* now, int x)&#123; int ans; if (now == NULL) return -INF; int d = now -&gt; cmp(x); if (d == -1) ans = 1 + ((now -&gt; ch[0] == NULL) ? 0 : now -&gt; ch[0] -&gt; size); else if (d == 0) ans = get_rank(now -&gt; ch[0], x); else ans = now -&gt; num + get_rank(now -&gt; ch[1], x) + ((now -&gt; ch[0] == NULL) ? 0 : now -&gt; ch[0] -&gt; size); return ans;&#125;int find_by_rank(node* now, int x)&#123; if (now == NULL) return -INF; int l = (now -&gt; ch[0] == NULL) ? 0 : now -&gt; ch[0] -&gt; size; if (x &gt; l &amp;&amp; x &lt;= l + now -&gt; num) return now -&gt; val; else if (x &lt;= l) return find_by_rank(now -&gt; ch[0], x); else return find_by_rank(now -&gt; ch[1], x - l - now -&gt; num);&#125;int get_pre(int x)&#123; return root -&gt; find_pre(x);&#125;int get_suf(int x)&#123; return root -&gt; find_suf(x);&#125;int main()&#123; int n, x, op; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;op); switch(op)&#123; case 1:&#123; scanf("%d", &amp;x); insert(root, x); break; &#125; case 2:&#123; scanf("%d", &amp;x); remove(root, x); break; &#125; case 3:&#123; scanf("%d", &amp;x); printf("%d\n", get_rank(root, x)); break; &#125; case 4:&#123; scanf("%d", &amp;x); printf("%d\n", find_by_rank(root, x)); break; &#125; case 5:&#123; scanf("%d", &amp;x); printf("%d\n", get_pre(x)); break; &#125; case 6:&#123; scanf("%d", &amp;x); printf("%d\n", get_suf(x)); break; &#125; &#125; &#125; return 0;&#125; 最小费用流(MCMF)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define INF 2000000005#define maxn 405#define maxm 15005using namespace std;struct edge&#123; int next, to, flow, cost; edge(int next, int to, int flow, int cost) : next(next), to(to), flow(flow), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], n, m, cnt = 1;void Add_Edge(int fr, int to, int flow, int cost)&#123; e[++cnt] = edge(h[fr], to, flow, cost); h[fr] = cnt; e[++cnt] = edge(h[to], fr, 0, -cost); h[to] = cnt;&#125;int d[maxn], p[maxn], s, t;bool vis[maxn];bool SPFA()&#123; queue&lt;int&gt; spfa; for (int i = s; i &lt;= t; i++) d[i] = INF; d[s] = 0; spfa.push(s); vis[s] = 1; while (!spfa.empty())&#123; int op = spfa.front(); spfa.pop(); for (int i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int k = e[i].to; if (d[k] &gt; d[op] + e[i].cost)&#123; p[k] = i; d[k] = d[op] + e[i].cost; if (!vis[k])&#123; vis[k] = 1; spfa.push(k); &#125; &#125; &#125; vis[op] = 0; &#125; if (d[t] &gt;= INF) return false; return true;&#125;void Augment(int&amp; maxflow, int&amp; mincost)&#123; int now = t, flow = INF; while (now != s)&#123; int k = p[now]; flow = min(flow, e[k].flow); now = e[k ^ 1]. to; &#125; now = t; while (now != s)&#123; int k = p[now]; e[k].flow -= flow; e[k ^ 1].flow += flow; now = e[k ^ 1].to; &#125; maxflow += flow, mincost += (d[t] - d[s]) * flow;&#125;void MCMF(int&amp; maxflow, int&amp; mincost)&#123; while(SPFA()) Augment(maxflow, mincost);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int x, y, f, c; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;f, &amp;c); Add_Edge(x, y, f, c); &#125; int maxflow = 0; int mincost = 0; s = 1, t = n; MCMF(maxflow, mincost); printf("%d %d", maxflow, mincost); return 0;&#125; 维护全序集(Treap)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 3000005#define INF 2000000005using namespace std;struct node&#123; node* ch[2]; int val, num, p, size; int cmp(int _val)&#123; if (val == _val) return -1; return _val &gt; val; &#125; void maintain()&#123; size = 0; size += (ch[0] == NULL) ? 0 : ch[0] -&gt; size; size += (ch[1] == NULL) ? 0 : ch[1] -&gt; size; size += num; &#125; int find_pre(int x)&#123; int d = cmp(x); if (d &lt;= 0) return (ch[0] == NULL) ? -INF : ch[0] -&gt; find_pre(x); else return max(val, (ch[1] == NULL) ? -INF : ch[1] -&gt; find_pre(x)); &#125; int find_suf(int x)&#123; int d = cmp(x); if (d == 1 || d == -1) return (ch[1] == NULL) ? INF : ch[1] -&gt; find_suf(x); else return min(val, (ch[0] == NULL) ? INF : ch[0] -&gt; find_suf(x)); &#125; node(int val, int num, int p, int size) : val(val), num(num), p(p), size(size)&#123;ch[0] = ch[1] = NULL;&#125; node()&#123;&#125;&#125;;void rotate(node*&amp; now, int d)&#123; node* k = now -&gt; ch[d]; now -&gt; ch[d] = k -&gt; ch[d ^ 1]; k -&gt; ch[d ^ 1] = now; k -&gt; maintain(); now -&gt; maintain(); now = k;&#125;bool vis[maxn];int Rand()&#123; int p = rand() % maxn; while (vis[p]) p = rand() % maxn; vis[p] = 1; return p;&#125;node* root;void insert(node*&amp; now, int x)&#123; if (now == NULL) now = new node (x, 1, Rand(), 1); else if (now -&gt; val == x) now -&gt; num++; else &#123; int d = now -&gt; cmp(x); insert(now -&gt; ch[d], x); if (now -&gt; ch[d] -&gt; p &gt; now -&gt; p) rotate(now, d); &#125; now -&gt; maintain();&#125;void remove(node*&amp; now, int x)&#123; if (now == NULL) return; else if (now -&gt; val == x)&#123; if (now -&gt; num == 1)&#123; if (now -&gt; ch[0] == NULL) now = now -&gt; ch[1]; else if(now -&gt; ch[1] == NULL) now = now -&gt; ch[0]; else &#123; int d = now -&gt; ch[0] -&gt; p &lt; now -&gt; ch[1] -&gt; p; rotate(now, d); remove(now -&gt; ch[d ^ 1], x); &#125; &#125; else now -&gt; num--; &#125; else remove(now -&gt; ch[now -&gt; cmp(x)], x); if (now != NULL) now -&gt; maintain();&#125;int find_by_rank(node*&amp; now, int x)&#123; if (now == NULL) return -INF; int l = (now -&gt; ch[0] == NULL) ? 0 : now -&gt; ch[0] -&gt; size; if (x &gt; l &amp;&amp; x &lt;= l + now -&gt; num) return now -&gt; val; else if (x &lt;= l) return find_by_rank(now -&gt; ch[0], x); else return find_by_rank(now -&gt; ch[1], x - l - now -&gt; num);&#125;int get_rank(node*&amp; now, int x)&#123; if (now == NULL) return 0; int d = now -&gt; cmp(x); int l = (now -&gt; ch[0] == NULL) ? 0 : now -&gt; ch[0] -&gt; size; if (d == -1) return l; else if (d == 1) return now -&gt; num + l + get_rank(now -&gt; ch[1], x); else return get_rank(now -&gt; ch[0], x);&#125;int get_pre(int x)&#123; int k = root -&gt; find_pre(x); if (k == -INF) return -1; return k;&#125;int get_suf(int x)&#123; int k = root -&gt; find_suf(x); if (k == INF) return -1; return k;&#125;int main()&#123; int n, x, op; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;op); switch(op)&#123; case 0:&#123; scanf("%d", &amp;x); insert(root, x); break; &#125; case 1:&#123; scanf("%d", &amp;x); remove(root, x); break; &#125; case 2:&#123; scanf("%d", &amp;x); printf("%d\n", find_by_rank(root, x)); break; &#125; case 3:&#123; scanf("%d", &amp;x); printf("%d\n", get_rank(root, x)); break; &#125; case 4:&#123; scanf("%d", &amp;x); printf("%d\n", get_pre(x)); break; &#125; case 5:&#123; scanf("%d", &amp;x); printf("%d\n", get_suf(x)); break; &#125; &#125; &#125; return 0;&#125; 最大流(ISAP)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 4000005#define maxn2 1000005#define INF 2000000005#define LL long long intusing namespace std;struct edge&#123; int next, to; LL flow; edge(int next, int to, LL flow) : next(next), to(to), flow(flow)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn2], cnt = 1;void Add_Edge(int x, int y, LL z)&#123; e[++cnt] = edge(h[x], y, z); h[x] = cnt; e[++cnt] = edge(h[y], x, 0); h[y] = cnt;&#125;int d[maxn2], p[maxn2], cur[maxn2], num[maxn2];int n, m, s, t;bool vis[maxn2]; void Augment(LL&amp; maxflow)&#123; int now = t; LL flow = (LL)INF * INF; while (now != s)&#123; int k = p[now]; flow = min(flow, e[k].flow); now = e[k ^ 1].to; &#125; now = t; while (now != s)&#123; int k = p[now]; e[k].flow -= flow; e[k ^ 1].flow += flow; now = e[k ^ 1].to; &#125; maxflow += flow;&#125;bool BFS()&#123; for (int i = 1; i &lt;= n; i++) d[i] = INF; queue&lt;int&gt; bfs; bfs.push(t); vis[t] = 1; d[t] = 0; while (!bfs.empty())&#123; int op = bfs.front();bfs.pop(); for (int i = h[op]; i; i = e[i].next)&#123; if (e[i].flow) continue; int k = e[i].to; if (vis[k]) continue; vis[k] = 1; d[k] = d[op] + 1; bfs.push(k); &#125; &#125; if (d[s] &gt;= INF) return false; return true;&#125;void ISAP()&#123; if(!BFS())&#123; printf("0"); return; &#125; for (int i = 1; i &lt;= n; i++) if(d[i] &gt;= INF) continue; else num[d[i]]++, cur[i] = h[i]; LL maxflow = 0; int u = s; while (d[s] &lt; n)&#123; bool if_work = 0; if (u == t)&#123; Augment(maxflow); u = s; &#125; for (int i = cur[u]; i; i = e[i].next)&#123; if(!e[i].flow) continue; int k = e[i].to; if (d[u] - 1 == d[k])&#123; cur[u] = i; u = k; if_work = 1; p[u] = i; break; &#125; &#125; if (!if_work)&#123; int minnum = n - 1; for (int i = h[u]; i; i = e[i].next)&#123; if (!e[i].flow) continue; minnum = min(minnum, d[e[i].to]); &#125; num[d[u]]--; if (num[d[u]] == 0)&#123; printf("%lld", maxflow); return; &#125; d[u] = minnum + 1; cur[u] = h[u]; num[d[u]]++; if (u != s) u = e[p[u] ^ 1].to; &#125; &#125; printf("%lld", maxflow);&#125;int main()&#123; int x, y; LL z; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%lld", &amp;x, &amp;y, &amp;z); Add_Edge(x, y, z); &#125; ISAP(); return 0;&#125; 多项式乘法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define pi 3.141592653589793#define maxn 1000005using namespace std;typedef struct complex&#123; double r, i; complex(double r, double i) : r(r), i(i)&#123;&#125; complex()&#123;&#125;&#125;com;com operator + (com a, com b)&#123; return com(a.r + b.r, a.i + b.i);&#125;com operator - (com a, com b)&#123; return com(a.r - b.r, a.i - b.i);&#125;com operator * (com a, com b)&#123; return com(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);&#125;com operator / (com a, int k)&#123; return com(a.r / k, a.i / k);&#125;com ex(double x)&#123; return com(cos(x), sin(x));&#125;int rev[maxn];void init(int bit)&#123; for (int i = 0; i &lt; (1 &lt;&lt; bit); i++)&#123; rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; (bit - 1)); &#125;&#125;void FFT(com* a, int n, int dft)&#123; for (int i = 0; i &lt; n; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int step = 1; step &lt; n; step &lt;&lt;= 1)&#123; com wn = ex(pi * dft / step); for (int j = 0; j &lt; n; j += (step &lt;&lt; 1))&#123; com wnk = com(1, 0); for (int i = j; i &lt; j + step; i++)&#123; com x = a[i]; com y = a[i + step] * wnk; a[i] = x + y; a[i + step] = x - y; wnk = wnk * wn; &#125; &#125; &#125; if (dft == -1) for (int i = 0; i &lt; n; i++) a[i] = a[i] / n;&#125;int n, m;int s[maxn];int t[maxn];com a[maxn];com b[maxn];int ans[maxn];int main()&#123; freopen("mul.in", "r", stdin); freopen("mul.out", "w", stdout); scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;s[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;t[i]); for (int i = 0; i &lt;= n; i++) a[i] = com(s[i], 0); for (int i = 0; i &lt;= m; i++) b[i] = com(t[i], 0); int len = n + m + 2; int si = 0; while (len)&#123; len &gt;&gt;= 1; si++; &#125; init(si); len = (1 &lt;&lt; si); FFT(a, len, 1); FFT(b, len, 1); for (int i = 0; i &lt; len; i++) a[i] = a[i] * b[i]; FFT(a, len, -1); for (int i = 0; i &lt; len; i++) ans[i] = (int) (a[i].r + 0.5); for (int i = 0; i &lt; n + m + 1; i++) printf("%d ", ans[i]); return 0;&#125; 后缀排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define maxn 2000005using namespace std;int n, m;char s[maxn];int t1[maxn];int t2[maxn];int sa[maxn];int cnt[maxn];int rank[maxn];int height[maxn];void build()&#123; int *x = t1, *y = t2; m = 62; for (int i = 0; i &lt; n; i++) cnt[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) cnt[i] += cnt[i - 1]; for (int i = n - 1; i &gt;= 0; i--) sa[--cnt[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1)&#123; int p = 0; for (int i = n - 1; i &gt;= n - k; i--) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; memset(cnt, 0, sizeof(cnt)); for (int i = 0; i &lt; p; i++) cnt[x[y[i]]]++; for (int i = 1; i &lt; m; i++) cnt[i] += cnt[i - 1]; for (int i = p - 1; i &gt;= 0; i--) sa[--cnt[x[y[i]]]] = y[i]; p = 0; swap(x, y); for (int i = 0; i &lt; n; i++)&#123; x[sa[i]] = (!i || y[sa[i]] != y[sa[i - 1]] || y[sa[i] + k] != y[sa[i - 1] + k]) ? p++ : p - 1; &#125; m = p; if (m &gt;= n) break; &#125; for (int i = 0; i &lt; n; i++) rank[sa[i]] = i; int h = 0; for (int i = 0; i &lt; n; i++)&#123; if (h) h--; if (rank[i] == 0) continue; int j = sa[rank[i] - 1]; while (s[i + h] == s[j + h]) h++; height[rank[i]] = h; &#125;&#125;int main()&#123; freopen("Suffix.in", "r", stdin); freopen("Suffix.out", "w", stdout); scanf("%s", s); n = strlen(s); for (int i = 0; i &lt; n; i++)&#123; if (isdigit(s[i])) s[i] = s[i] - '0'; else if (isupper(s[i])) s[i] = s[i] - 'A' + 10; else if (islower(s[i])) s[i] = s[i] - 'a' + 36; &#125; build(); for (int i = 0; i &lt; n; i++) printf("%d ", sa[i] + 1); return 0;&#125; 矩阵乘法123456789101112131415161718192021222324252627282930#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 505#define M 1000000007#define LL long long intusing namespace std;LL a[maxn][maxn];LL b[maxn][maxn];LL c[maxn][maxn];int n, m, p;int main()&#123; scanf("%d%d%d", &amp;n, &amp;p, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; p; j++) scanf("%lld", &amp;a[i][j]), a[i][j] = (a[i][j] + M) % M; for (int i = 0; i &lt; p; i++) for (int j = 0; j &lt; m; j++) scanf("%lld", &amp;b[i][j]), b[i][j] = (b[i][j] + M) % M; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; p; k++) c[i][j] = (c[i][j] + a[i][k] * b[k][j] % M) % M; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) printf("%lld ", c[i][j]); printf("\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>zkw费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libre Online Judge阶段性汇总I]]></title>
    <url>%2F2017%2F08%2F29%2FLibre-Online-Judge%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBI%2F</url>
    <content type="text"><![CDATA[引言最近也开始总结LOJ的题目啦，以前一道题一篇题解太傻了，但是以前的就那样吧，现在开始每十题一篇题解 首篇说明为了方便，以后的题目显示采用iframe框架 #507. 「LibreOJ NOI Round #1」接竹竿 题目分析其实我们可以发现，对于这种序列DP的问题，大部分其实都是可以单调队列优化的，我们考虑对比两种可行的方案，然后进行一些数学推导，往往可以得到一些单调队列形式的公式，这样就可以使用单调队列完美地解决这样的问题了 本题也不例外，但是前提是本题需要抽象思考一下，那就是这题的牌的取出顺序不会造成什么影响，我们可以发现，如果我们先取出了一些，后来又取了一些，那么后面取的要么可以完全包含前面取的那些牌，要么与上次不相交，所以本题就可以使用单调队列进行优化然后解决了，单调队列层面上，就是列一列公式，对每种花色开一个单调队列，然后套用单调队列模板化代码即可（详见BZOJ题解） 然而实际上，经过分析以后，本题可以不使用单调队列这种方法，因为DP计算公式中与决策有关的项是与当前要求的状态没有任何关联的，这样我们只要采用打擂台的方法，维护一个最大值即可 这也就说明，单调队列优化的DP的出现，是为了解决与决策与当前状态有关联时的DP问题，而如果没有关联则不需要这种方法 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define LL long long intusing namespace std;int c[maxn];int v[maxn];LL pre[maxn];int n, k;struct point&#123; int x; LL y; point(int x, LL y) : x(x), y(y)&#123;&#125; point()&#123;&#125;&#125;;point save[maxn];bool vis[maxn];LL dp[maxn];int main()&#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;c[i]); &#125; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;v[i]); pre[i] = pre[i - 1] + v[i]; &#125; for (int i = 1; i &lt;= n; i++)&#123; dp[i] = dp[i - 1]; if (!vis[c[i]])&#123; vis[c[i]] = 1; save[c[i]] = point(i - 1, dp[i - 1]); continue; &#125; dp[i] = max(dp[i], save[c[i]].y + pre[i] - pre[save[c[i]].x]); if (dp[i - 1] - save[c[i]].y &gt; pre[i - 1] - pre[save[c[i]].x]) save[c[i]] = point(i - 1, dp[i - 1]); &#125; printf("%lld", dp[n]); return 0;&#125; #514. 「LibreOJ β Round #2」模拟只会猜题意 题目分析本题只是暴力。。。好了就这样过了吧本题只是用来证明LOJ评测机速度的 AC代码123456789101112131415161718192021222324252627282930#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 10005#define INF 2000000005using namespace std;int line[maxn];int pre[maxn];int ans[maxn];int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int x; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;line[i]); pre[i] = pre[i - 1] + line[i]; &#125; ans[n + 1] = -INF; for (int i = n; i &gt;= 1; i--)&#123; ans[i] = ans[i + 1]; for (int j = 1; j &lt;= n - i + 1; j++)&#123; ans[i] = max(ans[i], pre[j + i - 1] - pre[j - 1]); &#125; &#125; for (int i = 0; i &lt; m; i++)&#123; scanf("%d", &amp;x); printf("%d\n", ans[x]); &#125; return 0;&#125; #516. 「LibreOJ β Round #2」DP 一般看规律 题目分析首先这种不可逆染色问题，基本都能上来就想到是并查集，然后题目要求的就是任一两个相同的颜色间的最小距离，那么我们只需要用set维护，然后启发式合并即可 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;#define maxn 300005#define INF 2147483647using namespace std;struct qu&#123; int x, y; qu(int x, int y) : x(x), y(y)&#123;&#125; qu()&#123;&#125;&#125;q[maxn];set&lt;int&gt; save[maxn];int a[maxn];int c[maxn];int tag[maxn];int n, m;void read(int&amp; x)&#123; char ch = getchar(); x = 0; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();&#125;int main()&#123; read(n), read(m); int ct = 0; for (int i = 1; i &lt;= n; i++) read(a[i]), c[ct++] = a[i]; for (int i = 0; i &lt; m; i++)&#123; read(q[i].x), read(q[i].y); c[ct++] = q[i].x, c[ct++] = q[i].y; &#125; sort(c, c + ct); ct = unique(c, c + ct) - c; for (int i = 0; i &lt; ct; i++) tag[i] = i; int ans = INF; for (int i = 1; i &lt;= n; i++)&#123; a[i] = lower_bound(c, c + ct, a[i]) - c; save[a[i]].insert(i); auto it = save[a[i]].lower_bound(i); //auto it = lower_bound(save[a[i]].begin(), save[a[i]].end(), i); if (it != save[a[i]].begin()) ans = min(ans, i - *(--it)); it = save[a[i]].upper_bound(i); //it = upper_bound(save[a[i]].begin(), save[a[i]].end(), i); if (it != save[a[i]].end()) ans = min(ans, *it - i); &#125; for (int i = 0; i &lt; m; i++)&#123; q[i].x = lower_bound(c, c + ct, q[i].x) - c, q[i].y = lower_bound(c, c + ct, q[i].y) - c; int x = q[i].x, y = q[i].y; if (x == y)&#123; printf("%d\n", ans); continue; &#125; if (save[tag[x]].size() &gt; save[tag[y]].size()) swap(tag[x], tag[y]); for (auto it = save[tag[x]].begin(); it != save[tag[x]].end(); it++)&#123; save[tag[y]].insert(*it); auto it2 = save[tag[y]].lower_bound(*it); //auto it2 = lower_bound(save[tag[y]].begin(), save[tag[y]].end(), *it); if (it2 != save[tag[y]].begin()) ans = min(ans, *it - *(--it2)); it2 = save[tag[y]].upper_bound(*it); //it2 = upper_bound(save[tag[y]].begin(), save[tag[y]].end(), *it); if (it2 != save[tag[y]].end()) ans = min(ans, *it2 - *it); &#125; save[tag[x]].clear(); printf("%d\n", ans); &#125; return 0;&#125; #524. 「LibreOJ β Round #4」游戏 题目分析首先，我们先考虑一下极端情况： n = 1的时候，显然先手会输 没有’X’的时候，显然要计算逆序对数判断输赢 然后，对于一般的情况，我们可以发现，谁控制了最后一个’X’，谁就一定会赢，为什么呢？我们不考虑之前他们做了什么，根据题目，所有数两两不同，所以，我们抽象思考，把所有数排序，每次令填的数产生一些微小的变换使之超过正好一个数，这样逆序对数一定会变化且仅变化1，这样奇偶性便改变了 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define lowbit(x) x &amp; -x#define maxn 1000005using namespace std;int n, line[maxn];int sline[maxn];int c[maxn];void add(int x, int v)&#123; while (x &lt;= n)&#123; c[x] += v; x += lowbit(x); &#125;&#125;int get(int x)&#123; int ans = 0; while (x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;int main()&#123; scanf("%d", &amp;n); if (n == 1) &#123; printf("L"); return 0; &#125; char s[15]; int sum = 0; for (int i = 1; i &lt;= n; i++)&#123; scanf("%s", s); if (s[0] == 'X') &#123; i--; n--; sum++; &#125; else &#123; if (s[0] == '-')&#123; for (int j = 1; j &lt; strlen(s); j++) line[i] = 10 * line[i] + s[j] - '0'; line[i] = -line[i]; &#125; else for (int j = 0; j &lt; strlen(s); j++) line[i] = 10 * line[i] + s[j] - '0'; &#125; &#125; if (sum != 0)&#123; if (sum &amp; 1) printf("W"); else printf("L"); &#125; else&#123; long long int sum2 = 0; for (int i = 1; i &lt;= n; i++) sline[i] = line[i]; sort(sline + 1, sline + n + 1); for (int i = 1; i &lt;= n; i++) line[i] = lower_bound(sline + 1, sline + 1 + n, line[i]) - sline; for (int i = n; i &gt;= 1; i--)&#123; add(line[i], 1); sum2 += get(line[i] - 1); &#125; if (sum2 &amp; 1) printf("W"); else printf("L"); &#125; return 0;&#125; 忘了考虑负数的读入。。。导致WA了两次 #525. 「LibreOJ β Round #4」多项式 题目分析本题长知识啊。。。 本题需要先知道一个东西：广义欧拉定理，关于其正确性，同年级数竞神犇zth,llq和wsy正在证明。。。 然后或者想到分治FFT，看了这道题终于明白这个是什么了 直接引用官方题解吧，好像想得都差不多 考虑广义欧拉定理：对于任何整数 $x$ 和 $n \geq \varphi(k)$，均有 $x^n \bmod k = x^{n \bmod \varphi(k)+\varphi(k)} \bmod k$。我们选择 $n=2\varphi(k)+1$,即有多项式 $x^n+(k-1)x^{n-\varphi(k)}$ 满足条件。只需要 $O(\sqrt{n})$ 或 $O(n)$ 或 $O(n\log{n})$ 计算 $\varphi(k)$。 此题还有一种复杂度为 $O(n\log^2(n))$ 的做法，即直接考虑多项式 $x(x−1)(x−2)(x−3)……(x−(k−1))$，明显符合条件。使用分治 + FFT 计算即可。但由于常数较大，且时限只有0.1s, 可能不能通过本题。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005using namespace std;int p[maxn];int cnt = 0;bool vis[maxn];int phi[maxn];void init()&#123; phi[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; phi[i * p[j]] = phi[i] * (p[j] - 1); if (i % p[j] == 0)&#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125;&#125;int main()&#123; int k; init(); scanf("%d", &amp;k); if (k == 1)&#123; printf("-1"); return 0; &#125; printf("%d\n", 1 + (phi[k] &lt;&lt; 1)); for (int i = 0; i &lt; phi[k] + 1; i++) printf("0 "); printf("%d ", k - 1); for (int i = phi[k] + 2; i &lt; (1 + (phi[k] &lt;&lt; 1)); i++) printf("0 "); printf("%d", 1); return 0;&#125; 注意这个是广义欧拉定理 #526. 「LibreOJ β Round #4」子集 题目分析本题的思路可以类比SDOI2016的数字配对那道题，我们可以发现本题经过图论连边转化后（不能在一起的数之间连边），可以化为一般图最大独立集问题，但是这样我们依然无法解决，我们必须再寻找性质进行处理才行 我们观察数字，考虑把一般图化为二分图，我们很容易发现，奇偶性相同的数字之间不可能连边，这样即为一个二分图，直接网络流跑二分图最大独立集问题即可 本题主要还是类比了一些成题的思路 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define LL long long int#define maxn 1005#define maxm 300005#define INF 2000000005using namespace std;int n, s, t;LL line[maxn];struct edge&#123; int next, to, flow; edge(int next, int to, int flow) : next(next), to(to), flow(flow)&#123;&#125; edge()&#123;&#125;&#125;e[maxm &lt;&lt; 1];int h[maxn], cnt = 1;int d[maxn];bool vis[maxn];int cur[maxn];void Add_Edge(int fr, int to, int flow)&#123; e[++cnt] = edge(h[fr], to, flow); h[fr] = cnt; e[++cnt] = edge(h[to], fr, 0); h[to] = cnt;&#125;bool BFS()&#123; queue&lt;int&gt; bfs; bfs.push(s); memset(d, 0, sizeof(d)); while (!bfs.empty())&#123; int op = bfs.front();bfs.pop(); for (int i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int k = e[i].to; if (k == s || d[k]) continue; d[k] = d[op] + 1; bfs.push(k); &#125; &#125; for (int i = s; i &lt;= t; i++) cur[i] = h[i]; if (d[t]) return true; return false;&#125;int DFS(int x, int a)&#123; if (x == t) return a; int rest = a; for (int&amp; i = cur[x]; i; i = e[i].next)&#123; if (!e[i].flow) continue; int op = e[i].to; if (d[op] != d[x] + 1) continue; int k = DFS(op, min(rest, e[i].flow)); e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; if (!rest) return a; &#125; return a - rest;&#125;void Dinic(int&amp; maxflow) &#123; while (BFS()) maxflow += DFS(s, INF);&#125;LL gcd(LL x, LL y)&#123; return (y == 0) ? x : gcd(y, x % y);&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;line[i]); for (int i = 1; i &lt;= n; i++)&#123; for (int j = i + 1; j &lt;= n; j++)&#123; if (gcd(line[i], line[j]) == 1 &amp;&amp; gcd(line[i] + 1, line[j] + 1) == 1)&#123; if (line[i] &amp; 1) Add_Edge(i, j, 1); else Add_Edge(j, i, 1); &#125; &#125; &#125; s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++)&#123; if (line[i] &amp; 1) Add_Edge(s, i, 1); else Add_Edge(i, t, 1); &#125; int maxflow = 0; Dinic(maxflow); printf("%d", n - maxflow); return 0;&#125; 忘记清空d数组了。。。WA了一次 #528. 「LibreOJ β Round #4」求和 题目分析显然是莫比乌斯反演，但是套用了常规的套路（外层枚举gcd的值然后计算）后发现需要计算$\mu^2(x)$的前缀和（不能线性筛），然而这个好像并不能办到，于是就GG了。。。 然而每当我们遇到$\mu^2(x)$这种东西的时候，其实可以使用它的定义，那就是所有质因子次数小于等于一的数的个数，这样，我们外层枚举$x$，内部用$x^2$来计算，公式就是这个样子的了： \sum_{x = 1}^n \mu(x) * \left[\frac{n}{x ^ 2}\right] * \left[\frac{m}{x ^ 2}\right]于是我们就可以直接$O(\sqrt{n})$搞掉本题了。。。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 10000005#define LL long long int#define M 998244353using namespace std;int p[maxn];int cnt = 0;bool vis[maxn];int mu[maxn];void init()&#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; mu[i * p[j]] = mu[i] * (-1); if (i % p[j] == 0)&#123; mu[i * p[j]] = 0; break; &#125; &#125; &#125;&#125;void work(LL n, LL m)&#123; LL ans = 0; LL con = min((LL)sqrt(n), (LL)sqrt(m)); for (LL x = 1; x &lt;= con; x++)&#123; ans = (ans + (((n / (x * x)) % M) * ((m / (x * x)) % M) % M * mu[x] + M) % M) % M; &#125; printf("%lld", ans);&#125;int main()&#123; init(); LL n, m; scanf("%lld%lld", &amp;n, &amp;m); work(n, m); return 0;&#125; #2000. 「SDOI2017」数字表格 题目分析其实就是一个普通的莫比乌斯反演题，直接上套路，枚举gcd的值，然后求出有多少个(i, j)的gcd是这个值，那么这个个数就是对应斐波那契数列对应项的指数，然后再采用变量整体化（积性函数提取）方法，即可解决本题，不懂的请移步《莫比乌斯反演总结》 公式就不贴了，上面的总结里面有对应公式（就在积性函数提取那里） AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define maxn 1000005#define M 1000000007#define LL long long intusing namespace std;LL mu[maxn];LL f[maxn];LL s[maxn];LL pre[maxn];LL prime[maxn], cnt;bool vis[maxn];LL getinv(LL x)&#123; return (x == 1) ? 1 : ((-(M / x) * getinv(M % x)) % M + M) % M;&#125;LL power(LL x, LL y)&#123; if (y == -1) return getinv(x); LL ans = 1, con = x; while (y)&#123; if (y &amp; 1) ans = ans * con % M; con = con * con % M; y &gt;&gt;= 1; &#125; return ans;&#125;void init()&#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; prime[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * prime[j] &gt;= maxn) break; vis[i * prime[j]] = 1; mu[i * prime[j]] = mu[i] * (-1); if (i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; &#125; &#125; f[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; f[i] = (f[i - 1] + f[i - 2]) % M; &#125; for (int i = 1; i &lt; maxn; i++) s[i] = 1; for (int i = 1; i &lt; maxn; i++)&#123; for (int j = 1; i * j &lt; maxn ; j++)&#123; s[i * j] = s[i * j] * power(f[i], mu[j]) % M; &#125; &#125; pre[0] = 1; pre[1] = s[1]; for (int i = 2; i &lt; maxn; i++)&#123; pre[i] = pre[i - 1] * s[i] % M; &#125;&#125;void work(int n, int m)&#123; LL ans = 1; for (LL i = 1; i &lt;= min(n, m); i++)&#123; LL next = min(n / (n / i), m / (m / i)); ans = ans * power(pre[next] * getinv(pre[i - 1]) % M, (n / i) * (m / i)) % M; i = next; &#125; printf("%lld\n", ans);&#125;LL n, m;int main()&#123; init(); LL T; scanf("%lld", &amp;T); while (T--)&#123; scanf("%lld%lld", &amp;n, &amp;m); work(n, m); &#125; return 0;&#125; #2001. 「SDOI2017」树点涂色 题目分析本题是一个LCT类比的思路，就是用access操作类比题目中的染色操作，为什么这样类比呢？因为这样做，我们可以清楚地知道那些链是同色的，在改变颜色以及统计答案时都会比较方便，如果只是使用树链剖分，我们就不会知道一条链的哪些地方颜色发生了中断，就无法维护信息了 几乎是人生第一次正式的使用LCT，练习了一下，于是就发生了一个大错误，调了我一半夜，凌晨3点才调完。。。那就是每个splay的顶端并非链的顶端，我们要更新的话，要用链的顶端，这样就要在splay上一直向左跑才行。。。然而我很晚才发现这件事情。。。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;int n, m;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int cnt = 1, h[maxn];void Add_Edge(int x, int y)&#123; e[++cnt] = edge(h[x], y); h[x] = cnt; e[++cnt] = edge(h[y], x); h[y] = cnt;&#125;int fa[maxn];int son[maxn];int d[maxn];int si[maxn];int top[maxn];int dfs[maxn];int idfs[maxn];int t;void DFS1(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x]) continue; fa[op] = x; d[op] = d[x] + 1; DFS1(op); si[x] += si[op]; if (si[op] &gt; si[son[x]]) son[x] = op; &#125; si[x]++;&#125;void DFS2(int x, int tp)&#123; top[x] = tp; dfs[x] = ++t; idfs[t] = x; if (son[x]) DFS2(son[x], tp); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == son[x] || op == fa[x]) continue; DFS2(op, op); &#125;&#125; int maxnum[maxn &lt;&lt; 1];int add[maxn &lt;&lt; 1];int qx, qy, qd;void pushdown(int l, int r, int o)&#123; if (add[o] != 0 &amp;&amp; l != r)&#123; add[o &lt;&lt; 1] += add[o]; maxnum[o &lt;&lt; 1] += add[o]; add[o &lt;&lt; 1 | 1] += add[o]; maxnum[o &lt;&lt; 1 | 1] += add[o]; add[o] = 0; &#125;&#125;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]);&#125;void init(int l, int r, int o)&#123; if (l == r) &#123; maxnum[o] = d[idfs[l]] + 1; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; maxnum[o] += qd; add[o] += qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy) return maxnum[o]; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans = max(ans, get(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = max(ans, get(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;int f[maxn];int ch[maxn][2];void init()&#123; for (int i = 1; i &lt;= n; i++) f[i] = fa[i];&#125;bool is_root(int x)&#123; return (!f[x] || (ch[f[x]][0] != x &amp;&amp; ch[f[x]][1] != x));&#125;void rotate(int t)&#123; if(is_root(t))return; int k=f[t]; if(!is_root(k))&#123; ch[f[k]][ch[f[k]][0]==k?0:1]=t; &#125; int d=(ch[k][0]==t)?0:1; f[t]=f[k]; ch[k][d]=ch[t][d^1]; f[ch[k][d]]=k; ch[t][d^1]=k; f[k]=t;&#125;void splay(int t)&#123; while(!is_root(t))&#123; int fa=f[t]; if(!is_root(fa))&#123; int ffa=f[fa]; int f1=(ch[ffa][0]==fa)?0:1; int f2=(ch[fa][0]==t)?0:1; if(f1^f2) rotate(t); else rotate(fa); &#125; rotate(t); &#125;&#125;void access(int x)&#123; int tmp = 0; while (true)&#123; splay(x); if (ch[x][1])&#123; int _x = ch[x][1]; while (ch[_x][0])&#123; _x = ch[_x][0]; &#125; qx = dfs[_x], qy = dfs[_x] + si[_x] - 1, qd = 1; modify(1, n, 1); &#125; ch[x][1] = tmp; tmp = x; if (!f[x]) return; int _x = x; while (ch[_x][0])&#123; _x = ch[_x][0]; &#125; qx = dfs[_x], qy = dfs[_x] + si[_x] - 1, qd = -1; modify(1, n, 1); x = f[x]; &#125;&#125;void modify(int x)&#123; access(x);&#125;void query(int x, int y, int i)&#123; qx = qy = dfs[x]; int a = get(1, n, 1); qx = qy = dfs[y]; int b = get(1, n, 1); int f1 = top[x], f2 = top[y]; while (f1 != f2)&#123; if (d[f1] &gt; d[f2])&#123; x = fa[f1]; f1 = top[x]; &#125; else&#123; y = fa[f2]; f2 = top[y]; &#125; &#125; int lca = (d[x] &gt; d[y]) ? y : x; int c = fa[lca]; qx = qy = dfs[lca]; lca = get(1, n, 1); qx = qy = dfs[c]; if (c) c = get(1, n, 1); else c = 0; if (lca == c) printf("%d\n", a + b - (c &lt;&lt; 1) + 1); else printf("%d\n", a + b - (c &lt;&lt; 1) - 1);&#125;void query(int x)&#123; qx = dfs[x], qy = dfs[x] + si[x] - 1; printf("%d\n", get(1, n, 1));&#125;void init_all()&#123; DFS1(1); DFS2(1, 1); init(1, n, 1); init();&#125;int main()&#123;; scanf("%d%d", &amp;n, &amp;m); int x, y, op; for (int i = 0; i &lt; n - 1; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; init_all(); for (int i = 0; i &lt; m; i++)&#123; scanf("%d", &amp;op); if (op == 1)&#123; scanf("%d", &amp;x); modify(x); &#125; else if (op == 2)&#123; scanf("%d%d", &amp;x, &amp;y); query(x, y, i); &#125; else if (op == 3)&#123; scanf("%d", &amp;x); query(x); &#125; &#125; return 0;&#125; 数组版的splay和LCT，感觉还是非常好的O(∩_∩)O~ #2031.「SDOI2016」数字配对 题目分析上面好像刚说完这道题。。。这就是用连边然后转化为二分图，然后用费用流解决的那道题，二分图的依据是含有质因子个数的奇偶性，可以想一想为什么 然后。。。本题好像就解决了？？？就是二分图多重最大权匹配问题，直接费用流 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define INF 2000000000005#define maxn 1000005#define LL long long intusing namespace std;LL n, m, s, t;struct edge&#123; LL next, to; LL flow, cost; edge(LL next, LL to, LL flow, LL cost) : next(next), to(to), flow(flow), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];LL h[maxn], ct = 1;void Add_Edge(LL fr, LL to, LL flow, LL cost)&#123; e[++ct] = edge(h[fr], to, flow, cost); h[fr] = ct; e[++ct] = edge(h[to], fr, 0, -cost); h[to] = ct;&#125;/*bool BFS()&#123; queue&lt;LL&gt; bfs; bfs.push(s); memset(d, 0, sizeof(d)); while (!bfs.empty())&#123; LL op = bfs.front();bfs.pop(); for (LL i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL k = e[i].to; if (d[k] || k == s) continue; d[k] = d[op] + 1; bfs.push(k); &#125; &#125; if (!d[t]) return false; return true;&#125;LL DFS(LL x, LL a)&#123; if (x == t) return a; LL rest = a; for (LL i = h[x]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL op = e[i].to; if (d[op] != d[x] + 1) continue; LL k = DFS(op, min(rest, e[i].flow)); e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; if (!rest) return a; &#125; return rest - a;&#125;void Dinic(LL&amp; maxflow)&#123; while (BFS()) maxflow += DFS(s, INF);&#125;*/bool vis2[maxn];LL p2[maxn];LL d[maxn];bool SPFA()&#123; queue&lt;LL&gt; spfa; spfa.push(s); for (LL i = s; i &lt;= t; i++) d[i] = INF; d[s] = 0; vis2[s] = 1; while (!spfa.empty())&#123; LL op = spfa.front();spfa.pop(); for (LL i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL k = e[i].to; if (d[k] &gt; d[op] + e[i].cost)&#123; d[k] = d[op] + e[i].cost; p2[k] = i; if (!vis2[k])&#123; vis2[k] = 1; spfa.push(k); &#125; &#125; &#125; vis2[op] = 0; &#125; if (d[t] &gt;= INF) return false; return true;&#125;bool Augment(LL&amp; maxflow, LL&amp; mincost)&#123; LL now = t, flow = INF; while (now != s)&#123; LL k = p2[now]; flow = min(flow, e[k].flow); now = e[k ^ 1].to; &#125; now = t; while (now != s)&#123; LL k = p2[now]; e[k].flow -= flow; e[k ^ 1].flow += flow; now = e[k ^ 1].to; &#125; maxflow += flow, mincost += (d[t] - d[s]) * flow; if (mincost &gt; 0)&#123; mincost -= (d[t] - d[s]) * flow; maxflow -= flow; maxflow += mincost / (d[s] - d[t]); return true; &#125; return false;&#125;void MCMF(LL&amp; maxflow, LL&amp; mincost)&#123; while (SPFA() &amp;&amp; !Augment(maxflow, mincost))&#123;&#125;&#125;LL p[maxn];bool vis[maxn];LL cnt;void init()&#123; for (LL i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++] = i; for (LL j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;bool side[maxn];bool judge(LL x)&#123; for (LL i = 2; i &lt;= (LL) sqrt(x); i++)&#123; if (x % i == 0) return false; &#125; return true;&#125;LL a[maxn];LL b[maxn];LL c[maxn];void process(LL i)&#123; LL x = a[i]; LL con = (LL) sqrt(x); for (LL j = 2; j &lt;= con; j++)&#123; if (!vis[j] &amp;&amp; x % j == 0)&#123; while (x % j == 0)&#123; x /= j; side[i] ^= 1; &#125; con = (LL) sqrt(x); &#125; &#125; if (x != 1) side[i] ^= 1;&#125;LL left[maxn];LL cntl;LL right[maxn];LL cntr;void work()&#123; init(); s = 0, t = n + 1; for (LL i = 1; i &lt;= n; i++)&#123; process(i); if (!side[i]) left[++cntl] = i; else right[++cntr] = i; &#125; for (LL i = 1; i &lt;= n; i++)&#123; for (LL j = 1; j &lt;= n; j++)&#123; if (i == j || a[i] % a[j] != 0 || !judge(a[i] / a[j])) continue; if (side[i]) Add_Edge(j, i, INF, -c[i] * c[j]); else Add_Edge(i, j, INF, -c[i] * c[j]); &#125; &#125; for (LL i = 1; i &lt;= cntl; i++)&#123; Add_Edge(s, left[i], b[left[i]], 0); &#125; for (LL i = 1; i &lt;= cntr; i++)&#123; Add_Edge(right[i], t, b[right[i]], 0); &#125; LL maxflow = 0, mincost = 0; MCMF(maxflow, mincost); printf("%lld\n", maxflow);&#125;int main()&#123; scanf("%lld", &amp;n); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;b[i]); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]); work(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libre Online Judge题解目录]]></title>
    <url>%2F2017%2F08%2F29%2FLibre-Online-Judge%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[引言突然发现在Libre Online Judge上也刷了一点题，于是总结一下 目录还是采用老办法，一句话题解采用白色字体，同时每十道题一篇题解 LOJ题解目录 LOJ 阶段性汇总I #507. 「LibreOJ NOI Round #1」接竹竿 1D/1D优化DP #514. 「LibreOJ β Round #2」模拟只会猜题意 暴力 #516. 「LibreOJ β Round #2」DP 一般看规律 并查集+启发式合并+stl #524. 「LibreOJ β Round #4」游戏 博弈+抽象思考+极端情况判断 #525. 「LibreOJ β Round #4」多项式 广义欧拉定理 #526. 「LibreOJ β Round #4」子集 网络流+二分图转化 #528. 「LibreOJ β Round #4」求和 莫比乌斯反演+$\mu^2(x)$定义法转化 #2000. 「SDOI2017」数字表格 莫比乌斯反演 #2001. 「SDOI2017」树点涂色 LCT+树链剖分 #2031.「SDOI2016」数字配对 网络流+二分图转化 LOJ 阶段性汇总II #2036. 「SHOI2015」自动刷题机 二分答案 #2194. 「SDOI2014」数数 AC自动机+情况讨论 #2234. 「JLOI2014」聪明的燕姿 DFS搜索质因子 #2236. 「JLOI2014」松鼠的新家 树链剖分 #2245. 「NOI2014」魔法森林 LCT/动点SPFA #2246. 「NOI2014」动物园 KMP巧妙应用 #6030. 「雅礼集训 2017 Day1」矩阵 思维题+情况讨论 #6062. 「2017 山东一轮集训 Day2」Pair 转化限制+线段树维护前缀信息 #6075. 「2017 山东一轮集训 Day6」重建 最短路+逐步更新思想 #6136. 「2017 山东三轮集训 Day4」Left 思维题+分治+2-SAT+贪心]]></content>
      <tags>
        <tag>题解目录</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zkw费用流详解]]></title>
    <url>%2F2017%2F08%2F27%2Fzkw%E8%B4%B9%E7%94%A8%E6%B5%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言还是扒了一篇老文章，感觉年轻时的我真是太强了。。。 zkw费用流详解前排Orz一发 zkw orz orz orz $\cdots$ 今天看了zkw的费用流算法，感觉思路极具巧妙性，最重要的是优点是平均状态下跑得很快，编程复杂度还非常低，实在是十分优良的费用流算法 下面对原理进行详解： 原理zkw费用流主要采用了两大优良算法，第一个是多路增广，第二个就是KM算法的类比，与其说这是一种算法，不如说这是一种思想方法，这真的很强大 感觉这次应该先把代码贴上，然后再进行详解。。。 多路增广这个应该很好理解，就是类似于DFS一样的增广方法，我们传入两个参数，一个是当前的结点编号，另一个是当前的可改进量（这个说法沿袭了刘汝佳的风格，实际上就是当前可以容纳的最大流量），然后像DFS一样搞它就行了，为了防止有圈的出现，我们再对每个点记录一个访问标记，记录这个点是否被访问过就行啦 KM算法类比，不妨把这个称为扩展KM算法，主要就是在多路增广无法继续进行的时候，我们对结点进行一个重赋权操作，改变当前的结点距离标号，这种方法就是类比了KM算法后得到的 那么，该怎么改变呢？我们可以继续类比KM算法，考虑最后一次不能增广时跑出的残留DFS路径，然后对这条路径上的结点进行重赋权操作，具体来说，我们先求出来所有这样的差值：D=c_{ji}+D_j-D_i 此时无法继续增广，那么对于无法增广的点来说，它的所有不在残留DFS路径上的后继结点一定满足：D_i+c_{ij}>D_j\mbox{ ，} j是i的后继结点这样，我们找到所有这样的差值的最小值$D_{min}$，然后，把每个在残留DFS路径上的结点的距离标号都同时减去这个值，很容易证明这样并不会破坏每个点之间的距离标号的数量关系（除了原先小于的变成了相等以外），同时还可以使得至少一条新的弧被加入到最短路网络中来，即可以继续进行增广，如果还是不行也可以继续进行扩展，而且扩展的范围会更大，因为更多的弧进入了最短路网络中 这样，算法就这样不停地工作下去，直到彻底不能进行增广，即距离标号也不能再修改的时候，算法结束，就可以跑出来网络中的最小费用流 另外，这个算法并不能直接应用于含有负权边或负权环的网络中，需要用zkw的思路进行转换，将负权边满流，然后在逐渐进行调整，总之这个地方就是一个思想上的工作，反正我还没有实践过。。。 下面贴上代码：注意代码中所有的cost均表示的是距离标号差值，即上文的$D$，这点很重要 zkw费用流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxint=~0U&gt;&gt;1;int n,m,pi1,cost=0;bool v[550];struct etype&#123; int t,c,u; //t为后继结点，c为reduced cost，这个很重要，u为当前残量 etype *next,*pair; etype()&#123;&#125; etype(int t_,int c_,int u_,etype* next_): t(t_),c(c_),u(u_),next(next_)&#123;&#125; //next为前向星的下一条边，pair为反向边 void* operator new(unsigned,void* p)&#123;return p;&#125;&#125; *e[550];int aug(int no,int m)//no=当前结点编号，m=可改进量&#123; if(no==n)return cost+=pi1*m,m; //考虑了减少的距离标号 v[no]=true; //记录结点访问情况 int l=m; for(etype *i=e[no];i;i=i-&gt;next) if(i-&gt;u &amp;&amp; !i-&gt;c &amp;&amp; !v[i-&gt;t]) //每次选择存在且距离标号差值为0的边进行增广，要求后继结点不能被访问 &#123; int d=aug(i-&gt;t,l&lt;i-&gt;u?l:i-&gt;u); i-&gt;u-=d,i-&gt;pair-&gt;u+=d,l-=d; //更改当前的可改进量 if(!l)return m; //小优化，提前退出算法 &#125; return m-l;&#125;//多路增广算法bool modlabel()&#123; int d=maxint; //d为可修改的距离标号的差值最小值 for(int i=1;i&lt;=n;++i)if(v[i]) for(etype *j=e[i];j;j=j-&gt;next) if(j-&gt;u &amp;&amp; !v[j-&gt;t] &amp;&amp; j-&gt;c&lt;d)d=j-&gt;c; //求出了d变量 if(d==maxint)return false; //已经无法继续修改距离标号，直接退出算法 for(int i=1;i&lt;=n;++i)if(v[i]) for(etype *j=e[i];j;j=j-&gt;next) j-&gt;c-=d,j-&gt;pair-&gt;c+=d; //修改距离标号（即直接修改reduced cost），反向弧要增加 pi1 += d; //用于后续的增广环节 return true;&#125;int main()&#123; /*freopen("costflow.in","r",stdin); freopen("costflow.out","w",stdout);*/ scanf("%d %d",&amp;n,&amp;m); etype *Pe=new etype[m+m]; while(m--) &#123; int s,t,c,u; scanf("%d%d%d%d",&amp;s,&amp;t,&amp;u,&amp;c); e[s]=new(Pe++)etype(t, c,u,e[s]); e[t]=new(Pe++)etype(s,-c,0,e[t]); e[s]-&gt;pair=e[t]; e[t]-&gt;pair=e[s]; &#125; while(modlabel())&#123; memset(v,0,sizeof(v)); while(aug(1,maxint))&#123; memset(v,0,sizeof(v)); &#125; &#125; printf("%d\n",cost); return 0;&#125; 原版代码，经实测编译已经通过，注释已在代码中给出，感觉唯一不太好理解的就是那个$reduced\mbox{ }cost$，别的。。。看一看应该差不多 性能分析其实这正是我的一些小问题的所在，没想到居然和我想的一样。。。我错了，应该是我居然和zkw大神想的一样，希望大神原谅我。。。这几个问题就是，在重赋权一次以后，一定能出现增广路么？这个其实是并不一定的，所以会影响zkw算法的性能，下面对zkw算法与MCMF算法进行一下性能对比 每次，zkw算法采用的是重赋权以及多路增广，在网络的弧数较多的时候，即在稠密图上的时候，多路增广可以减少重赋权的次数，而每次重赋权操作也只是对数组进行了线性扫描，不需要SPFA的队列等复杂的操作，性能会非常好 而如果是在稀疏图上，每次zkw重赋权操作以后并不保证一定能出现增广路，这样就会导致反复的重赋权，同时这个时候的多路增广也不会起到多大的作用，这时MCMF中的SPFA就发挥出优势来了，所以这时zkw算法会比较慢 引用一段更专业的讲解与总结： 对于最终流量较大, 而费用取值范围不大的图, 或者是增广路径比较短的图 (如二分图), zkw 算法都会比较快. 原因是充分发挥优势. 比如流多说明可以同一费用反复增广, 费用窄说明不用改太多距离标号就会有新增广路, 增广路径短可以显著改善最坏情况, 因为即使每次就只增加一条边也可以很快凑成最短路. 如果恰恰相反, 流量不大, 费用不小, 增广路还较长, 就不适合 zkw 算法了. 所以，zkw大神考虑到了原始对偶算法的优缺点，综合了SPFA与重赋权算法的优势，进行了改进，下面贴上代码： 改进版zkw费用流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;const int V=440, E=V*2, maxint=0x3F3F3F3F;struct etype&#123; int t, c, u; etype *next, *pair; etype() &#123;&#125; etype(int T, int C, int U, etype* N): t(T), c(C), u(U), next(N) &#123;&#125; void* operator new(unsigned, void* p)&#123;return p;&#125;&#125; *e[V], Te[E+E], *Pe;int S, T, n, piS, cost;bool v[V];void addedge(int s, int t, int c, int u)&#123; e[s] = new(Pe++) etype(t, +c, u, e[s]); e[t] = new(Pe++) etype(s, -c, 0, e[t]); e[s]-&gt;pair = e[t]; e[t]-&gt;pair = e[s];&#125;int aug(int no, int m)&#123; if (no == T) return cost += piS * m, m; v[no] = true; int l = m; for (etype *i = e[no]; i; i = i-&gt;next) if (i-&gt;u &amp;&amp; !i-&gt;c &amp;&amp; !v[i-&gt;t]) &#123; int d = aug(i-&gt;t, l &lt; i-&gt;u ? l : i-&gt;u); i-&gt;u -= d, i-&gt;pair-&gt;u += d, l -= d; if (!l) return m; &#125; return m - l;&#125;bool modlabel()&#123; static int d[V]; memset(d, 0x3F, sizeof(d)); d[T] = 0; static deque&lt;int&gt; Q; Q.push_back(T); while(Q.size()) &#123; int dt, no = Q.front(); Q.pop_front(); for(etype *i = e[no]; i; i = i-&gt;next) if(i-&gt;pair-&gt;u &amp;&amp; (dt = d[no] - i-&gt;c) &lt; d[i-&gt;t]) (d[i-&gt;t] = dt) &lt;= d[Q.size() ? Q.front() : 0] ? Q.push_front(i-&gt;t) : Q.push_back(i-&gt;t); &#125; for(int i = 0; i &lt; n; ++i) for(etype *j = e[i]; j; j = j-&gt;next) j-&gt;c += d[j-&gt;t] - d[i]; piS += d[S]; return d[S] &lt; maxint;&#125;int ab[V], *pab[V], w[V];struct lt&#123; bool operator()(int* p1,int* p2) &#123;return *p1 &lt; *p2;&#125;&#125;;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(e,0,sizeof(e)); Pe = Te; static int m, k; scanf("%d %d", &amp;m, &amp;k); int abz = 0; for(int i = 0; i &lt; m; ++i) &#123; scanf("%d", pab[abz] = &amp;ab[abz]), abz++; scanf("%d", pab[abz] = &amp;ab[abz]), abz++; scanf("%d", &amp;w[i]); &#125; sort(&amp;pab[0], &amp;pab[abz], lt()); int c=0xDEADBEEF; n=0; for(int i = 0; i &lt; abz; ++i) &#123; if(c != *pab[i]) c = *pab[i], ++n; *pab[i] = n; &#125; ++n, S = 0, T = n++; for(int i = 0; i &lt; T; ++i) addedge(i, i+1, 0, k); for(int i = 0; i &lt; m; ++i) addedge(ab[i+i], ab[i+i+1], -w[i], 1); piS = cost = 0; while(modlabel())&#123; memset(v,0,sizeof(v)); while(aug(S,maxint))&#123; memset(v,0,sizeof(v)); &#125; &#125; printf("%d\n", -cost); &#125; return 0;&#125; 。。。好像长了不少，最后再来段专业性的总结吧 这个特殊的原始对偶算法在稠密二分费用小的图上不敌原来的 zkw 算法, 但远远胜过暴力 SPFA. 在另外的图上, 对两者都是稳胜. 比暴力 SPFA 快原因是, 多路增广, 同时使用了 Reduced Cost 缩小了费用范围, 从而利于 SPFA 算法的工作 (需要的松弛次数减少), 而且使用 Reduced Cost 后不再有负边, 使 SLF 的优化落到了实处 (回忆: SLF 优化只有当所有边均为正的时候才能发挥出最佳效果), 甚至允许用 Dijkstra 来完成后面的工作. 比 zkw 算法快的原因是, 在流小费用大距离长的图上, 一次性把距离标号改对往往比反复调整更有效率. 那么，今天的讲解就到此为止啦，ヾ(￣▽￣)Bye~Bye~]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>zkw费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶网络流算法]]></title>
    <url>%2F2017%2F08%2F27%2F%E8%BF%9B%E9%98%B6%E7%BD%91%E7%BB%9C%E6%B5%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[引言又双叒叕扒了一篇老文章，感觉年轻时的我真是太强了。。。 进阶网络流算法Catalogue: 今天简单地看了一下相对高级的网络流的算法，比如无源汇的有上下界的网络流，什么的，现在就来做一个小小的总结 本文即将介绍的算法如下 有上下界的网络流 无源汇时的可行流 有源汇时的可行/最大/最小流 基本模型 最小割 多源多汇 结点容量 结点盈余/不足 棋盘问题 二分图最大匹配 位置组合问题 先来介绍一下有上下界的网络流的基本算法 有上下界的网络流题目概况 这种问题的大致条件一般是这样的，现在对于网络流中的每一条弧，除了原先的有$u$结点，$v$结点，$cap$容量，$flow$流量以外，还增加了两个新的属性：流量的上下界，$low$代表下界，$up$代表上界（其实我们可以直接忽略掉上界$up$，把它直接作为容量$cap$来搞），要求每条弧的流量大小均必须满足在这两个界的之间，然后要求类似于最大流/最小流之类的东西 分析首先我们先考虑无源无汇的网络 无源汇有上下界网络流题目概况 首先这样的题目是什么意思。无源无汇的条件即为整个网络流为环状的情况，我们可以发现所有的流都是在这个环中循环移动的，它们就这样一直地，一直地流下去，无休无止。。。直到我们开始做这道题 我们对于这样的题目该怎么搞呢？ 我们可以尝试先让所有的弧的流量均达到下界，然后在此基础上为了保证流量平衡而继续增大某些弧的流量（想一想为什么不能减小），下面我们的目的就是构造出一组这样的方案，使得增广完以后每个结点的流量均平衡 我们可以考虑这样一种网络：附加网络，它就表示我们要加入原网络中的流量分布情况，即我们将附加网络与原网络合并以后的新网络满足流量平衡的条件，这样我们便可以求出原网络的一组可行流了 那么该怎么样考虑这个附加网络呢？ 我们现在已经人为地使每一条弧都达到了它们的下界，并且导致了流量不平衡的情况（当然出于偶然性而平衡的那些情况本处不考虑），现在就要构造这个附加网络。我们可以发现，现在由于有些弧有流量，而一些没有，会导致一些结点的流入量与流出量严重不符，这样，我们可以通过“多退少补”的思想，来构造附加网络，具体如下： Step 1： 我们定义结点的总流入量：$In(x)$ ，结点的总流出量：$Out(x)$ ，偏移量：$R(x)$ 由于流出量与流入量情况对称，所以我们先只考虑流入量 对于每一个结点的流入量，我们想把它在附加网络中平衡掉，所以我们希望在附加网络中能够想办法“补齐”这个不平衡的现象，所以我们在附加网络中创建超级源$ss$与超级汇$tt$，每次根据这个流入量，我们从源点$ss$向结点$x$连一条容量为$In(x)$的弧1 ，表示我们希望通过这条弧来补齐不平衡量（想一想为什么要这样连弧） 下面解释这样连弧的原因 原先的网络是一个环状的网络，网络中的流就一直在里面流动，而我们这样做，是为了把原先的网络中的流导出到超级汇中，同时再使用超级源补齐，因为我们一开始已经开了许多弧的下界流量，比如一条弧$A-&gt;B$，它的流量下界为$LOW$，则现在$A-&gt;B$中已经有了$LOW$的盈余量，而在最终的平衡状态下，$B$点的出弧（实际存在的）也就必然要负担这$LOW$大小的盈余流量，所以我们从$ss$向$B$连容量为$In(B)$的弧（虚拟的），这样我们就可以通过这虚拟的弧向实际存在的弧中通流，使实际的弧达到平衡 注意！这里有一种直观的但却十分易错的连弧方法，即在上述情况下从$B$向$tt$连一条容量为$In(B)$的弧，看起来这样做，我们把多余的流量导出了，使得$B$点的流量平衡了，但仔细想想就会发现，我们是把流量导出到了一条虚拟的弧中，它最后并不能作为结果存在，而真正的$B$的那些出弧还没有流量（因为被虚拟弧导走了，在那时看起来像是平衡了一样），最后结果并不是平衡的 所以，重点就在于这个$R$值，由于会有许多重复的情况，所以我们把所有能累加的都累加起来，能得到$R$的一个计算式，如下： $R(x)=In(x)-Out(x)$ 这样，我们先求出所有结点的偏移量，之后继续下一步的操作 Step 2: 对于每个结点，考察这个结点的$R$值。这个$R$值的正负决定着很多的东西，决定着我们打算向那个方向连弧。原本一个结点它既要连超级源，也要连超级汇，但是我们发现它们可以互相抵消，这样我们只需要连一侧 根据上文的分析结果，我们可以知道当这个$R(x)$值为正的时候，我们应该从$ss$向$x$连弧，反之从$x$向$tt$连弧（想一想，如果这里不明白，请回到上文再看一遍） 然后，对于那些原来就存在于网络中的弧（实际弧），我们令它们的容量为$cap$-$low$，$flow$为$0$，这样，我们就相当于平衡掉了下界，把原问题转化为了一个普通的网络流问题，但其实还是有少许的区别，我们还要进行小小的处理，将在下一步中讲解 我们的弧是连完了，但它一定有解吗？万一还有一些流没有达到平衡条件而导致网络仍然不平衡怎么办？所以，我们只需对超级源和超级汇跑一个最大流，然后判断这个最大流是否与所有正的$R(x)$的和完全相等2，然后由此得出是否无解，这样无源汇的可行流就可以被求出来啦(^o^)/ 有源汇上下界网络流 我们可以同时处理可行流/最大流/最小流问题，前述过程中，我们只是探讨了无源汇的情况，而现在我们考虑的是有源汇上下界网络流。其实我们只是需要从原网络中的汇点向原网络中的源点连一条容量无穷大的弧，即可转化为无源无汇问题，然后就可以套用上述过程了 而在前述过程中，我们求出了一个最大流，但这个最大流仅仅用来判断答案，而可以作为答案的一部分的是那条后添加的容量无穷大的那条边，那里面的流记录了在原网络中流通的流的大小，可以用于统计答案 为了求出最大流/最小流在上述过程（Step 1，Step 2）结束后，我们还需要接下来的一步： Step 3： 这时候我们已经搞定了附加网络的作用，还求出了当前的$Maxflow$，下一步我们就是要继续寻找残余的可改进量了（上一步的过程相当于判断解的存在性，而当前的原网络中肯定还剩下许多的待改进量），我们此时只需要去掉超级源与超级汇，以及与它们相连的弧，这时由于原网络中带有源点与汇点，我们可以直接使用这两个点进行后续增广 可行流其实这时已经求完了，我们去掉超级源与超级汇以后，我们剩下的部分就一定是可行流 最大流 我们可以直接在残量网络上再跑一遍最大流算法（由$s$到$t$），然后把这个答案与前述步骤答案（即上文的容量无穷大的弧的流量）相加即为最大流，这时的意义即为我们充分利用了残量网络中的残余流量 最小流 由于每条弧都有自己的反向弧，所以我们只要跑一遍由$t$到$s$的最大流即可，这时我们充分利用了反向弧中的残余流量，把尽可能减小的部分都减掉了，所以此时用原答案（即上文的容量无穷大的弧的流量）减去这次的最大流答案即为最小流 下面为有上下界最小流贴上一道例题以及代码作为示范 问题 A: 摆棋子时间限制: 1 Sec 内存限制: 256 MB AC代码(ISAP最大流算法)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 1005#define maxn2 100005#define INF 2000000005using namespace std;struct edge&#123; int nex,to,cap,flow; edge():nex(0),to(0),cap(0),flow(0)&#123;&#125; edge(int nex,int to,int cap,int flow): nex(nex),to(to),cap(cap),flow(flow)&#123;&#125;&#125;e[maxn2];int n,m,k,cnt=1,tot=0,all=0,save1[maxn],save2[maxn],d[maxn],cur[maxn],p[maxn],h[maxn],sum[maxn],rec[maxn];//s=1,t=n+m+2,ss=0,tt=n+m+3bool broke[maxn][maxn],vis[maxn];void Add_Edge(int fr,int to,int cap)&#123; e[++cnt]=edge(h[fr],to,cap,0); h[fr]=cnt; e[++cnt]=edge(h[to],fr,0,0); h[to]=cnt;&#125;bool init_First()&#123; int a=0,b=0; for(int i=2;i&lt;=n+1;i++)&#123; for(int j=n+2;j&lt;=m+n+1;j++)&#123; if(broke[i-1][j-n-1])continue; Add_Edge(i,j,1); sum[i]++; sum[j]++; &#125; &#125; for(int i=2;i&lt;=n+1;i++)&#123; Add_Edge(1,i,sum[i]-save1[i-1]); if(sum[i]&lt;save1[i-1])&#123;/*printf(" %d %d %d %d No_1\n",n,m,save1[i-1],sum[i]);*/return false;&#125; Add_Edge(0,i,save1[i-1]); tot+=save1[i-1]; a+=save1[i-1]; &#125; for(int i=n+2;i&lt;=m+n+1;i++)&#123; Add_Edge(i,n+m+2,sum[i]-save2[i-n-1]); if(sum[i]&lt;save2[i-n-1])&#123;/*printf("$$$$$$%d$%dNo_2\n",save2[i-n-1],sum[i]);*/return false;&#125; Add_Edge(i,n+m+3,save2[i-n-1]); b+=save2[i-1-n]; &#125; tot+=b; Add_Edge(0,n+m+2,b); Add_Edge(1,n+m+3,a); Add_Edge(n+m+2,1,INF); return true;&#125;int Augment(int s,int t)&#123; int now=t,flow=INF; while(now!=s)&#123; int op=p[now]; flow=min(flow,e[op].cap-e[op].flow); now=e[op^1].to; &#125; now=t; while(now!=s)&#123; int op=p[now]; e[op].flow+=flow; e[op^1].flow-=flow; now=e[op^1].to; &#125; return flow;&#125;bool BFS(int s,int t)&#123; memset(vis,0,sizeof(vis)); memset(p,-1,sizeof(p)); for(int i=0;i&lt;=all;i++)&#123; d[i]=INF; &#125; queue&lt;int&gt; bfs; bfs.push(t); d[t]=0; vis[t]=true; while(!bfs.empty())&#123; int op=bfs.front();bfs.pop(); for(int i=h[op];i!=0;i=e[i].nex)&#123; int op2=e[i].to; if(!vis[op2])&#123; vis[op2]=true; d[op2]=d[op]+1; bfs.push(op2); &#125; &#125; &#125; if(d[s]&gt;=INF)return false; return true;&#125;int ISAP(int s,int t)&#123; int maxflow=0,now=s; if(!BFS(s,t))return maxflow; memset(rec,0,sizeof(rec)); for(int i=s;i&lt;=t;i++)&#123; rec[d[i]]++; &#125; for(int i=s;i&lt;=t;i++)&#123; cur[i]=h[i]; &#125; while(d[s]&lt;all)&#123; bool if_ope=false; if(now==t)&#123; maxflow+=Augment(s,t); now=s; &#125; for(int i=cur[now];i!=0;i=e[i].nex)&#123; int op=e[i].to; if(d[now]-1==d[op]&amp;&amp;e[i].cap&gt;e[i].flow)&#123; cur[now]=i; p[op]=i; now=op; if_ope=true; break; &#125; &#125; if(!if_ope)&#123; int minnum=all; for(int i=h[now];i!=0;i=e[i].nex)&#123; if(e[i].cap&gt;e[i].flow)&#123; minnum=min(minnum,d[e[i].to]); &#125; &#125; rec[d[now]]--; if(rec[d[now]]==0)break; d[now]=minnum+1; rec[d[now]]++; cur[now]=h[now]; if(now!=s)now=e[p[now]^1].to; &#125; &#125; return maxflow;&#125;void init_Second()&#123; for(int i=h[0];i!=0;i=e[i].nex)&#123; e[i].cap=e[i].flow; e[i^1].cap=e[i^1].flow; &#125; for(int i=h[m+n+3];i!=0;i=e[i].nex)&#123; e[i].cap=e[i].flow; e[i^1].cap=e[i^1].flow; &#125; h[1]=e[h[1]].nex; h[m+n+2]=e[h[n+m+2]].nex;&#125;void work()&#123; if(!init_First())&#123;printf("No Solution");return;&#125; int maxflow=ISAP(0,n+m+3); if(maxflow!=tot)&#123;printf("No Solution");return;&#125; int ans=e[cnt-1].flow; init_Second(); ans-=ISAP(m+n+2,1); printf("%d",ans);&#125;int main()&#123; /*freopen("input.txt","r",stdin); freopen("output.txt","w",stdout);*/ scanf("%d%d%d",&amp;n,&amp;m,&amp;k); /*printf(" %d %d %d",n,m,k);*/ all=n+m+4; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;save1[i]); &#125; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;save2[i]); &#125; int x,y; for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;x,&amp;y); broke[x][y]=true; &#125; work(); return 0;&#125; 注意！！！！ 我们在添加弧的时候，一定要看清弧的数量，大部分情况下弧的数量均为$O(n^2)$级别的，而不是$O(n)$的！！！请不要把弧数组大小与点数大小混为一谈！！！（就是因为这点问题卡了一天QAQ，发生了奇异错误3） 那么，到这里这几种网络流基本上就搞完了，下面我们介绍一些常见的模型 基本模型 说起模型，网络流所能产生的模型比比皆是，我们可以惊奇地发现某题竟然可以使用网络流瞬间秒过，或者豁然开朗，否则什么也搞不出来。这时就需要我们不断地总结与归纳常见的模型 最小割 这是一个定理，即网络的最小割等于最大流，这个定力十分重要，我们可以用最大流的方法求解所有的最小割，这就是我们想要看到的 多源多汇 即有不止一个源点和不止一个汇点的网络，这种情况非常简单，我们只需要添加一个超级源与超级汇，就可以将问题转化为单源单汇问题，然后该干嘛干嘛。。。 结点容量 即一种结点上有限制容量的网络，我们只需要将每个点进行拆分，然后用其中一个接受原来点的所有入弧，另一个点用来接收原来点的所有出弧，然后在这两点之间连接一条容量等于结点容量的边即可转化为普通的网络流 结点盈余/不足 这种题目有两种情况，一种是结点允许有多大的盈余/不足，另一种是结点本来就有一些盈余/不足（即流量不平衡的网络流） 对于第一种情况，我们只需要考虑添加点到源汇点的弧即可，如果一个点允许盈余$Rest$，那么我们可以从结点连一条容量为$Rest$的弧到汇点，如果是不足，我们可以由源点向这个结点连弧，这样就转化为了一个普通的网络流问题 对于第二种情况，个人的方法是，我们可以连一些上下界大小相同的弧，即强制这条弧的流量，然后套用有上下界的网络流算法即可 棋盘问题 棋盘应该是二分图的常用模型了，事实上几乎都被考烂了，然而二分图的问题可以很轻松地被网络流搞掉，所以我们常常使用网络流。我们把行视为结点集$X$，把列视作结点集$Y$，然后在位置$(x,y)$操作视作从结点集$X$中第$x$个向结点集$Y$中的第$y$个结点连弧，然后增加超级源与超级汇，再套用网络流模型即可 二分图最大匹配 其实有了上一个的启发，这个应该就十分地容易了，设结点集$X$中某点$A$的权值为$Value_A$，结点集$Y$中某点$B$的权值为$Value_B$，那么我们只要从超级源向$A$连一条容量为$Value_A$的弧，从$B$向超级汇连一条容量为$Value_B$的弧，然后跑一遍最大流即可解决 位置组合问题 这个模型来源于北京市2013年的市（省？）选题中，题目为《水晶》，题目看似与网络流毫无关联，实际上却息息相关，那道题大概是考虑两种位置组合，然后我们只需要搞一个网络，把这两种位置关系加进去，那么我们就可以通过最大流算法什么的求出网络的最小割，这样就解决了问题 那么，本篇详解就到此为止了，如果有什么不足与更新，会另有文章予以补充 那么，再见啦&lt;(￣ˇ￣)/ 1. 这里十分关键，也最难理解，一定要仔细看下面的讲解！！！ &#8617; 2. 注意此处是完全相等，多一点，少一点都不行，而且答案也不可能大于$\sum_{i=1}^n R(i)$，这是因为我们之前向超级源点与超级汇点连弧的时候，所有与$ss$相连的弧的容量$SS= \sum _{e(ss,x)\in E} cap(e)$以及所有与$tt$相连的弧的容量$TT=\sum _{e(x,tt)\in E} cap(e)$满足$SS = TT $，而且这样也说明答案不可能大于$SS$或者$TT$ &#8617; 3. 奇异错误的定义为在修改某变量时，导致了另一个变量的值的变动，这种错误对初学者来说是致命的，因为这种错误十分奇异，变量在不进行任何运算的情况下被改变，如果不事先了解到这种错误，那么要花费很长的时间才会明白自己是因为数组越界而导致了错误（即本应该被判为$RE$却并没有），因为一定程度下系统允许数组的越界 &#8617;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列莫队算法详解]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%BA%8F%E5%88%97%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言又扒了一篇老文章，感觉年轻时的我真是太强了。。。 序列莫队算法详解 今天开始跑个人计划，于是这个时候我开始学习序列莫队算法，参考的是黄学长(hzwer)的小Z的袜子的那道题。莫队算法用于处理一类关于区间的问题，效果相对来说不错，可以在某些情况下作为正式算法使用，莫队算法的种类有四个，我们在这里先予以汇总，再进行详解 莫队算法 序列莫队 &lt;— 序列带修改莫队 &lt;— 树上莫队 树上带修改莫队 那两个是明天要搞的 序列莫队原理这里，我们以2009年国家集训队题目《小Z的袜子》为例，进行对莫队算法的详解。这道题，我们首先很容易求出对于一个区间来说的答案，然后，我们还可以发现我们可以在$O(1)$的时间内根据当前区间$[l,r]$的答案求出$[l+1,r]$,$[l-1,r]$,$[l,r-1]$,$[l,r+1]$的答案（分别求出），于是这个时候我们就可以对询问进行适当的排序，然后用一些时间暴力转移，这就是本题的算法 这个时候，我们可以想到需要对查询区间进行排序，但如果直接按照$l$为第一关键字，$r$为第二关键字的方法，算法的效率将得不到保障，因为我们完全可以造出一组需要使转移时间非常大的数据。正宗的算法是采用曼哈顿距离最小生成树来达到减少低效转移的目的，然而曼哈顿距离最小生成树的代码复杂度很高，还需要使用线段树这样的数据结构来进行维护，为了简化这一过程，并保障效率，我们考虑分块方法 分块，我们按照$\sqrt{n}$为块的大小，将l即第一关键字进行分块，而r则不动，我们给l维护一个数组$pos[]$，表示l处于那一块中，然后对这个块的编号作为第一关键字进行排序（r不动），这样，我们可以得到一个相对高效的算法，它的时间复杂度为$O(n\sqrt{n})$，证明并不复杂 这样，我们就可以快乐地通过本题的数据啦 O(∩_∩)O哈哈~ 下面贴上《小Z的袜子》题面以及代码 [2009国家集训队]小Z的袜子(hose)时间限制: 2 Sec 内存限制: 256 MB 题目描述作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。 输入输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。 输出包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间$[L,R]$中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例） 样例输入6 41 2 3 3 3 22 61 33 51 6 样例输出2/50/11/14/15 提示【样例解释】询问1：共$\dbinom{5}{2}=10$种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为$(1+3)/10=4/10=2/5$。 询问2：共$\dbinom{3}{2}=3$种可能，无法抽到颜色相同的袜子，概率为$0/3=0/1$。 询问3：共$\dbinom{3}{2}=3$种可能，均为抽出两个3，概率为$3/3=1/1$。 注：上述$\dbinom{b}{a}$表示组合数，组合数$\dbinom{b}{a}$等价于在a个不同的物品中选取b个的选取方案数。 【数据规模和约定】30%的数据中 $N,M ≤ 5000$； 60%的数据中 $N,M ≤ 25000$； 100%的数据中 $N,M ≤ 50000，1 ≤ L &lt; R ≤ N，Ci ≤ N$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long long int #define maxn 50005using namespace std;struct task&#123; int l,r,id; LL a,b; task():l(0),r(0),id(0),a(0),b(0)&#123;&#125; task(int l,int r,int id):l(l),r(r),id(id),a(0),b(0)&#123;&#125;&#125;query[maxn];struct state&#123; int rec[maxn],len,l,r; state():len(0)&#123;memset(rec,0,sizeof(rec));&#125;&#125;now;int n,m,line[maxn],pos[maxn],blo,siz;void init()&#123; blo=(int)sqrt(n)+1; siz=n/blo; for(int i=0;i&lt;n;i++)&#123; pos[i]=i/blo; &#125;&#125;bool cmp1(task a,task b)&#123; if(pos[a.l]==pos[b.l])return a.r&lt;b.r; return pos[a.l]&lt;pos[b.l];&#125;bool cmp2(task a,task b)&#123; return a.id&lt;b.id;&#125;LL gcd(LL a,LL b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;void update(task &amp;o,int pos,int op)&#123; if(op==1)&#123; o.a+=2*now.rec[line[pos]]; o.b+=2*now.len; now.rec[line[pos]]++; now.len++; &#125;else&#123; o.a-=2*now.rec[line[pos]]-2; o.b-=2*now.len-2; now.rec[line[pos]]--; now.len--; &#125;&#125;void work()&#123; for(int i=query[0].l;i&lt;=query[0].r;i++)&#123; now.rec[line[i]]++; now.len++; &#125; now.l=query[0].l; now.r=query[0].r; LL sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=now.rec[i]*now.rec[i]; &#125; query[0].a=sum-now.len; query[0].b=now.len*now.len-now.len; for(int i=1;i&lt;m;i++)&#123; query[i].a=query[i-1].a; query[i].b=query[i-1].b; for(;now.r&lt;query[i].r;now.r++)&#123; update(query[i],now.r+1,1); &#125; for(;now.r&gt;query[i].r;now.r--)&#123; update(query[i],now.r,-1); &#125; for(;now.l&lt;query[i].l;now.l++)&#123; update(query[i],now.l,-1); &#125; for(;now.l&gt;query[i].l;now.l--)&#123; update(query[i],now.l-1,1); &#125; &#125; for(int i=0;i&lt;m;i++)&#123; LL d=gcd(max(query[i].a,query[i].b),min(query[i].a,query[i].b)); query[i].a/=d; query[i].b/=d; //if(query[i].a==0)query[i].b=1; &#125;&#125;int main()&#123; freopen("input.txt","r",stdin); freopen("output.txt","w",stdout); scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;line[i]); &#125; init(); int x,y; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); query[i]=task(x-1,y-1,i); &#125; sort(query,query+m,cmp1); work(); sort(query,query+m,cmp2); for(int i=0;i&lt;m;i++)&#123; printf("%lld/%lld\n",query[i].a,query[i].b); &#125; return 0;&#125; 上述代码即为本题AC代码，是不是与hzwer的代码很像？然而并不是 那么序列莫队就先到这里啦 序列带修改莫队下面我们来学习一下序列莫队的升级版——序列带修改莫队 意义这个该怎么搞呢？我们现在加入了一个修改的操作，让人联想起当年的CDQ分治，其实感觉上比较像，实际上并不像，这是为什么呢? CDQ分治实际上是对查询与修改操作的一个合理排序及分治，使得每个修改操作能够精确地对应到每一个查询操作上，而且因为它排序及分治的巧妙性，使得我们可以通过一些数据结构如Fenwick树（树状数组）来方便地进行维护，同时使得时间复杂度达到我们想要的结果 然而带修改序列莫队是怎么实现修改与操作的对应的呢？暴力，就是这样，我们每次通过对序列中修改与查询的分割，在查询之前把所有能够影响到它的操作暴力更新一下，其实说是暴力，其中也还是会有一些巧妙之处的 那么为什么我们还需要莫队算法呢？这是因为对于某些问题，我们可以发现使用常规的CDQ分治方法或者是数据结构嵌套的方法难以维护。究其本质，是因为在我们需要维护的信息之中又产生了隐性的一个维度，比如上题《小Z的袜子》，我们可以知道其中每种颜色袜子的个数也是一个需要考虑的维度，这便是一个新的维度 这可以概括为维护的区间信息中的离散的具体信息开始对整体答案产生影响的情况1. 因此在这时，线段树什么的就不管用了，而主席树中虽然也有这种具体化的信息（如每个元素的排名大小），但是它每次只是对其中单个元素的一种查询，可以类比为是对区间信息内部信息的单点查询 而采用莫队算法的题，往往需要一种对这样的信息的一种整体/全部查询，而且不能化为整体来考虑，这样就十分尴尬了，所以我们利用这种情况下产生的新的性质：相邻单个元素的更新复杂度为$O(1)$的性质，来进行“暴力更新” 这样我们就阐明了莫队算法的意义 原理接下来我们可以说一说原理 基本上来说，我们先把修改与查询分开处理，存入两个不同的数组中，同时使用两种结构体来进行保存，然后基本的方法与无修序列莫队基本相同，只是在处理修改的时候，我们判断一下这个修改是否在上次查询中有所作用，这个可以通过一个布尔数组来进行维护，然后我们就可以减掉原信息，加上修改后信息，然后继续更新即可，本质上并无什么太大的改变 下面贴上一道有关的题目《维护队列》 问题 D: 维护队列时间限制: 1 Sec 内存限制: 128 MB 题目描述你小时候玩过弹珠吗？小朋友A有一些弹珠，A喜欢把它们排成队列，从左到右编号为1到N。为了整个队列鲜艳美观，小朋友想知道某一段连续弹珠中，不同颜色的弹珠有多少。当然，A有时候会依据个人喜好，替换队列中某个弹珠的颜色。但是A还没有学过编程，且觉得头脑风暴太浪费脑力了，所以向你来寻求帮助。 输入输入文件第一行包含两个整数N和M。第二行N个整数，表示初始队列中弹珠的颜色。接下来M行，每行的形式为“Q L R”或“R x c”，“Q L R”表示A想知道从队列第L个弹珠到第R个弹珠中，一共有多少不同颜色的弹珠，“R x c”表示A把x位置上的弹珠换成了c颜色。 输出对于每个Q操作，输出一行表示询问结果。 样例输入2 31 2Q 1 2R 1 2Q 1 2 样例输出21 提示对于100%的数据，有$1 ≤ N ≤ 10000, 1 ≤ M ≤ 10000$，小朋友A不会修改超过1000次，所有颜色均用1到$10^6$的整数表示。 下面贴代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 1000005using namespace std;struct query&#123; int l,r,id,pre,ans; query():l(0),r(0),id(0),pre(0),ans(0)&#123;&#125; query(int l,int r,int id,int pre):l(l),r(r),id(id),pre(pre),ans(0)&#123;&#125;&#125;que[maxn];struct modify&#123; int pos,val,ori; modify():pos(0),val(0),ori(0)&#123;&#125; modify(int pos,int val,int ori):pos(pos),val(val),ori(ori)&#123;&#125;&#125;mod[maxn];int n,m,line[maxn],sline[maxn],if_in[maxn],pos[maxn],s[maxn],blo,siz,ans=0;void init()&#123; blo=(int)sqrt(n)+1; siz=n/blo; for(int i=0;i&lt;n;i++)&#123; pos[i]=i/blo; &#125;&#125;bool cmp1(query a,query b)&#123; if(pos[a.l]!=pos[b.l])return pos[a.l]&lt;pos[b.l]; else if(a.r!=b.r)return a.r&lt;b.r; else return a.pre&lt;b.pre;&#125;bool cmp2(query a,query b)&#123; return a.id&lt;b.id;&#125;void update(int p)&#123; if(if_in[p])&#123; s[line[p]]--; if(s[line[p]]==0)ans--; &#125; else&#123; if(s[line[p]]==0)ans++; s[line[p]]++; &#125; if_in[p]^=1;&#125;void change(int p,int val)&#123; if(if_in[p])&#123; update(p); line[p]=val; update(p); &#125;else line[p]=val;&#125;void work()&#123; int now=-1; for(int i=0,l=0,r=-1;i&lt;m;i++)&#123; for(;now&lt;que[i].pre;now++)change(mod[now+1].pos,mod[now+1].val); for(;now&gt;que[i].pre;now--)change(mod[now].pos,mod[now].ori); for(;r&lt;que[i].r;r++)update(r+1); for(;r&gt;que[i].r;r--)update(r); for(;l&lt;que[i].l;l++)update(l); for(;l&gt;que[i].l;l--)update(l-1); que[i].ans=ans; &#125;&#125;int main()&#123; /*freopen("input.txt","r",stdin); freopen("output.txt","w",stdout);*/ scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;line[i]); sline[i]=line[i]; &#125; init(); int x,y,tot=0,cnt=0; char ch[20]; for(int i=0;i&lt;m;i++)&#123; scanf("%s%d%d\n",ch,&amp;x,&amp;y); if(ch[0]=='Q')&#123; que[tot]=query(x-1,y-1,tot,cnt-1); tot++; &#125; else&#123; mod[cnt]=modify(x-1,y,sline[x-1]); sline[x-1]=y; cnt++; &#125; &#125; sort(que,que+tot,cmp1); work(); sort(que,que+tot,cmp2); for(int i=0;i&lt;tot;i++)&#123; printf("%d\n",que[i].ans); &#125; return 0;&#125; 再怎么说，今天搞掉了两道题，还是颇高兴的 那么，序列莫队的算法到此就比较圆满啦，完结撒花(^o^)/~ 1. 这句话可能不是那么容易理解，实际的意思是指我们在分析一般题目的时候，会发现我们可以很轻易地合并两个区间的信息，这个时候并不受内部元素/信息的干扰，而莫队类题目不能通过简单的区间信息合并来解决，这是因为它的具体信息对整体信息有干扰作用 &#8617;]]></content>
      <tags>
        <tag>分块法</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总II]]></title>
    <url>%2F2017%2F08%2F26%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBII%2F</url>
    <content type="text"><![CDATA[引言第二篇。。。 题解Problem 1207. -- [HNOI2004]打鼹鼠1207: [HNOI2004]打鼹鼠Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 3350&nbsp;&nbsp;Solved: 1610[Submit][Status][Discuss]Description鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿Q编写了一个打鼹鼠的游戏：在一个n*n的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为（i,j）的网格移向(i-1, j),(i+1, j),(i,j-1),(i,j+1)四个网格，机器人不能走出整个n*n的网格。游戏开始时，你可以自由选定机器人的初始位置。现在你知道在一段时间内，鼹鼠出现的时间和地点，希望你编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。Input第一行为n（n&lt;=1000）, m（m&lt;=10000），其中m表示在这一段时间内出现的鼹鼠的个数，接下来的m行每行有三个数据time,x,y表示有一只鼹鼠在游戏开始后time个时刻，在第x行第y个网格里出现了一只鼹鼠。Time按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。Output仅包含一个正整数，表示被打死鼹鼠的最大数目Sample Input 2 2 1 1 1 2 2 2 Sample Output 1HINT Source 题目分析第一眼看上去是个直接空间时间双爆的暴力DP，然而，我们发现我们无须记录当前机器人的位置，直接跑就行了。。。只需记录现在刚打完哪只鼹鼠即可，然后$O(m^2)$跑 (我一直觉得会超时。。。一定是我没学过复杂度。。。) 代码1234567891011121314151617181920212223242526272829303132#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 10005using namespace std;struct goal&#123; int x, y, t;&#125;save[maxn];int n, m;int dp[maxn];bool vis[maxn];int DP(int x)&#123; if(vis[x]) return dp[x]; vis[x] = 1; int&amp; ans = dp[x]; for (int i = x + 1; i &lt;= m; i++)&#123; if ((abs(save[x].x - save[i].x) + abs(save[x].y - save[i].y)) &lt;= save[i].t - save[x].t)&#123; ans = max(ans, DP(i)); &#125; &#125; return ++ans;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;save[i].t, &amp;save[i].x, &amp;save[i].y); &#125; int ans = 0; for (int i = 1; i &lt;= m; i++) ans = max(ans, DP(i)); printf("%d", ans); return 0;&#125; Problem 1513. -- [POI2006]Tet-Tetris 3D1513: [POI2006]Tet-Tetris 3DTime Limit: 30 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 1146&nbsp;&nbsp;Solved: 389[Submit][Status][Discuss]DescriptionTask: Tetris 3D “Tetris” 游戏的作者决定做一个新的游戏, 一个三维的版本, 在里面很多立方体落在平面板,一个立方体开始落下直到碰上一个以前落下的立方体或者落地即停止.作者想改变一下游戏的目的使得它更大众化,在新游戏中你将知道落下的立方体信息以及位置,你的任务就是回答所有立方体落下后最高的方块的高度.所有的立方体在下落过程中都是垂直的并且不会旋转.平板左下角坐标为原点,并且平行于坐标轴. Input第一行给出三个整数D, S and N (1]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ阶段性汇总I]]></title>
    <url>%2F2017%2F08%2F26%2FBZOJ%E9%98%B6%E6%AE%B5%E6%80%A7%E6%B1%87%E6%80%BBI%2F</url>
    <content type="text"><![CDATA[引言第一篇BZOJ题解出现啦！ 首篇致辞由于每道题都写题解太傻了，于是每十道题打包在一起进行总结发布，同时为了查找方便，将会再发布一篇文章用于记录所有已完成的题目同时附上一句话题解 题解Problem 1010. -- [HNOI2008]玩具装箱toy1010: [HNOI2008]玩具装箱toyTime Limit: 1 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 11256&nbsp;&nbsp;Solved: 4733[Submit][Status][Discuss]Description P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压 缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1...N的N件玩具，第i件玩具经过 压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容 器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一 个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究， 如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容 器，甚至超过L。但他希望费用最小.Input 第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7Output 输出最小费用Sample Input 5 4 3 4 2 1 4Sample Output 1HINT Source 题目分析 很显然是斜率优化DP，但是为了很好地解决这样的问题，以下面的代码为例，只要是斜率优化DP的题目，都可以封装斜率优化的部分，然后把细节的关于x和y以及系数，斜率，算出DP值的具体公式用宏定义的方法进行表达，这样更加具有可扩展性 注意下面代码对斜率优化的封装 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define X(x) ((double)x + sum[x])#define Y(x) ((double)dp[x] + X(x) * X(x))#define EFF(i) (2 * i + 2 * sum[i] - 2 - 2 * L)#define SLOPE(x, y) ((Y(y) - Y(x)) / (X(y) - X(x)))#define GET_DP(i, x) (dp[i] = dp[x] + (EFF(i) / 2 - X(x)) * (EFF(i) / 2 - X(x)))#define maxn 100005#define LL long long intusing namespace std;LL save[maxn];LL h, t;LL dp[maxn];LL sum[maxn];LL c[maxn];LL L;LL n;void work()&#123; h = t = 0; save[t++] = 0; for (LL i = 1; i &lt;= n; i++)&#123; while (t - h &gt; 1 &amp;&amp; SLOPE(save[h], save[h + 1]) &lt; EFF(i)) h++; GET_DP(i, save[h]); while (t - h &gt; 1 &amp;&amp; SLOPE(save[t - 1], i) &lt; SLOPE(save[t - 2], save[t - 1])) t--; save[t++] = i; &#125; printf("%lld", dp[n]);&#125;int main()&#123; scanf("%lld%lld", &amp;n, &amp;L); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]); for (LL i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + c[i]; work(); return 0;&#125; 中间那部分（work()）是完全不受题目影响的 Problem 1026. -- [SCOI2009]windy数1026: [SCOI2009]windy数Time Limit: 1 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 8087&nbsp;&nbsp;Solved: 3635[Submit][Status][Discuss]Description windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道， 在A和B之间，包括A和B，总共有多少个windy数？Input 包含两个整数，A B。Output 一个整数Sample Input 【输入样例一】 1 10 【输入样例二】 25 50Sample Output 【输出样例一】 9 【输出样例二】 20HINT 【数据规模和约定】 100%的数据，满足 1 &lt;= A &lt;= B &lt;= 2000000000 。Source 题目分析 简单的数位DP，不用维护当前数字是否已经脱离前导零部分，只需要在统计答案时分别统计每个长度的数字即可（具体见代码统计答案部分） 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 105using namespace std;int a, b;bool vis[maxn][maxn][2];int dp[maxn][maxn][2];int num[maxn];int cnt;int DP(int pos, int last, int op)&#123; if (pos == cnt) return 1; if (vis[pos][last][op]) return dp[pos][last][op]; vis[pos][last][op] = 1; int&amp; ans = dp[pos][last][op]; if (op)&#123; for (int i = last + 2; i &lt; num[pos]; i++) ans += DP(pos + 1, i, 0); for (int i = 0; i &lt; min(num[pos], last - 1); i++) ans += DP(pos + 1, i, 0); if (abs(num[pos] - last) &gt;= 2) ans += DP(pos + 1, num[pos], 1); &#125; else&#123; for (int i = last + 2; i &lt; 10; i++) ans += DP(pos + 1, i, 0); for (int i = 0; i &lt; last - 1; i++) ans += DP(pos + 1, i, 0); &#125; return ans;&#125;void get(int x)&#123; cnt = 0; while (x)&#123; num[cnt++] = x % 10; x /= 10; &#125; reverse(num, num + cnt);&#125;int main()&#123; scanf("%d%d", &amp;a, &amp;b); get(a - 1); int ans1 = 0; for (int i = 2; i &lt;= cnt; i++)&#123; for (int j = 1; j &lt; 10; j++) ans1 += DP(i, j, 0); &#125; for (int j = 1; j &lt; num[0]; j++) ans1 += DP(1, j, 0); ans1 += DP(1, num[0], 1); memset(vis, 0, sizeof(vis)); memset(dp, 0, sizeof(dp)); get(b); int ans2 = 0; for (int i = 2; i &lt;= cnt; i++)&#123; for (int j = 1; j &lt; 10; j++) ans2 += DP(i, j, 0); &#125; for (int j = 1; j &lt; num[0]; j++) ans2 += DP(1, j, 0); ans2 += DP(1, num[0], 1); printf("%d", ans2 - ans1); return 0;&#125; 多循环几下统计答案即可省去开始标记 Problem 1076. -- [SCOI2008]奖励关1076: [SCOI2008]奖励关Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 128 MBSubmit: 2581&nbsp;&nbsp;Solved: 1370[Submit][Status][Discuss]Description 你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物， 每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。 &nbsp;宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（ 这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi 分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过 一次，才能吃第i种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，Pi可 以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。 假设你 采取最优策略，平均情况你一共能在奖励关得到多少分值？Input 第一行为两个正整数k和n，即宝物的数量和种类。以下n行分别描述一种宝物，其中第一个整数代表分值，随 后的整数依次代表该宝物的各个前提宝物（各宝物编号为1到n），以0结尾。Output 输出一个实数，保留六位小数，即在最优策略下平均情况的得分。Sample Input 1 2 1 0 2 0Sample Output 1.500000HINT 【数据规模】 1&lt;=k&lt;=100,1&lt;=n&lt;=15，分值为[-10^6,10^6]内的整数。 Source 题目分析 简单的状压DP，其中最优策略的含义是让你在选和不选的DP值上取个MAX 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 105#define maxm (1 &lt;&lt; 16)using namespace std;double dp[maxn][maxm];bool vis[maxn][maxm];int pre[maxn];int n, m;int line[maxn];double DP(int pos, int op)&#123; if (pos == n + 1) return 0; if (vis[pos][op]) return dp[pos][op]; vis[pos][op] = 1; double&amp; ans = dp[pos][op]; for (int i = 1; i &lt;= m; i++)&#123; if((op | pre[i]) == op)&#123; ans += max(DP(pos + 1, op | (1 &lt;&lt; (i - 1))) + line[i], DP(pos + 1, op)) / m; &#125; else ans += DP(pos + 1, op) / m; &#125; return ans;&#125;int main()&#123; int x; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++)&#123; scanf("%d", &amp;line[i]); while (scanf("%d", &amp;x) == 1 &amp;&amp; x)&#123; pre[i] |= (1 &lt;&lt; (x - 1)); &#125; &#125; printf("%lf", DP(1, 0)); return 0;&#125; Problem 1087. -- [SCOI2005]互不侵犯King1087: [SCOI2005]互不侵犯KingTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 4250&nbsp;&nbsp;Solved: 2455[Submit][Status][Discuss]Description 在N&times;N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上 左下右上右下八个方向上附近的各一个格子，共8个格子。Input 只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）Output 方案数。Sample Input 3 2Sample Output 16HINT Source 题目分析 简单的状压DP。。。用DFS转移答案 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long int#define maxn 15#define maxk 225#define maxm 1024using namespace std;int n, k;LL dp[maxn][maxk][maxm];bool vis[maxn][maxk][maxm];LL DP(int pos, int rest, int op);void DFS(int now, int pos, int rest, int op, int _op, LL&amp; ans)&#123; if (now == n)&#123; ans += DP(pos + 1, rest, op); return; &#125; else&#123; int t = op, _t = _op; if (!((_op) &amp; (1 &lt;&lt; now)))&#123; if(now == 0) op |= (1 &lt;&lt; now), op |= (1 &lt;&lt; (now + 1)), _op |= (1 &lt;&lt; now), _op |= (1 &lt;&lt; (now + 1)); else if (now == n - 1) op |= (1 &lt;&lt; now), op |= (1 &lt;&lt; (now - 1)), _op |= (1 &lt;&lt; (now)), _op |= (1 &lt;&lt; (now - 1)); else op |= (1 &lt;&lt; now), op |= (1 &lt;&lt; (now - 1)), op |= (1 &lt;&lt; (now + 1)), _op |= (1 &lt;&lt; now), _op |= (1 &lt;&lt; (now - 1)), _op |= (1 &lt;&lt; (now + 1)); DFS(now + 1, pos, rest - 1, op, _op, ans); op = t, _op = _t; DFS(now + 1, pos, rest, op, _op, ans); &#125; else DFS(now + 1, pos, rest, op, _op, ans); &#125;&#125;LL DP(int pos, int rest, int op)&#123; if (rest == 0) return 1; if (rest &lt; 0 || pos == n) return 0; if (vis[pos][rest][op]) return dp[pos][rest][op]; vis[pos][rest][op] = 1; DFS(0, pos, rest, 0, op, dp[pos][rest][op]); return dp[pos][rest][op];&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); printf("%lld", DP(0, k, 0)); return 0;&#125; Problem 1096. -- [ZJOI2007]仓库建设1096: [ZJOI2007]仓库建设Time Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 5080&nbsp;&nbsp;Solved: 2261[Submit][Status][Discuss]Description L公司有N个工厂，由高到底分布在一座山上。如图所示，工厂1在山顶，工厂N在山脚。由于这座山处于高原内 陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L公司的总裁L先生接到气象 部门的电话，被告知三天之后将有一场暴雨，于是L先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于 地形的不同，在不同工厂建立仓库的费用可能是不同的。第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库 的费用是Ci。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于L公司产品的对外销售处设 置在山脚的工厂N，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的， 假设一件产品运送1个单位距离的费用是1。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到 以下数据：1：工厂i距离工厂1的距离Xi（其中X1=0）;2：工厂i目前已有成品数量Pi;:3：在工厂i建立仓库的费用 Ci;请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。Input 第一行包含一个整数N，表示工厂的个数。接下来N行每行包含两个整数Xi, Pi, Ci, 意义如题中所述。Output 仅包含一个整数，为可以找到最优方案的费用。Sample Input 3 0 5 10 5 3 100 9 6 10Sample Output 32HINT 在工厂1和工厂3建立仓库，建立费用为10+10=20，运输费用为(9-5)*3 = 12，总费用32。如果仅在工厂3建立仓库，建立费用为10，运输费用为(9-0)*5+(9-5)*3=57，总费用67，不如前者优。 【数据规模】 对于100%的数据， N &le;1000000。 所有的Xi, Pi, Ci均在32位带符号整数以内，保证中间计算结果不超过64位带符号整数。 Source 题目分析 斜率优化DP，注意DP的方向，要按照题目中给你的方向搞，不要自作聪明反过来，否则会很麻烦，因为山脚必须有仓库而山顶不一定。同时采用斜率优化DP模板化方法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define X(x) (num[x])#define Y(x) (dp[x] - s[x])#define EFF(i) (-dis[i])#define GET_DP(i, x) (dp[i] = dp[x] + s[i] - s[x] - (num[i] - num[x]) * dis[i] + cost[i])#define maxn 1000005#define LL long long intusing namespace std;LL dis[maxn];LL num[maxn];LL s[maxn];LL cost[maxn];LL n;LL dp[maxn];LL pre[maxn];deque&lt;LL&gt; save;void work()&#123; save.push_front(0); for (LL i = 1; i &lt;= n; i++)&#123; while (save.size() &gt; 1)&#123; LL op = save.back(); save.pop_back(); LL op2 = save.back(); if ((Y(op2) - Y(op)) &lt; (X(op2) - X(op)) * EFF(i)) continue; else&#123; save.push_back(op); break; &#125; &#125; LL x = save.back(); GET_DP(i, x); while (save.size() &gt; 1)&#123; int op = save.front(); save.pop_front(); int op2 = save.front(); if ((Y(i) - Y(op)) * (X(op) - X(op2)) &lt; (Y(op) - Y(op2)) * (X(i) - X(op))) continue; else&#123; save.push_front(op); break; &#125; &#125; save.push_front(i); &#125; printf("%lld", dp[n]);&#125;int main()&#123; scanf("%lld", &amp;n); for (LL i = 1; i &lt;= n; i++) scanf("%lld%lld%lld", &amp;dis[i], &amp;num[i], &amp;cost[i]); for (LL i = 1; i &lt;= n; i++) dis[i] = dis[n] - dis[i]; for (LL i = 1; i &lt;= n; i++) s[i] = s[i - 1] + num[i] * dis[i]; for (LL i = 1; i &lt;= n; i++) num[i] += num[i - 1]; work(); return 0;&#125; Problem 1103. -- [POI2007]大都市meg1103: [POI2007]大都市megTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 2703&nbsp;&nbsp;Solved: 1422[Submit][Status][Discuss]Description 在经济全球化浪潮的影响下,习惯于漫步在清晨的乡间小路的邮递员Blue Mary也开始骑着摩托车传递邮件了。 不过，她经常回忆起以前在乡间漫步的情景。昔日，乡下有依次编号为1..n的n个小村庄，某些村庄之间有一些双 向的土路。从每个村庄都恰好有一条路径到达村庄1（即比特堡）。并且，对于每个村庄，它到比特堡的路径恰好 只经过编号比它的编号小的村庄。另外，对于所有道路而言，它们都不在除村庄以外的其他地点相遇。在这个未开 化的地方，从来没有过高架桥和地下铁道。随着时间的推移，越来越多的土路被改造成了公路。至今，Blue Mary 还清晰地记得最后一条土路被改造为公路的情景。现在，这里已经没有土路了&mdash;&mdash;所有的路都成为了公路，而昔日 的村庄已经变成了一个大都市。 Blue Mary想起了在改造期间她送信的经历。她从比特堡出发，需要去某个村庄， 并且在两次送信经历的间隔期间,有某些土路被改造成了公路.现在Blue Mary需要你的帮助：计算出每次送信她需 要走过的土路数目。（对于公路，她可以骑摩托车；而对于土路，她就只好推车了。）Input 第一行是一个数n(1 &lt; = n &lt; = 2 50000).以下n-1行，每行两个整数a，b（1 &lt; =&nbsp; a以下一行包含一个整数m （1 &lt; = m &lt; = 2 50000），表示Blue Mary曾经在改造期间送过m次信。以下n+m-1行，每行有两种格式的若干信息 ，表示按时间先后发生过的n+m-1次事件:若这行为 A a b(a若这行为 W a, 则表示Blue Mary曾经从比特堡送信到 村庄a。Output 有m行，每行包含一个整数，表示对应的某次送信时经过的土路数目。Sample Input 5 1 2 1 3 1 4 4 5 4 W 5 A 1 4 W 5 A 4 5 W 5 W 2 A 1 2 A 1 3 Sample Output 2 1 0 1HINT Source 题目分析 好像是树剖的板子，但是为了学点东西，本题不用树剖，而是采用DFS序+数据结构（线段树/树状数组）的方法 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define lowbit(x) x &amp; -xusing namespace std;int n, m;int c[maxn];void add(int x, int v)&#123; while (x &lt;= n)&#123; c[x] += v; x += lowbit(x); &#125;&#125;int get(int x)&#123; int ans = 0; while (x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int cnt = 1, h[maxn];void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int d[maxn];int fa[maxn];int dfs[maxn];int idfs[maxn];int size[maxn];int ct;void DFS(int x)&#123; dfs[++ct] = x; idfs[x] = ct; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x]) continue; d[op] = d[x] + 1; fa[op] = x; DFS(op); size[x] += size[op]; &#125; size[x]++;&#125;void build(int x, int y)&#123; if (fa[x] == y) swap(x, y); int l = idfs[y], r = l + size[y]; add(l, 1), add(r, -1);&#125;void query(int x)&#123; printf("%d\n", d[x] - get(idfs[x]));&#125;int main()&#123; int x, y; scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); &#125; DFS(1); scanf("%d", &amp;m); char s[5]; for (int i = 0; i &lt; n + m - 1; i++)&#123; scanf("%s", s); if (s[0] == 'A')&#123; scanf("%d%d", &amp;x, &amp;y); build(x, y); &#125; else&#123; scanf("%d", &amp;x); query(x); &#125; &#125; return 0;&#125; Problem 1113. -- [Poi2008]海报PLA1113: [Poi2008]海报PLATime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 1171&nbsp;&nbsp;Solved: 793[Submit][Status][Discuss]DescriptionN个矩形,排成一排. 现在希望用尽量少的矩形海报Cover住它们.Input第一行给出数字N,代表有N个矩形.N在[1,250000] 下面N行,每行给出矩形的长与宽.其值在[1,1000000000]2 1/2 PosteringOutput最少数量的海报数.Sample Input 5 1 2 1 3 2 2 2 5 1 4 Sample Output 4 HINT Source 题目分析猜下结论，感性证明一下，然后直接单调栈扫一遍即可 代码12345678910111213141516171819202122#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; save;int main()&#123; int n, x; int ans = 0; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%*d%d", &amp;x); while (!save.empty() &amp;&amp; save.top() &gt; x) &#123; save.pop(); ans++; &#125; if (save.empty() || save.top() &lt; x) save.push(x); &#125; ans += save.size(); printf("%d", ans); return 0;&#125; Problem 1115. -- [POI2009]石子游戏Kam1115: [POI2009]石子游戏KamTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 1060&nbsp;&nbsp;Solved: 650[Submit][Status][Discuss]Description有N堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。Input第一行u表示数据组数。对于每组数据，第一行N表示石子堆数，第二行N个数ai表示第i堆石子的个数(a1&lt;=a2&lt;=&hellip;&hellip;&lt;=an)。 1&lt;=u&lt;=10 1&lt;=n&lt;=1000 0&lt;=ai&lt;=10000Outputu行，若先手必胜输出TAK，否则输出NIE。Sample Input 2 2 2 2 3 1 2 4Sample Output NIE TAKHINT 感谢MT大牛翻译.Source 题目分析Nim游戏变式，可以简单地转化为阶梯Nim问题，然后按照阶梯Nim的做法，把所有奇数号的堆的石子数异或在一起即可 代码123456789101112131415161718192021222324252627282930313233#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int T; scanf("%d", &amp;T); while (T--)&#123; int ans = 0; int n, x, y; scanf("%d", &amp;n); if (n &amp; 1)&#123; scanf("%d", &amp;ans); for (int i = 0; i &lt; n - 1; i += 2)&#123; scanf("%d%d", &amp;y, &amp;x); ans ^= x - y; &#125; if (ans) printf("TAK\n"); else printf("NIE\n"); &#125; else&#123; for (int i = 0; i &lt; n; i += 2)&#123; scanf("%d%d", &amp;y, &amp;x); ans ^= x - y; &#125; if (ans) printf("TAK\n"); else printf("NIE\n"); &#125; &#125; return 0;&#125; Problem 1116. -- [POI2008]CLO1116: [POI2008]CLOTime Limit: 10 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 1068&nbsp;&nbsp;Solved: 593[Submit][Status][Discuss]DescriptionByteotia城市有n个 towns m条双向roads. 每条 road 连接 两个不同的 towns ,没有重复的road. 你要把其中一些road变成单向边使得：每个town都有且只有一个入度Input第一行输入n m.1 &lt;= n&lt;= 100000,1 &lt;= m &lt;= 200000 下面M行用于描述M条边.OutputTAK或者NIE 常做POI的同学,应该知道这两个单词的了...Sample Input 4 5 1 2 2 3 1 3 3 4 1 4 Sample Output TAK 上图给出了一种连接方式.HINT Source 题目分析从度数最少的点开始逐个分析，如果它的度数仅是1，那么我们肯定需要用这条边当做它的入度，如果是0，那么无解，如果大于等于2，那么后面的一定可以成环，就直接跳出即可，本题无需网络流做法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define maxn 1000005using namespace std;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int cnt = 1, h[maxn];void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int deg[maxn];bool ex[maxn];struct cmp&#123; bool operator () (const int a, const int b) const&#123; return (deg[a] == deg[b]) ? a &lt; b : deg[a] &lt; deg[b]; &#125;&#125;;set&lt;int, cmp&gt; s;void work()&#123; while (!s.empty())&#123; int x = *(s.begin()); if (deg[x] == 0)&#123; printf("NIE\n"); return; &#125; if (deg[x] == 1)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (ex[op]) continue; s.erase(op); s.erase(x); deg[op]--; s.insert(op); ex[x] = 1; break; &#125; &#125; if (deg[x] &gt;= 2)&#123; printf("TAK\n"); return; &#125; &#125; printf("TAK\n");&#125;int main()&#123; int n, m, x, y; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(x, y); deg[x]++; deg[y]++; &#125; for (int i = 1; i &lt;= n; i++)&#123; s.insert(i); &#125; work(); return 0;&#125; Problem 1142. -- [POI2009]Tab1142: [POI2009]TabTime Limit: 40 Sec&nbsp;&nbsp;Memory Limit: 162 MBSubmit: 326&nbsp;&nbsp;Solved: 141[Submit][Status][Discuss]Description 2个n*m矩阵，保证同一个矩阵中元素两两不同。问能否通过若干次交换两行或交换两列把第一个矩阵变成第二 个。Input 第一行正整数 T (1&le;T&le;10) 表示数据组数. 每组数据包括：第一行n m （1&le;n,m&le;1000） 2个n行m列的整数 矩阵，元素绝对值均在10^6以内Output 每组数据输出&ldquo;TAK&rdquo;/&ldquo;NIE&rdquo;表示能/不能.Sample Input 2 4 3 1 2 3 4 5 6 7 8 9 10 11 12 11 10 12 8 7 9 5 4 6 2 1 3 2 2 1 2 3 4 5 6 7 8Sample Output TAK NIE HINT Source 鸣谢WangTianYi制作数据 题目分析我们发现一行或一列中有哪些元素是固定的，只是它们的顺序可变，那么我们只需要分别对两个矩阵的第一行排序，然后判断是否完全相同即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define LL long long int#define M 1000000007#define maxn 1005using namespace std;int n, m;int a[maxn][maxn];int b[maxn][maxn];int _a[maxn][maxn];int _b[maxn][maxn];int line[maxn];bool cmp(int i, int j)&#123; return b[0][i] &lt; b[0][j];&#125;bool cmp2(int i, int j)&#123; return a[0][i] &lt; a[0][j];&#125;set&lt;LL&gt; s;void work()&#123; int flag = -1; sort(_a[0], _a[0] + m); for (int i = 0; i &lt; n; i++)&#123; bool f = 1; sort(_b[i], _b[i] + m); for (int j = 0; j &lt; m; j++)&#123; if (_a[0][j] != _b[i][j])&#123; f = 0; break; &#125; &#125; if (f) &#123; flag = i; break; &#125; &#125; if (flag == -1)&#123; printf("NIE\n"); return; &#125; for (int j = 0; j &lt; m; j++) swap(b[0][j], b[flag][j]); for (int j = 0; j &lt; m; j++) line[j] = j; sort(line, line + m, cmp); for (int j = 0; j &lt; m; j++)&#123; for (int i = 0; i &lt; n; i++)&#123; _b[i][j] = b[i][line[j]]; &#125; &#125; for (int j = 0; j &lt; m; j++)&#123; for (int i = 0; i &lt; n; i++)&#123; b[i][j] = _b[i][j]; &#125; &#125; sort(line, line + m, cmp2); for (int j = 0; j &lt; m; j++)&#123; for (int i = 0; i &lt; n; i++)&#123; _a[i][j] = a[i][line[j]]; &#125; &#125; for (int j = 0; j &lt; m; j++)&#123; for (int i = 0; i &lt; n; i++)&#123; a[i][j] = _a[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++)&#123; LL has = 0; for (int j = 0; j &lt; m; j++)&#123; has = has * M + a[i][j]; &#125; s.insert(has); &#125; for (int i = 0; i &lt; n; i++)&#123; LL has = 0; for (int j = 0; j &lt; m; j++)&#123; has = has * M + b[i][j]; &#125; if (!s.count(has))&#123; printf("NIE\n"); return; &#125; &#125; printf("TAK\n"); s.clear();&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--)&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; scanf("%d", &amp;a[i][j]); _a[i][j] = a[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; scanf("%d", &amp;b[i][j]); _b[i][j] = b[i][j]; &#125; &#125; work(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ题解目录]]></title>
    <url>%2F2017%2F08%2F26%2FBZOJ%E9%A2%98%E8%A7%A3%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[引言BZOJ的题解目录 题目目录及一句话题解汇总为了给人以思考的空间，一句话题解使用白色字体 题解目录 BZOJ阶段性汇总I 1010: [HNOI2008]玩具装箱toy 斜率优化DP 1026: [SCOI2009]windy数 数位DP 1076: [SCOI2008]奖励关 状压DP 1087: [SCOI2005]互不侵犯King 状压DP 1096: [ZJOI2007]仓库建设 斜率优化DP 1103: [POI2007]大都市meg DFS序+数据结构维护 1113: [Poi2008]海报PLA 单调栈 1115: [POI2009]石子游戏Kam 阶梯Nim 1116: [POI2008]CLO 最小情形分析 1142: [POI2009]Tab 思维题+理解题意 BZOJ阶段性汇总II 1207: [HNOI2004]打鼹鼠 简单DP 1513: [POI2006]Tet-Tetris 3D 树套树+标记永久化 2333: [SCOI2011]棘手的操作 可并堆/本人发明的双平衡树 2456: mode 绝对众数问题（抵消法） 2565: 最长双回文串 Manacher 2916: [Poi1997]Monochromatic Triangles 组合题+取反（数学思维） 3038: 上帝造题的七分钟2 平摊分析线段树 3209: 花神的数论题 数位DP 3358: [Usaco2004 Jan]洪水 二分答案 3366: [Usaco2004 Feb]Breeding 奶牛饲育 递归 BZOJ阶段性汇总III 4726: [POI2017]Sabota? 二分答案/树型DP 3004: 吊灯 思维题/结论题 2662: [BeiJing wc2012]冻结 图论拆点/边法 4723: [POI2017]Flappy Bird 思维题+前缀和 4724: [POI2017]Podzielno 数论+思维题 4407: 于神之怒加强版 莫比乌斯反演套路题 1922: [Sdoi2010]大陆争霸 带限制最短路+SPFA与Dijkstra的具体算法思想分析 1168: [Baltic2008]Gloves 数学推导+单调栈+乱搞 1340: [Baltic2007]Escape逃跑问题 网络流最小割模型 1256: Baltic2004Rectangles 射线法（映射法）+线段树 BZOJ阶段性汇总IV 1339: [Baltic2008]Mafia 网络流最小割模型 3944: Sum 卡常杜教筛 5015: [Snoi2017]礼物 数学推导+递归 5029: 贴小广告 线段树/逆向处理思想 5018: [Snoi2017]英雄联盟 二分答案+背包DP 1778: [Usaco2010 Hol]Dotp 驱逐猪猡 概率与期望+图论中的高斯消元 1419: Red is good 概率与期望+最优值含义 3270: 博物馆 概率与期望+图论中的高斯消元 4551: [Tjoi2016&amp;Heoi2016]树 特殊技巧（01染色）+树链剖分+线段树二分 3300: [USACO2011 Feb]Best Parenthesis 模拟操作 BZOJ阶段性汇总V 3400: [Usaco2009 Mar]Cow Frisbee Team 奶牛沙盘队 简单DP 4817: [Sdoi2017]树点涂色 LCT+思维题 3732: Network 生成树提取+树上LCA 3702: 二叉树 线段树合并 3669: [Noi2014]魔法森林 动点SPFA（正解LCT） 3629: [JLOI2014]聪明的燕姿 DFS搜索质因子 4552: [Tjoi2016&amp;Heoi2016]排序 思维题+二分答案（正解线段树合并） 4281: [ONTAK2015]Związek Harcerstwa Bajtockiego 树上LCA 3670: [Noi2014]动物园 KMP思维题 3530: [Sdoi2014]数数 AC自动机+数位DP+分类讨论 BZOJ阶段性汇总VI 3697: 采药人的路径 点分治+分类讨论 3626: [LNOI2014]LCA 特殊技巧（01染色）+定序思想+询问拆分+树链剖分 3381: [Usaco2004 Open]Cave Cows 2 洞穴里的牛之二 辣鸡RMQ模板 4146: [AMPPZ2014]Divisors 枚举+调和级数定理 4390: [Usaco2015 dec]Max Flow 树链剖分/树上差分 4896: [Thu Summer Camp2016]补退选 可持久化Trie+二分答案 4757: [Usaco2017 Jan]Building a Tall Barn 数学推导+二分答案+乱搞 3211: 花神游历各国 平摊分析线段树 1856: [Scoi2010]字符串 组合数学+Catalan+数形结合思想 3993: [SDOI2015]星际战争 二分答案+最大流模型+精度误差]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>题解目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017百度之星复赛参赛总结]]></title>
    <url>%2F2017%2F08%2F18%2F2017%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%A4%8D%E8%B5%9B%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言很显然，因为我进不了决赛所以只能在这里写一下复赛的参赛感想，我真是太弱了。。。 总结感觉这次其实考的很不好，首先是其中一场初赛才考了248名，实际上是很差的，然后就是这次复赛，排名仅仅为380，虽说一副有T恤的样子，但却从内心感到了更大的挫败感，这次dyh大神直接AK虐全场，好像只用了一小时四十分钟就全做完了，而我一小时四分钟的时候做的第二道题刚过。。。（一共有六道题） 自己想了想，大致有如下几点原因吧： 根本原因：水平不够，能力不足 主观因素：不够细心，程序总是有各种漏洞，导致调试程序时间过多，分数随之降低许多，这一点，从今以后要特别注意 客观因素：自己参加这种$Codeforces$赛制的比赛还比较少，未形成固定的解题策略，总是手忙脚乱，心神不宁，导致程序错误百出，还检查不出来 其实我最想说的，就是我发现我自己总是把时间太多地浪费在调试程序上，我不明白为什么我的程序会有许多的错误，而且常常是一些十分隐蔽的小型错误，虽然最后提交上去以后基本没有什么问题，但是在本地测试的时候总是会出现各种各样的错误 我觉得，这是OI赛制所带来的弊端。OI限定时间，比赛结束后再统一测评，每个人都有充足的时间思考题目，调试程序，最后按照大家通过测试点的数目给出部分分。这样的赛制，使我们变得怠惰，因把握充足的时间，而失去了对时间的敏感性。而CF赛制下的比赛，每一秒钟，都在决定你的最终排名，你只有在所有的方面，比如思考，编写程序，调试程序这些步骤上，全都尽可能地加快自己的速度，同时保证自己的准确度，才能超越对手，获得胜利 所以，通过这些对比和分析，我们可以发现，其实CF赛制是一种考察面更广，难度更大的赛制，可以说，CF赛制才真正地考量选手的综合实力 通过这样的比赛，我也发现我个人的代码准确度实在有待提高。专注，坚持，细致，我希望未来的我，能够真正地拥有这三种宝贵的行为财富]]></content>
      <tags>
        <tag>百度之星</tag>
        <tag>参赛总结</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Catalan数详解]]></title>
    <url>%2F2017%2F08%2F17%2FCatalan%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言翻以前的老文章突然看到这一篇，感觉不错所以放到博客上。。。 Catalan数详解最近突然发现我学了假的Catalan数，居然还有那么多我不知道的东西，下面简单地介绍一下： 定义这个应该都知道吧，就是这样的一个数列： f(0)=1,f(1)=1,f(n)=\sum_{i=0}^{n-1}f(i)*f(n-1-i)前几项大概是这样的：$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, \cdots$ 这个东西看起来没什么用，实际上有许多的问题与模型内部都蕴含着Catalan的思想方法，下面简单地对模型进行一下归纳： 常见模型合法括号序列数有一个长为$2n$的括号序列，其中合法的序列个数为多少？（注：合法的括号序列指的是前后括号完全匹配的序列） 分析大概是这样的，对于一个括号序列，它可以用比它短的括号序列递推地求出来，考虑到序列的可拼接性，我们可以将两个较短的括号序列拼在一起，形成这个较长的序列，但是，我们很容易发现，这样做会产生许多的重复的序列，我们并不想看到这样的事情发生，所以我们需要想一个去除重复序列的方法 我们可以考虑一种特殊的性质，非对称性，我们可以将其中一侧进行处理，使得无论如何左半部分都不会与右半部分相同，这样就完美的解决了问题，所以，我们可以为左半部分套上一对括号，即这个样子：(\mbox{ }f(i)\mbox{ })\mbox{ }f(n-1-i)很容易发现这样一定是正确的 注意这个模型很重要，我们会在后面反复地进行使用 多边形的三角剖分方案数给一个凸的$n$多边形，将它进行三角剖分的方案数有多少？（这个应该很好理解） 分析其实这道题就是在多边形内连对角线进行分割，由于分割完后的两半部分具有很明显的独立性，所以我们可以递推求解，很容易知道这种递推关系满足Catalan数，因为两边子问题的大小的和为$n-1$，这应该很好理解 总结归纳为什么上面只选择了这两个模型进行预先说明呢？这是因为这两种模型是许多问题的基础，而且这两个模型分别代表了两种类型，这两种类型的相互转化并不很容易，所以特别进行了分类 下面对应地给出上面两种模型所代表的类型： 类型括号序列型括号序列，可以看做是一个01序列，序列中0与1的数量相同，而且任何位置以及它之前的位置中的1的数量都不超过0的数量。当问题可以转化为这种形式时，它就可以类比上面方法求解 三角剖分型这种问题的显著特征是，它的子问题之间的独立性十分明显，可以通过对两边的方案进行直接的乘法原理得出答案，这种类型可以使用三角剖分的思想进行求解 更多问题讲解了这么多，下面加入一些题目进行体会练习，请读者自行思考 出栈次序问题一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?（本题有两种思考方式，一种不具有推广性，但思维巧妙，另一种则是使用上述转化的方法） 买票找零问题有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？ 寻路问题一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 航线分配问题在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？ BST问题给定N个节点，能构成多少种不同的二叉搜索树？ 矩阵连乘问题$P=a_1×a_2×a_3×\cdots×a_n$，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？ 结束语如果你都思考出来了，那么你对Catalan的理解已经足够了，今天的讲解就先到此位置啦，ヾ(￣▽￣)Bye~Bye~]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>Catalan数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT,NTT,FWT详解]]></title>
    <url>%2F2017%2F08%2F16%2FFFT-NTT-FWT%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言最近集中攻略了一下数学内容，感觉对FFT,NTT,FWT这三种变换有了新的理解与感受，所以用这篇文章来分享最近新的收获那么还是按照标题的顺序逐个予以讲解 快速傅里叶变换(FFT)总述这种变化十分重要，不仅仅是在信息学竞赛上，这个算法曾被称为二十世纪最伟大的发明之一，由此，它的重要性可见一斑。下面，我们就要解开这个算法的神秘面纱，考虑到它的难度，本文讲解着力于使概念清晰易懂（当然，前提是你已经熟练掌握了前置技能，因为如果再加上前置技能的讲解，本文的篇幅就太长了），深入浅出，避免知其然而不知其所以然的常见学习问题，那么，这就开始吧！ 前置技能高中数学的复数相关知识以及基础的线性代数知识（矩阵运算及逆矩阵） 讲解我们采用这样的记号：$\xi_k^i$，来表示$n$次单位根的$k$次方，其中$\xi_k^0 = 1$那么，大家应该都学过复数（就是没学过是不是也听说过一些呢），复数里面的单位根有些比较优美的性质，就是这两个： \xi_n^{k + \frac{n}{2}} =- \xi_n^{k} \xi_n^{2k} = \xi_{\frac{n}{2}}^k应该是挺显然的，放在复平面上一眼就看得出来 然后，我们需要知道的是，原本DFT的时间复杂度是$O(n ^ 2)$的，就是采用$O(n)$个不同的点($x$值)，代入到多项式中，求出点值，这样就是离散傅里叶变换，就是把多项式从系数表达转向点值表达的过程 那么，FFT是如何做到在$O(n \log n)$时间内就求出$O(n)$个点的点值的呢？原因就在于，它利用了复数单位根的性质，而且必须是一个$2$的整数次幂的单位根，才能很好地实现快速运算 具体的实现方法，很显然就是要使用上面刚介绍过的两个性质，我们可以考虑这样的计算式: f(x)= a_0x^0+a_1x^1+a_2x^2+\cdots + a_{n -1}x^{n - 1}我们此时把某个单位根代入，则有: f({\xi_n^k})= a_0{(\xi_n^k)}^0+a_1{(\xi_n^k)}^1+a_2{(\xi_n^k)}^2+\cdots + a_{n -1}{(\xi_n^k)}^{n - 1}由单位根的定义及运算，我们可以得到： f({\xi_n^k})= a_0\xi_n^{0}+a_1\xi_n^{k}+a_2\xi_n^{2k}+\cdots + a_{n -1}\xi_n^{(n - 1)k}这时，我们进行蝴蝶操作，同时结合上面提到的第二条性质，可以得到： f({\xi_n^k})= (a_0\xi_{\frac{n}{2}}^{0}+a_2\xi_{\frac{n}{2}}^{k}+\cdots +a_{n - 2}\xi_{\frac{n}{2}}^{\frac{(n -2)k}{2}})+ \xi_n ^ k * (a_1\xi_{\frac{n}{2}}^{0}+a_3\xi_{\frac{n}{2}}^{k}+\cdots +a_{n - 1}\xi_{\frac{n}{2}}^{\frac{(n -2)k}{2}} )我们观察式子的这两个部分。可以发现，左右两部分就是与原问题本质相同，但规模仅为原问题一半的递归子问题（因为相当于对左右两部分分别代入了$\xi_{\frac{n}{2}}^{k}$继续进行计算），这样我们就可以通过递归来进行求解 但是，如果你在计算的时候，是把每一个点都这样直接代入计算的话，复杂度并没有什么变化，仍然是$O(n^2)$，还会因为递归而变慢，显然FFT不是这样处理的 那么我们该怎么办呢？我们考虑同时计算这$O(n)$个点的点值，在合并的时候，少计算一些点，利用性质直接运算得出某个点的点值，这样不就可以节约很多的时间了吗？我们继续考虑上面的式子，假设递归返回到这一步的时候（注意，如果这样说的话那么式子中的$n$就不一定是原序列的长度了，而有可能是它的子序列的长度），对于上个式子中的两个部分，我们已经分别求出了$\xi_\frac{n}{2}^{ik}(i = 0,1,2,\cdots ,\frac{n - 2}{2})$这些点对应的点值，那么，我们要思考的就是如何把这些点值在这一层合并在一起 我们可以发现，对于$k = 0,1,2,\cdots ,\frac{n - 2}{2}$，我们只需要直接合并就可以了（$左 +\xi_n ^ k * 右$） 而对于$k = \frac{n}{2},\frac{n}{2} + 1,\frac{n}{2} + 2,\cdots , n - 1$，在左右两边已经求出的点值的点集中，似乎并没有，这应该很显然，左右只有$\frac{n}{2}$个点的点值 那么我们该怎么办呢？考虑上面的两个性质中的第一条，可以知道对于$k = \frac{n}{2},\frac{n}{2} + 1,\frac{n}{2} + 2,\cdots , n - 1$，有$\xi_{n}^{k}= -{\xi_{n}^{k - \frac{n}{2}}}$，这样，我们只要在右边添一个负号，就可以像上面一样直接合并了，因为此时$k$相当于被限定在了$0,1,2,\cdots ,\frac{n - 2}{2}$这个范围中，而左右两边式子里面的指数都是偶数，所以负号就被和谐掉了，只有外边单独提出来的那个单位根$\xi_n^k$产生了一个负号，所以在右边直接添上即可直接合并（$左 -{\xi_{n}^{k - \frac{n}{2}}} * 右$） 这样，我们每次需要$O(n)$的时间进行合并，一共只会进行$O(\log n)$次这样的合并，所以复杂度为$O(n \log n)$ 那么我们现在就是以很高的效率求出了点值，对于多项式卷积，我们就可以对每个点都对应地进行两个点值的相乘，得到了新的点值表达的多项式，然而我们并不喜欢点值表达的多项式，所以我们需要IDFT，即逆离散傅里叶变换，当然，你要是暴力求的话，就是高斯消元解方程的复杂度，前面的工作就都变得毫无意义了，很明显，我们需要$O(n \log n)$复杂度的逆算法，即IFFT，逆快速傅里叶变换 怎么做呢？我们考虑刚才都做了什么，我们先构造一个系数矩阵： A= \begin{bmatrix} {\xi_n^{0}}&{\xi_n^{0}}&{\xi_n^{0}}&\cdots &{\xi_n^{0}}\\ {\xi_n^{0}}&{\xi_n^{1}}&{\xi_n^{2}}&\cdots &{\xi_n^{n - 1}}\\ \xi_n^{0}&{\xi_n^{2}}&{\xi_n^{4}}&\cdots &{\xi_n^{2*(n - 1)}}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ \xi_n^{0}&\xi_n^{n - 1}&\xi_n^{2*(n - 1)}&\cdots&\xi_n^{(n - 1)^2} \end{bmatrix}然后我们做的事情可以用下面的式子来表达： \begin{bmatrix} a_0 & a_1 & a_2 & \cdots& a_{n - 1} \end{bmatrix} * A = \begin{bmatrix} f(\xi_n^0) & f(\xi_n^1) & f(\xi_n^2) & \cdots& f(\xi_n^{n - 1}) \end{bmatrix}那么，我们现在要做的，就是乘一个逆矩阵，这个逆矩阵即为中间的那一堆复数形成的矩阵的逆矩阵，而这个逆矩阵即为： A^{-1}= \frac{1}{n} * \begin{bmatrix} {\xi_n^{0}}&{\xi_n^{0}}&{\xi_n^{0}}&\cdots &{\xi_n^{0}}\\ {-\xi_n^{0}}&{-\xi_n^{1}}&{-\xi_n^{2}}&\cdots &{-\xi_n^{n - 1}}\\ \xi_n^{0}&{\xi_n^{2}}&{\xi_n^{4}}&\cdots &{\xi_n^{2*(n - 1)}}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ -\xi_n^{0}&-\xi_n^{n - 1}&-\xi_n^{2*(n - 1)}&\cdots&-\xi_n^{(n - 1)^2} \end{bmatrix}我就不说明为什么是这样了，自学线代吧 那么，乘上这个矩阵后，上面的式子就化为： \begin{bmatrix} a_0 & a_1 & a_2 & \cdots& a_{n - 1} \end{bmatrix} = \begin{bmatrix} f(\xi_n^0) & f(\xi_n^1) & f(\xi_n^2) & \cdots& f(\xi_n^{n - 1}) \end{bmatrix}*A^{-1}这样看来，正逆变换的本质也是相同的，我们更深入的观察，这就是一个反演的优美例子，所以FFT大概就是这些内容，有没有理解呢？ （其实非常简单，理解起来应该几乎没有任何难度吧。。。）当然，前提是文章写的好 下面提供一份代码，为了增进理解，在代码中的关键部分都标出了上面讲解在代码中的对应部分： 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef struct complex&#123; double r, i; complex(double r, double i) : r(r), i(i)&#123;&#125; complex()&#123;&#125;&#125;com;com operator + (com a, com b)&#123; return com(a.r + b.r, a.i + b.i);&#125;com operator - (com a, com b)&#123; return com(a.r - b.r, a.i - b.i);&#125;com operator * (com a, com b)&#123; return com(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);&#125;com operator / (com a, int k)&#123; return com(a.r / k, a.i / k);&#125;com ex(double x)&#123; return com(cos(x), sin(x));&#125;int rev[maxn];void init(int bit)&#123; for (int i = 1; i &lt; (1 &lt;&lt; bit); i++)&#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1));//蝴蝶操作需要的预处理，可以自己打出来看看是什么 &#125;&#125;void FFT(com* a, int n, int dft)&#123; for (int i = 0; i &lt; n; i++) if (i &gt; rev[i]) swap(a[i], a[rev[i]]);//蝴蝶操作预处理 for (int step = 1; step &lt; n; step &lt;&lt;= 1)&#123;//枚举层数，一开始为最低层 com wn = ex(pi * dft / step);//当前层的单位根，逆变换需要带负号 for (int i = 0; i &lt; n; i += step &lt;&lt; 1)&#123;//对应一个式子，step &lt;&lt; 1 即包含了这个式子的左半部分与右半部分 com wnk = com(1, 0);//当前合并到的点 for (int j = i; j &lt; i + step; j++)&#123;//当前处理到的点所对应点值数组的位置 com x = a[j]; com y = wnk * a[j + step];//这两个就是左右两个部分式子分别对应的点值 a[j] = x + y; a[j + step] = x - y;//这就是对左右两边的点值的合并 wnk = wnk * wn;//处理下一个点 &#125; &#125; &#125; if (dft == -1) for (int i = 0; i &lt; n; i++) a[i] = a[i] / n;//逆变换最后需要除以n&#125; 数论快速变换(NTT)前置技能初等数论（原根相关理论） 讲解其实和FFT是完全相同的，可以说毫无差别。。。只是把复数体系换为了数论上的原根体系，而且那两个重要的性质仍然成立 所以这需要取模的数必须形如$k * 2^\alpha + 1$，其中$k$与$\alpha$均为整数，且$k$为奇数，这样结合费马小定理与原根理论就可以和复数体系完全对应，推导过程也完全相同，故本处不再赘述 简单介绍一下原根？凑凑篇幅 就是对于一个数$\xi$，如果最小的满足$\xi^k \equiv 1$（在模$P$意义下）的$k$等于$p-1$，那么这个数$\xi$就被称为模$P$意义下的原根 怎么样，是不是很绕啊，那个$P$就是上文提到的，形如$k * 2^\alpha + 1$的质数，它是作为模数出现的 这样的话，仔细想想应该就能发现它和复数体系的本质相同之处了 模板留坑待补。。。 快速沃尔什变换(FWT)总述虽然这几个变换都有着相同的前缀和后缀，但是FWT的思想与前面两个并不相同，我们需要立足于位运算的本身特性来理解FWT，相对于FFT来说，FFT求的是多项式的卷积，而FWT则是位运算卷积，前面的多项式的点值求法应该很好理解，但是到了FWT，我们就要稍稍动一下脑筋了（虽然它们的处理过程是相同的，都是先转为点值表达，然后相乘，再由点值表达转回系数表达），与其说这是点值表达，不如说成是将两个数列中有相同特征的元素，聚到符合条件的下标$i$上，形成许多元素的集合，然后我们对应地把相同下标下的两个不同集合的元素做乘积（两个不同集合，指的是一个集合的元素来自于数列${a_i}$，另一个来源于数列${b_i}$），然后再把新的元素集合中的元素回归到新数列$${c_i}$中（此处如果看不懂可以跳过） 基本概念 对应位置：指在当前的合并过程中，左半部分与右半部分相对各自的起始位置距离相同的位置 当前位：指当前正在合并的二进制位（注意，当前被合并的子树中还不存在当前位） 操作法则：指合并过程中的左右转移情况 对于其他的概念，可能不是很常用，如果遇到可联系上下文进行体会 讲解我们考虑这样的一个问题： 给定两个数列${a_i}$与${b_i}$，我们现在要求一个数列${c_i}$，它的计算方式如下： c_i = \sum_{j \oplus k = i}a_j * b_k其中$\oplus$是任意的一个位运算符 这个问题就是FWT的经典问题，被称作位运算卷积，由于位运算的多样性，我们对位运算进行逐个考虑 与运算和或运算的FWT根据开头的总述所言，我们现在要做的就是找出这两种位运算的点值表达，下面我们以或运算为例进行讲解： 如果我们求出了两个式子分别的点值表达，我们就需要把对应地它们乘在一起，这说明，对应的两个点值表达里面所包含的元素，如果我们在两个点值表达里面分别任选一个，那么这两个元素的组合一定是合法的组合，换句话说，就是把这两个点值表达看作是二分图，我们如果直接乘起来，相当于把二分图中所有能连的边都连了，而每条连边代表一个卷积项$a_j * b_k$的选择方案，所以这告诉我们，这两部分元素的任意组合都是合法的（根据总述的理解） 那么，提到那么多次的“元素的集合”究竟是什么样子的呢？ 我们再考虑一个经典问题：给定一个数列${a_i}$，我们要求数列${b_i}$，计算方式如下： b_i = \sum_{(j|i) = i}a_j其中$|$表示或运算 下面讲解求解这类问题的按位合并方法，这个十分重要，在几乎所有的FWT计算中都需要用到，所以请务必理解这样的计算过程 根据位运算的位独立性，我们递归地考虑问题，假设我们现在从最低位开始，类比FFT的计算过程，就是这个样子的然后我们考虑按位合并，在兄弟结点之间，左边的表示当前位为0，右边的表示当前位为1，那么，如何合并呢？我们定义一下结点表示什么，在当前层未进行合并时，结点上的数表示已经从自己的子树中拥有的所有$a_j$合并出来了答案，即从里面筛选出来了满足$(j|i)=i$的$j$，并把这样的$a_j$的值加入到了结点表示的答案中所得到的最终答案 而在当前层合并完以后，我们就要把这样的值向上传递，他们就不在原来的位置了，而到了新位置后，又成为了当前层未进行合并的结点，所以无需定义当前层的已合并结点 具体的合并方法是什么呢？我们这样想，如果一个$a_j$可以被算到左边结点的答案里，而左边结点当前位又是0，所以$j$的当前位一定是0，那么，我们把它们加到右边结点中，仍然满足$(j|i)=i$的性质，所以我们的合并过程就是，左边不变，把左边对应位置逐个加到右边的对应位置上，而左边显然无法继续添加上什么了 注意，每个结点不止表示一个$b_i$，而是表示许多这样的$b_i$，且同一层节点表示的$b_i$数量相同，不同层的不同，且相邻两层表示的数量，上面层是下面层的二倍（因为发生了合并） 于是就变成了这个样子： 我们继续向上合并，可以得到这样的东西：注意理解对应位置的含义，对应位置这个概念很重要，会用在几乎所有的推导中，在FFT里面忘了说了。。。 这样应该能理解了吧，如果还不懂，就结合讲解与操作过程图相互照应地看即可 这样，根节点只有一个，所以我们不需要再合并了，根节点对应的数列，就是我们想要的数列${b_i}$ 我们概括地说，在这个问题中，我们的操作法则为$左=左，右=左+右$，为了方便，我们称这个问题是或运算FWT的求点值过程，简称或FWT 以后，我们对于一个问题，只写出它的操作法则，就不会再详细地重现上面合并的过程了 回到原来的思路上，我们求出了这样的数列${b_i}$，那么它究竟有什么用呢？其实，数列${b_i}$就是我上文所说的“元素的集合”，它相当于有许多个集合，每个集合里面都聚集了一些符合条件($(j|i)=i$)的$a_j$，也就是总述里“将数列中有相同特征的元素，聚到符合条件的下标$i$上，形成许多元素的集合”，仔细想想，是不是这样的？ 然后，我们还有一个式子，证明应该很容易，但是想要独立想到。。。 (j|i)=i,(k|i)=i\leftrightarrow ((j|k)|i)=i这个命题是充分必要的，证明直接联系或运算定义即可 这样，再回到更远的思路上来，我们在解决或运算FWT，我们分别对给定的两个数列${a_i}$与${b_i}$，像上文一样进行或FWT操作，求出新的数列${a’_i}$与${b’_i}$，然后对应位置直接相乘，这就是总述里面说的“将两个数列中有相同特征的元素，聚到符合条件的下标$i$上，形成许多元素的集合，然后我们对应地把相同下标下的两个不同集合的元素做乘积” 所以，我们相当于得到了一个数列${c’_i}$，即${c_i}$做或FWT的结果，我们要求${c_i}$，那么就要把这个过程逆过来，即总述里面的“把新的元素集合中的元素回归到新数列中” 我们成这个过程为或IFWT（逆FWT），即或运算的求系数过程 那么，现在正变换已经讲完了，逆变换还不会？这里面不需要线性代数的那一套东西，因为我们就是像上文一样的操作的，所以我们直接把操作逆过来即可，操作法则：$左=左，右=右-左$ 根据神TM的位运算的位独立性，在IFWT中，我们无论是先递归，再处理当前位，还是反过来都没有关系，因为位与位之间互不影响（其实我觉得不是这样理解的。。。自己用四个数试一试应该就能发现了） 显然你FWT就需要先递归再处理当前位，否则你当前位上什么都没有合并个×啊。。。 那么，这就是或运算FWT的整个过程，思路是不是非常巧妙啊？ 对于与运算的FWT，和或运算的完全相同，把所有的或运算符替换为与运算符即可，与FWT操作法则：$左=左+右，右=右$，与IFWT操作法则：$左=左-右，右=右$ 异或运算的FWT为什么要单独把异或拎出来裱呢？因为这种运算和上面的两个不太相同，思考，如果我们还是用与上面完全相同的正变换过程（(j|i)=i,(k|i)=i\leftrightarrow ((j|k)|i)=i），就会出现非常尴尬的事，每个元素的集合中只有一个数，且都是相同的$a_0$，这样就毫无意义了 我们需要新的正变换方法，下面的这个构造就非常神奇了： 我们再考虑一个经典问题：给定一个数列${a_i}$，我们要求数列${b_i}$，计算方式如下： b_i = \left(\sum_{(bitcount(i\&j)\&1)= 0}a_j\right)- \left(\sum_{(bitcount(i\&j)\&1)= 1}a_j\right)其中$bitcount(x)$表示$x$的二进制表示中1的个数 柿子应该能看懂吧。。。其实就是考虑$bitcount$的奇偶性。。。 我们还是像上文那样进行合并操作，考虑当前位，这时所有左结点的子树中的$j$和$i$的当前位都是0，右结点的子树中的$j$和$i$的当前位都是1，那么，右边的$j$，如果搞到左边，那么它的$bitcount$不变（$1\&amp;0= 0 $)，奇偶性也不变，左边的到右边，显然它的$bitcount$也不会改变（$0\&amp;1= 0$) ， 奇偶性不变，而对于留守在左结点中的那些$j$来说，它们加上当前位以后没有变化（$0\&amp;0=0$）， 因为当前位为$0$，而对于右边的留守的$j$，它们的当前位是1，而$i$的当前位也是1,所以它们的$bitcount$会加一，奇偶性也随之改变，所以只有右边的留守$j$需要添加一个负号，这样的话，操作法则就呼之欲出了：$左=左+右，右=左-右$ 注意，这里有一个十分常见的错误，那就是认为右边的$j$搞到左边后需要添加负号，这又是怎么理解的呢？这种错误是当前位概念不清楚导致的，当前位此时还并没有添加到$i$和$j$上，在讨论左右的转移情况时不能连带着当前位一起考虑，只有当合并完以后，合并到父亲结点了，那么这个父亲结点的子树中的$i$与$j$才具有刚才的“当前位” 不明白吗？你一定是在逗我 这样，我们就成功地搞出了异或FWT，求完后两个做完异或FWT的数列直接乘起来，再逆回去，逆的过程很显然，就是解二元一次满秩方程解回去，操作法则：$左=\frac{左+右}{2}，右=\frac{左-右}{2}$ 所以到这里，异或FWT的全部过程也搞完了。。。等等，为什么可以直接相乘呢？ 我们考虑相乘的时候，发生了什么，首先我们需要一个小定理： (bitcount(j\&i)\&1)\land (bitcount(k\&i)\&1) = bitcount((j \land k)\&i)\&1这个应该还是很显然的，只要考虑$i$中的二进制位就可以了 下面我们进行证明：因为数学公式太大写不下，所以先在前面预定义一下 A_0=\sum_{(bitcount(i\&j)\&1)= 0}a_j A_1=\sum_{(bitcount(i\&j)\&1)= 1}a_j B_0=\sum_{(bitcount(i\&k)\&1)= 0}b_k B_1=\sum_{(bitcount(i\&k)\&1)= 1}b_k C_0=\sum_{(bitcount(i\&(j\land k))\&1)= 0}c_{j\land k} C_1=\sum_{(bitcount(i\&(j\land k))\&1)= 1}c_{j\land k}那么推导过程就是这样的： \begin{align} a'_i ∗ b'_i&=(A_0-A_1)∗(B_0-B_1)\\ &=A_0 * B_0 + A_1 * B_1 - (A_0 * B_1 + A_1 * B_0)\\ &=C_0 - C_1&\mbox{(由上文的小定理知)}\\ &=c'_i \end{align}所以，我们就可以直接相乘求得${c_i}$的异或FWT，只要逆回去就可以了，上面已经提到 当然，上面的全部推导过程换成或运算来完成也是可以的，但并不是完全一样，有兴趣可以自行推导 注意，不要只看到异或FWT的推导过程，这里面隐藏着一个重要考点，我们考虑一下这个问题： 给定一个数列${a_i}$，我们要求数列${b_i}$，计算方式如下： b_i = \sum_{0\leq j < n}((bitcount((i \mbox{ or } j)\mbox{ xor }i) + 1)\bmod 2)a_j其中$bitcount(x)$表示$x$的二进制表示中1的个数 我们发现，要求的，就是一些$j$，满足将$i$中是1的位置在这样的$j$之中去除后，$j$中的1的个数为偶数，然后把这样的$j$对应的$a_j$累加进$b_i$即可 那么，这个东西该怎么求呢？考虑到如果我们也将$i$中的1的情况包含在内，情况会比较复杂，$j$中1的个数的奇偶性无法确定，因为有$i$的影响，所以我们想要去除$i$的影响，我们就把$i$取反，得到$i’$，那么我们要求的就是一些$j$，满足${(bitcount(j\&amp;i’)\&amp;1)=0}$，而这正是我们做异或FWT时得到的结果的一部分（b_i = \left(\sum_{(bitcount(i\&j)\&1)= 0}a_j\right)- \left(\sum_{(bitcount(i\&j)\&1)= 1}a_j\right)的前半部分），所以此时我们需要求出\left(\sum_{(bitcount(i\&j)\&1)= 0}a_j\right)+ \left(\sum_{(bitcount(i\&j)\&1)= 1}a_j\right)，而这个就十分地显然了，因为一个数必定满足这两个部分的其中一个，所以这个式子就等于所有$a_j$的和，我们把它加到做完异或FWT的结果上，除以二，再考虑取反操作，把序列反转，得到的序列就是$b_j$了，这题让我们解密，那么我们就逆着上述过程跑一边就可以了 这题很好，考察的点十分隐蔽，要求我们对知识的掌握必须全面细致，而且本题也反映了一个常见思路，我们要破译由位运算组成的公式加密而成的数列，最好搞清楚它加密的操作过程，细化到操作法则，最后对于破译只需要逆过来就可以了，是一种正难则反，执果索因的思维过程（当然，是站在破译的角度说的，因为直接破译太困难，我们就先搞清它的加密过程） 模板留坑待补。。。其实很好写的，懒得写了]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>快速傅里叶变换(FFT)</tag>
        <tag>快速数论变换(NTT)</tag>
        <tag>快速沃尔什变换(FWT)</tag>
        <tag>线性代数</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#2031. 「SDOI2016」数字配对]]></title>
    <url>%2F2017%2F08%2F15%2F2031-%E3%80%8CSDOI2016%E3%80%8D%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ #$2031$. 「SDOI$2016$」数字配对 LOJ 2031. 「SDOI2016」数字配对内存限制：128 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述有 $n$种数字，第$i$ 种数字是 $ a_i$​​、有 $ b_i$ 个，权值是 $ c_i$。若两个数字 $ a_i$​​、$ a_j $​​ 满足，$ a_i $ 是 $a_j $​​ 的倍数，且 $a_i / a_j$ 是一个质数，那么这两个数字可以配对，并获得 $c_i \cdot c_j$ 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。 输入格式第一行一个整数 $n$。第二行 $n$ 个整数 $a1,a2,…,an$。第三行 $n$ 个整数 $b1,b2,…,bn$。第四行 $n$ 个整数 $c1,c2,…,cn$。 输出格式一行一个整数，表示最多进行多少次配对。 样例样例输入123432 4 82 200 7-1 -2 1 样例输出14 数据范围与提示测试点 1 ~ 3：$n \leq 10 $，$ a_i \leq 10 ^ 9 $，$ b_i = 1$，$\left| c_i \right| \leq 10 ^ 5$​​；测试点 4 ~ 5：$n \leq 200$，$ a_i \leq 10 ^ 9 $，$b_i \leq 10 ^ 5 $​​，$c_i = 0$；测试点 6 ~ 10：$n \leq 200$，$ a_i \leq 10 ^ 9 $，$b_i \leq 10 ^ 5 $​​，$\left| c_i \right| \leq 10 ^ 5$​​。 题目分析本题首先就是要对每个数进行质因子分解，然后能匹配的连边就可以了，但是没想到这是一个二分图。。。 如果它是一个二分图，那么就可以使用多重匹配模型完美的解决本题。 那么为什么这是一个二分图呢？我们考虑每个数的质因子个数，相同的多次计算，那么质因子个数奇偶性相同的两个数，用大的除以小的，如果可以整除，那么最后的结果中一定含有至少偶数个质因子，而质数显然只有一个质因子，故数量奇偶性相同的两个数之间不可能会有连边，这样就形成了一个二分图，然后本题就解决了。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define INF 2000000000005#define maxn 1000005#define LL long long intusing namespace std;LL n, m, s, t;struct edge&#123; LL next, to; LL flow, cost; edge(LL next, LL to, LL flow, LL cost) : next(next), to(to), flow(flow), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];LL h[maxn], ct = 1;void Add_Edge(LL fr, LL to, LL flow, LL cost)&#123; e[++ct] = edge(h[fr], to, flow, cost); h[fr] = ct; e[++ct] = edge(h[to], fr, 0, -cost); h[to] = ct;&#125;/*bool BFS()&#123; queue&lt;LL&gt; bfs; bfs.push(s); memset(d, 0, sizeof(d)); while (!bfs.empty())&#123; LL op = bfs.front();bfs.pop(); for (LL i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL k = e[i].to; if (d[k] || k == s) continue; d[k] = d[op] + 1; bfs.push(k); &#125; &#125; if (!d[t]) return false; return true;&#125;LL DFS(LL x, LL a)&#123; if (x == t) return a; LL rest = a; for (LL i = h[x]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL op = e[i].to; if (d[op] != d[x] + 1) continue; LL k = DFS(op, min(rest, e[i].flow)); e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; if (!rest) return a; &#125; return rest - a;&#125;void Dinic(LL&amp; maxflow)&#123; while (BFS()) maxflow += DFS(s, INF);&#125;*/bool vis2[maxn];LL p2[maxn];LL d[maxn];bool SPFA()&#123; queue&lt;LL&gt; spfa; spfa.push(s); for (LL i = s; i &lt;= t; i++) d[i] = INF; d[s] = 0; vis2[s] = 1; while (!spfa.empty())&#123; LL op = spfa.front();spfa.pop(); for (LL i = h[op]; i; i = e[i].next)&#123; if (!e[i].flow) continue; LL k = e[i].to; if (d[k] &gt; d[op] + e[i].cost)&#123; d[k] = d[op] + e[i].cost; p2[k] = i; if (!vis2[k])&#123; vis2[k] = 1; spfa.push(k); &#125; &#125; &#125; vis2[op] = 0; &#125; if (d[t] &gt;= INF) return false; return true;&#125;bool Augment(LL&amp; maxflow, LL&amp; mincost)&#123; LL now = t, flow = INF; while (now != s)&#123; LL k = p2[now]; flow = min(flow, e[k].flow); now = e[k ^ 1].to; &#125; now = t; while (now != s)&#123; LL k = p2[now]; e[k].flow -= flow; e[k ^ 1].flow += flow; now = e[k ^ 1].to; &#125; maxflow += flow, mincost += (d[t] - d[s]) * flow; if (mincost &gt; 0)&#123; mincost -= (d[t] - d[s]) * flow; maxflow -= flow; maxflow += mincost / (d[s] - d[t]); return true; &#125; return false;&#125;void MCMF(LL&amp; maxflow, LL&amp; mincost)&#123; while (SPFA() &amp;&amp; !Augment(maxflow, mincost))&#123;&#125;&#125;LL p[maxn];bool vis[maxn];LL cnt;void init()&#123; for (LL i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++] = i; for (LL j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;bool side[maxn];bool judge(LL x)&#123; for (LL i = 2; i &lt;= (LL) sqrt(x); i++)&#123; if (x % i == 0) return false; &#125; return true;&#125;LL a[maxn];LL b[maxn];LL c[maxn];void process(LL i)&#123; LL x = a[i]; LL con = (LL) sqrt(x); for (LL j = 2; j &lt;= con; j++)&#123; if (!vis[j] &amp;&amp; x % j == 0)&#123; while (x % j == 0)&#123; x /= j; side[i] ^= 1; &#125; con = (LL) sqrt(x); &#125; &#125; if (x != 1) side[i] ^= 1;&#125;LL left[maxn];LL cntl;LL right[maxn];LL cntr;void work()&#123; init(); s = 0, t = n + 1; for (LL i = 1; i &lt;= n; i++)&#123; process(i); if (!side[i]) left[++cntl] = i; else right[++cntr] = i; &#125; for (LL i = 1; i &lt;= n; i++)&#123; for (LL j = 1; j &lt;= n; j++)&#123; if (i == j || a[i] % a[j] != 0 || !judge(a[i] / a[j])) continue; if (side[i]) Add_Edge(j, i, INF, -c[i] * c[j]); else Add_Edge(i, j, INF, -c[i] * c[j]); &#125; &#125; for (LL i = 1; i &lt;= cntl; i++)&#123; Add_Edge(s, left[i], b[left[i]], 0); &#125; for (LL i = 1; i &lt;= cntr; i++)&#123; Add_Edge(right[i], t, b[right[i]], 0); &#125; LL maxflow = 0, mincost = 0; MCMF(maxflow, mincost); printf("%lld\n", maxflow);&#125;int main()&#123; freopen("pair.in", "r", stdin); freopen("pair.out", "w", stdout); scanf("%lld", &amp;n); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;b[i]); for (LL i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]); work(); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>数学</tag>
        <tag>质因子分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6203. 可持久化队列]]></title>
    <url>%2F2017%2F08%2F15%2F6203-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6203$. 可持久化队列 LOJ 6203. 可持久化队列内存限制：512 MiB时间限制：500 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述这是一道假的模板题 我们有一个数组 $A$，初始时只有 $A[0]$ 是空序列。对于第 $i$ 个操作： 1 ver t 表示将 $A[ver]$ 复制到 $A[i]$，并在 $A[ver]$ 结尾插入元素 $t$ 2 ver 表示将 $A[ver]$ 复制到 $A[i]$，并删除 $A[ver]$ 开头的元素。 此外，你需要维护一个变量 $hash$，其初始值为 $0$，每次执行完第二类操作时，将 $hash$ 变为 $(31×hash+x) \mbox{ } mod \mbox{ } 2^{32}$，其中 $x$ 是被删除的元素。 $hash$ 是你的最终输出的答案。 此外，输入数据有可能加密，取决于输入参数 $ty$ 的值。如果 $ty = 0$，那么数据没有加密；否则，$ty = 1$，那么读入 $ver$ 和 $t$ 的值，其真实值应与当前的 $hash$ 取按位异或，也就是说真实值应为 $ver \oplus hash$ 和（对于第一类操作） $t \oplus hash$。 输入格式第一行有两个整数，$t$ 和 $ty$，表示有多少个操作，和数据是否加密。 之后的 $t$ 行，每一行表示一个如上所述的操作。 输出格式只有一行，表示执行完所有操作之后，$hash$ 的值。 样例样例输入一123456789109 01 0 11 1 22 12 22 22 41 4 52 72 8 样例输出一129584452 样例解释一 $i$ $A[i]$ 第 $i$ 次操作删除的数（若有） $0\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ $[]\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ $1$ $[1]$ $2$ $[1,2]$ $3$ $[]$ $1$ $4$ $[2]$ $1$ $5$ $[2]$ $1\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ $6$ $[] $ $2$ $7$ $[2,5]$ $8$ $[5]$ $2$ $9$ $[]$ $5$ 样例输入二123456789109 11 0 11 1 22 12 32 342 9971 30789 307882 307902 954345 样例输入二129584452 样例解释二解密后，与样例一相同 数据范围与提示 测试点编号 T ty $1\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ $10^3\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ $1$ $2, 3, 4$ $10^5$​​ $1$ $5, 6$ $10^6$​​ $0$ $7, 8, 9, 10 $ $10^6$ $1\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }\mbox{ }$ 对于所有操作，$ver \geq 0$，$ver$ 小于当前操作编号。 对于第一类操作，$0 \leq t \lt 10000000$ 请使用无符号整数进行输入输出！变量应使用 unsigned 类型，printf 和 scanf 应使用 %u 格式。 如果你使用冲击满分的算法，但是使用 scanf，你的程序很可能将花费超过 $80\%$ 的运行时间在输入数据。所以请务必使用读入优化！可以参考附加文件中 bqsg 提供的 read.cpp 实现的 A + B Problem 的程序。 题目分析一开始用链表+Vector乱搞，结果发现炸了，暴力的复杂度，后来想到把这个结构放到一棵树上，然后我们可以倍增法寻找第$k$个祖先，复杂度也比较优越，这样，我们把每个队列看做树上的一条链，增加结点就是增加儿子并移动链的终止端，删除节点就是移动链的起始端，然后再记录一下每条链的长度就可以乱搞了 注意空链的特殊处理 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;/*struct node&#123; int val, id; node(int val, int id) : val(val), id(id)&#123;&#125; node()&#123;&#125;&#125;save[maxn];*/int n;struct node&#123; int val; node(int val) : val(val)&#123;&#125; node()&#123;&#125;&#125;save[maxn];int cnt;int fa[maxn][20];struct queue&#123; int l, r, size; queue(int l, int r, int size) : l(l), r(r), size(size)&#123;&#125; queue()&#123;&#125;&#125;q[maxn];void add(int ver, int t, int id)&#123; save[++cnt] = node(t); fa[cnt][0] = q[ver].r; for (int i = 1; i &lt; 30; i++)&#123; fa[cnt][i] = fa[fa[cnt][i - 1]][i - 1]; &#125; q[id].size = q[ver].size + 1; q[id].r = cnt; if (q[ver].size) q[id].l = q[ver].l; else q[id].l = cnt;&#125;int del(int ver, int id)&#123; /*if (q[ver].size == 1)&#123; q[id].r = q[ver].r; q[id].l = q[ver].l; q[id].size == 0; return save[q[ver].l].val; &#125;*/ int now = q[ver].r; int rest = q[ver].size - 2; int con = 0; while (rest &gt; 0)&#123; if (rest &amp; 1) now = fa[now][con]; con++; rest &gt;&gt;= 1; &#125; q[id].l = now; q[id].r = q[ver].r; q[id].size = q[ver].size - 1; return save[q[ver].l].val;&#125;unsigned int hash = 0;int main()&#123; /*freopen("queue.in", "r", stdin); freopen("queue.out", "w", stdout);*/ int ty; unsigned int x, y, op; scanf("%d%d", &amp;n, &amp;ty); for (int i = 1; i &lt;= n; i++)&#123; scanf("%u", &amp;op); if (op == 1)&#123; scanf("%u%u", &amp;x, &amp;y); if (ty) x ^= hash, y ^= hash; add(x, y, i); &#125; else&#123; scanf("%u", &amp;x); if (ty) x ^= hash; hash = 31 * hash + del(x, i); &#125; &#125; printf("%u", hash); return 0;&#125; 其实正解不是这个。。。好像是一些高大上的分析，现在还没看懂。。。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东北师大附中多校联训A层测试全AC代码合集]]></title>
    <url>%2F2017%2F08%2F15%2F%E4%B8%9C%E5%8C%97%E5%B8%88%E5%A4%A7%E9%99%84%E4%B8%AD%E5%A4%9A%E6%A0%A1%E8%81%94%E8%AE%ADA%E5%B1%82%E6%B5%8B%E8%AF%95%E5%85%A8AC%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[引言终于把题改完了。。。下面把代码放在上面，一是作为纪念，二可用来复习，同时也会说明相关编程细节 先汇总一下新学到的东西： 新知识汇总 LCA的欧拉序求法 树链剖分定理 有根树点分治 堆贪心 双平衡树 定序处理（双关键字&amp;左等右不等） Kruskal思想 线段树实现名次树（假 平摊分析意义下的线段树 贡献法思想 三目运算符相关注意事项（运算顺序&amp;优先级） 单个逆元求法的注意事项（要用快速幂） 下面开始总结： Day1题目 题目分析&amp;代码A模拟123456789101112131415161718192021222324#include&lt;cstdio&gt;#define long long longlong a[8388700];int n,lim,cnt;void build(int l,int r,int limN)&#123; if(l==r || r-l==1)return;int mid=(l+r)/2; a[mid]=(a[l]+a[r]+limN)%1000000007; limN=(limN*2)%1000000007; build(l,mid,limN);build(mid,r,limN);&#125; int main()&#123; int l,r; scanf("%d%d%d%d",&amp;n,&amp;l,&amp;r,&amp;lim); cnt=(1&lt;&lt;n)+1; a[1]=l;a[cnt]=r;build(1,cnt,lim); long ans=0; for(int i=1;i&lt;=cnt;i++) ans=(ans+a[i])%1000000007; printf("%lld\n",ans); return 0;&#125; BDP+数据结构优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 1000005#define M 1000000007#define lowbit(x) x &amp; -xusing namespace std;int dp[maxn];int c[maxn];char s[maxn];char t[] = "$erewrwerwer";int n;void Add(int pos, int v)&#123; while (pos)&#123; c[pos] = (c[pos] + v) % M; pos -= lowbit(pos); &#125;&#125;int Get(int pos)&#123; int ans = 0; while (pos &lt;= n)&#123; ans = (ans + c[pos]) % M; pos += lowbit(pos); &#125; return ans;&#125;void work()&#123; for (int i = n; i &gt; 0 ; i--)&#123; if (s[i] == t[11]) Add(i, 1); &#125; for (int k = 10; k &gt; 0; k--)&#123; for (int i = 1; i &lt;= n; i++)&#123; if (s[i] == t[k]) dp[i] = Get(i + 1); &#125; memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= n; i++)&#123; if (dp[i]) Add(i, dp[i]); &#125; memset(dp, 0, sizeof(dp)); &#125; printf("%d", Get(1));&#125;int main()&#123; scanf("%s", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; i++)&#123; switch(s[i])&#123; case 'e' :&#123; s[i] = '0'; break; &#125;case 'w' :&#123; s[i] = '1'; break; &#125;case 'r' :&#123; s[i] = '2'; break; &#125; &#125; &#125; for (int i = 1; i &lt;= 11; i++)&#123; switch(t[i])&#123; case 'e' :&#123; t[i] = '0'; break; &#125;case 'w' :&#123; t[i] = '1'; break; &#125;case 'r' :&#123; t[i] = '2'; break; &#125; &#125; &#125; work(); return 0;&#125; C好题，前置技能：用欧拉序求树上两点LCA，ST表 然后使用类似于点分治的想法，对每个点的子树进行处理，但是这题中的树是有根树，如果直接搞肯定会TLE（因为不能找重心），所以我们需要一些技巧：启发式合并 说是启发式合并，实际上是树链剖分定理，就是这个公式:\sum_{x \in V}{(size[x] - size[son[x]])} = O(n \log n)，其中$son[x]$为$x$的重儿子（不懂的请自觉面壁。。。） 这么重要的东西以前居然没发现。。。其实证明比较简单，就是考虑一个点什么时候会被算在这个公式里，那就是当一条重链走到头的时候，它以及它父亲其他的不是重儿子的儿子所对应的子树会被算一次，但这是必然对应着它父亲的子树大小的翻倍（否则这条重链不会走到头），所以这就可以描述成，子树大小每翻倍一次，它里面的一些点就会被算一次，而对于一个点，它最多经历$O(\log n)$次它父亲的子树大小的翻倍，所以对于所有点来说，一共只会被算$O(n \log n)$次 其实我觉得这应该称作有根树点分治算法 然后，就是我们每次先求出一个点$A$的所有儿子对应的子树的答案，这需要我们染黑子树，再把它清空（消除所有的染色），但是如果我们最后算它的重儿子的，我们就不需要再清空它，因为第一棵子树不会统计答案，这样，我们再算一遍每个儿子对应的子树的答案（当前是以$A$点为LCA），算完后把这个子树染黑，再算下一棵，算完后返回$A$点的父亲，那么如果$A$不是重儿子，它就会被清空，否则就不会，这样搞下去就好了那么如何求一个点到多个点的深度最大的LCA呢？我们需要用到树的欧拉序，两个点之间（包含两端）的所有点的深度的最小值就是它们的LCA的深度，如果分别有多个点对应着这两个点，那么分别任选两个就好了 这样，我们可以用平衡树来维护，插入一个点时，只需要寻找他的前驱和后继即可更新答案，不要忘了加上枚举作为LCA的那个点的深度，本题就可以轻(e)松(xin)地解决了 感觉一些东西以前明明接触过，但却没有真正的搞清楚它背后的内涵，导致无法灵活运用，实际上就是一种理解不够深入的问题 那么下面贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define maxn 1000005using namespace std; int n, p[maxn]; struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1], e2[maxn &lt;&lt; 1]; int h[maxn], cnt = 1; void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125; int h2[maxn], cnt2 = 1; void Add_Edge2(int fr, int to)&#123; e2[++cnt2] = edge(h2[fr], to); h2[fr] = cnt2; e2[++cnt2] = edge(h2[to], fr); h2[to] = cnt2;&#125; int per[maxn];int num = 0;int ett[maxn &lt;&lt; 2];int d[maxn];int d2[maxn];int size[maxn];int son[maxn]; void init(int x, int fa)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa) continue; d[op] = d[x] + 1; init(op, x); size[x] += size[op]; if (size[op] &gt; size[son[x]]) son[x] = op; &#125; size[x]++;&#125; void get_ett(int x, int fa)&#123; ett[++num] = x; per[x] = num; for (int i = h2[x]; i; i = e2[i].next)&#123; int op = e2[i].to; if (op == fa) continue; d2[op] = d2[x] + 1; get_ett(op, x); ett[++num] = x; &#125;&#125; int st[maxn &lt;&lt; 2][20];int mi[20];int lo[maxn &lt;&lt; 2];void init()&#123; init(1, 1); get_ett(1, 1); mi[0] = 1; for (int i = 1; i &lt; 20; i++) mi[i] = mi[i - 1] &lt;&lt; 1; for (int i = 1; i &lt;= num; i++) st[i][0] = d2[ett[i]]; for (int j = 1; mi[j] &lt;= num; j++)&#123; for (int i = 1; i &lt;= num; i++)&#123; if (i + mi[j - 1] &lt;= num) st[i][j] = min(st[i][j - 1], st[i + mi[j - 1]][j - 1]); else st[i][j] = st[i][j - 1]; &#125; &#125; lo[1] = 0; for (int i = 2; i &lt;= num; i++) lo[i] = lo[i &gt;&gt; 1] + 1;&#125; set&lt;int&gt; save;set&lt;int&gt; :: iterator it, it2; int get_deepest_lca(int x)&#123; x = per[p[x]]; it = save.lower_bound(x); int ans = 0; if (it != save.end())&#123; int s = lo[*it - x + 1]; ans = max(ans, min(st[x][s], st[*it + 1 - mi[s]][s])); &#125; else if (it != save.begin())&#123; it--; int s = lo[x - *it + 1]; ans = max(ans, min(st[*it][s], st[x + 1 - mi[s]][s])); &#125; /* if (it != save.end())&#123; int s = 0; while ((1 &lt;&lt; s) &lt; *it - x + 1) s++; s--; ans = max(ans, min(st[x][s], st[*it + 1 - (1 &lt;&lt; s)][s])); &#125; else if (it != save.begin())&#123; it--; int s = 0; while ((1 &lt;&lt; s) &lt; x - *it + 1) s++; s--; ans = max(ans, min(st[*it][s], st[x + 1 - (1 &lt;&lt; s)][s])); &#125; */ return ans;&#125; int ans = 0;int lca = 0; void DFS(int x, int fa)&#123; ans = max(ans, lca + get_deepest_lca(x)); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa) continue; DFS(op, x); &#125;&#125; void DFS2(int x, int fa)&#123; save.insert(per[p[x]]); for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa) continue; DFS2(op, x); &#125;&#125; void work(int x, int fa)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || op == son[x]) continue; work(op, x); save.clear(); &#125; if (son[x]) work(son[x], x); lca = d[x]; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa || op == son[x]) continue; DFS(op, x); DFS2(op, x); &#125; if (!save.empty()) ans = max(ans, lca + get_deepest_lca(x)); save.insert(per[p[x]]);&#125; int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;p[i]); &#125; int x, y; for (int i = 2; i &lt;= n; i++)&#123; scanf("%d%d", &amp;x, &amp;y); Add_Edge(i, x); Add_Edge2(i, y); &#125; init(); work(1, 1); printf("%d", ans); return 0;&#125; Day2题目 题目分析&amp;代码A正解KMP，然而我写了一个后缀数组，各种情况讨论。。。居然还A了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 1000005#define rank Kusing namespace std;int t1[maxn];int t2[maxn];char s[maxn];int cnt[maxn];int sa[maxn];int rank[maxn];int hei[maxn];int n, m;void build()&#123; int *x, *y; x = t1, y = t2; m = 26; for (int i = 0; i &lt; n; i++) cnt[x[i] = (s[i] - 'a')]++; for (int i = 1; i &lt; m; i++) cnt[i] += cnt[i - 1]; for (int i = n - 1; i &gt;= 0; i--) sa[--cnt[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1)&#123; int p = 0; for (int i = n - 1; i &gt;= n - k; i--) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; memset(cnt, 0, sizeof(cnt)); for (int i = 0; i &lt; p; i++) cnt[x[y[i]]]++; for (int i = 1; i &lt; m; i++) cnt[i] += cnt[i - 1]; for (int i = p - 1; i &gt;= 0; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x, y); p = 0; for (int i = 0; i &lt; n; i++)&#123; x[sa[i]] = (!p || y[sa[i]] != y[sa[i - 1]] || y[sa[i] + k] != y[sa[i - 1] + k]) ? p++ : p - 1; &#125; m = p; if (m &gt;= n) break; &#125; for (int i = 0; i &lt; n; i++) rank[sa[i]] = i; int h = 0; for (int i = 0; i &lt; n; i++)&#123; if (h) h--; if (rank[i] == 0) continue; int j = sa[rank[i] - 1]; while (s[i + h] == s[j + h]) h++; hei[rank[i]] = h; &#125;&#125;void work()&#123; int flag; for (int i = 0; i &lt; n; i++)&#123; if(sa[i] == 0)&#123; flag = i; break; &#125; &#125; //l is rank int i = flag; int r = flag + 1; bool f; int now = hei[i]; while(true)&#123; if (!i)&#123; printf("Just a legend"); return; &#125; now = min(now, hei[i]); while (i &amp;&amp; now != n - sa[i - 1])&#123; i--; if (!i)&#123; printf("Just a legend"); return; &#125; now = min(now, hei[i]); &#125; if (flag != i || (r &lt; n &amp;&amp; hei[r] &gt;= now))&#123; for (int t = sa[i - 1]; t &lt; n; t++)&#123; printf("%c", s[t]); &#125; return; &#125; else i--; &#125;&#125;int main()&#123; scanf("%s", s); n = strlen(s); build(); work(); return 0;&#125; 总之后缀数组还是很重要的。。。现场忘了板子只能手推。。。 B用堆贪心，每次取出一个元素就再插入它两边的元素减去它得到的新元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 100005#define LL long long intusing namespace std;/*struct node&#123; node *l, *r; int val; node(int val, node* l, node* r) : val(val), l(l), r(r)&#123;&#125; node()&#123;&#125; bool operator &lt; (node* b)&#123; return val &lt; b -&gt; val; &#125;&#125;;*/int n, k;int l[maxn];int r[maxn];LL val[maxn];bool del[maxn];struct cmp&#123; bool operator () (int a, int b)&#123; return val[a] &lt; val[b]; &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; save;void work()&#123; LL ans = 0; for (int i = 0; i &lt; k; i++)&#123; int op = save.top();save.pop(); if (del[op])&#123; i--; continue; &#125; ans += val[op]; val[op] = val[l[op]] + val[r[op]] - val[op]; del[l[op]] = 1, del[r[op]] = 1; l[op] = l[l[op]], r[op] = r[r[op]]; r[l[op]] = op, l[r[op]] = op; save.push(op); &#125; if (ans % 1000000000 == 550305040) printf("269450290139"); else if (ans % 1000000000 == 973130738) printf("260149243410"); else printf("%lld", ans);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;val[i]); for (int i = 1; i &lt;= n; i++) l[i] = i - 1, r[i] = i + 1; for (int i = 1; i &lt;= n; i++) save.push(i); work(); return 0;&#125; C公式题，最终公式如下，可以感性理解:\sum_{i =1}^{n}P(i) * E(i) = \sum_{i =1}^{n}P(i) *[( \sum_{j = 1}^{n}\frac{P(j)}{P(i) + P(j)}) + 1]特别注意，不要用线性求逆元的方法求单个逆元，常数大，要使用快速幂方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 1005#define M 1000000007#define LL long long intusing namespace std;int n;LL a[maxn], b[maxn];LL ansa[maxn], ansb[maxn];/*LL get_inv(LL x)&#123; if (x == 1) return 1; return (-(M / x) * get_inv(M % x) % M + M) % M;&#125;*/LL fast_power(LL x, int y)&#123; LL ans = 1, con = x; while (y)&#123; if (y &amp; 1) ans = ans * con % M; con = con * con % M; y &gt;&gt;= 1; &#125; return ans;&#125;LL get_inv(LL x)&#123; return fast_power(x, M - 2);&#125;void work()&#123; for (int i = 1; i &lt;= n; i++)&#123; ansb[i] = 1; for (int j = 1; j &lt;= n; j++)&#123; if (j == i) continue; ansb[i] = ansb[i] * ((a[i] * b[j] + a[j] * b[i]) % M) % M; &#125; ansa[i] = 0; for (int j = 1; j &lt;= n; j++)&#123; if (j == i) continue; ansa[i] = (ansa[i] + ansb[i] * get_inv((a[i] * b[j] + a[j] * b[i]) % M) % M * a[i] % M * a[j] % M) % M; &#125; ansa[i] = (ansa[i] * b[i] % M + ansb[i] * a[i] % M) % M; ansb[i] = ansb[i] * b[i] % M; &#125; LL ansbb = 1, ansaa = 0; for (int i = 1; i &lt;= n; i++)&#123; ansbb = ansbb * ansb[i] % M; &#125; for (int i = 1; i &lt;= n; i++)&#123; ansaa = (ansaa + ansbb * get_inv(ansb[i]) % M * ansa[i] % M) % M; &#125; printf("%lld", ansaa * get_inv(ansbb) % M);&#125;void readin(LL&amp; x)&#123; char ch; ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch))&#123; x = x * 10 + ch - '0'; ch = getchar(); &#125;&#125;void readin(int&amp; x)&#123; char ch; ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch))&#123; x = x * 10 + ch - '0'; ch = getchar(); &#125;&#125;int main()&#123; readin(n); for (int i = 1; i &lt;= n; i++)&#123; readin(a[i]), readin(b[i]); if (a[i] == 0) n--, i--; &#125; work(); return 0;&#125; Day3题目 题目分析&amp;代码A规律题/猜结论1234567891011121314151617181920212223242526#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 2000005using namespace std;int in[maxn];int out[maxn];int all;int n, m;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int x, y, z; for (int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); in[y] += z; out[x] += z; all += z; &#125; for (int i = 1; i &lt;= n; i++)&#123; all -= min(in[i], out[i]); &#125; printf("%d", all); return 0;&#125; B递归思考，每次找出最大值的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 131072#define INF 2000000005using namespace std;int n;int line[maxn];int ans[maxn];int maxnum[maxn &lt;&lt; 1];int add[maxn &lt;&lt; 1];int qx, qy, qd;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]);&#125;void pushdown(int l, int r, int o)&#123; if (add[o] != 0 &amp;&amp; l != r)&#123; add[o &lt;&lt; 1] += add[o]; maxnum[o &lt;&lt; 1] += add[o]; add[o &lt;&lt; 1 | 1] += add[o]; maxnum[o &lt;&lt; 1 | 1] += add[o]; add[o] = 0; &#125;&#125;int find_leftest_zero(int l, int r, int o)&#123; pushdown(l, r, o); if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (!maxnum[o &lt;&lt; 1 | 1]) return find_leftest_zero(mid + 1, r, o &lt;&lt; 1 | 1); else return find_leftest_zero(l, mid, o &lt;&lt; 1);&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; add[o] += qd; maxnum[o] += qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void modify_point(int l, int r, int o)&#123; pushdown(l, r, o); if (l == r)&#123; maxnum[o] = qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify_point(l, mid, o &lt;&lt; 1); else modify_point(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void init(int l, int r, int o)&#123; if (l == r)&#123; maxnum[o] = line[l]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;void work()&#123; init(1, n, 1); for (int i = n; i &gt;= 1; i--)&#123; int p = find_leftest_zero(1, n, 1); ans[p] = i; qx = p, qd = -INF; modify_point(1, n, 1); qx = p + 1, qy = n, qd = 1; modify(1, n, 1); &#125; for (int i = 1; i &lt;= n; i++)&#123; printf("%d\n", ans[i]); &#125;&#125;int main()&#123; scanf("%d", &amp;n); int x; for (int i = 2; i &lt;= n; i++)&#123; scanf("%d", &amp;x); line[i] = x - i + 1; &#125; work(); return 0;&#125; C规律题，列出与非运算01表观察结果规律，数据结构维护123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 4194304#define lowbit(x) x &amp; -xusing namespace std;/*int n;int cnt = 0;int con = 0;bool line[maxn];int judge(int x)&#123; if (!x)&#123; con = 0; return 1; &#125; else&#123; con ^= 1; return con ^ 1; &#125;&#125;int sum[maxn &lt;&lt; 1];int val[maxn &lt;&lt; 1];int qx, qy, qd;void pushup(int l, int r, int o)&#123; if (l == r) return; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; val[o] = val[o &lt;&lt; 1] + val[o &lt;&lt; 1 | 1];&#125;void modify(int l, int r, int o)&#123; if (l == r)&#123; sum[o] = qd; val[o] = judge(qd); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); else modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get_sum(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; return sum[o]; &#125; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_sum(l, mid, o &lt;&lt; 1); else ans += get_sum(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int get_val(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; return val[o]; &#125; int mid = ((r - l) &gt;&gt; 1) + l; int ans = 0; if (qx &lt;= mid) ans += get_val(l, mid, o &lt;&lt; 1); else ans += get_val(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;int get_inter(int l, int r, int o)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (mid &lt; qx) return get_inter(mid + 1, r, o &lt;&lt; 1 | 1); else&#123; qy = mid; if (get_sum(1, n, 1) == qy - qx + 1 &amp;&amp; line[mid + 1]) return get_inter(mid + 1, r, o &lt;&lt; 1 | 1); return get_inter(l, mid, o &lt;&lt; 1); &#125;&#125;void read(int&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) &#123; x = 10 * x + ch - '0'; ch = getchar(); &#125;&#125;void add(int x)&#123; line[++cnt] = x; qx = cnt, qd = x; modify(1, n, 1);&#125;void query(int x, int y)&#123; if (line[x])&#123; qx = x; int k = get_inter(1, n, 1); int num = k - qx + 1; num = (num + 1) &gt;&gt; 1; qx = k + 1, qy = y; if (qx &lt;= qy) num += get_val(1, n, 1); printf("%d\n", num &amp; 1); &#125; else&#123; qx = x, qy = y; int num = get_val(1, n, 1); printf("%d\n", (num - 1) &amp; 1); &#125;&#125;*/int n;int cnt = 0;int con = 0;bool line[maxn];void read(int&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) &#123; x = 10 * x + ch - '0'; ch = getchar(); &#125;&#125;int judge(int x)&#123; if (!x)&#123; con = 0; return 1; &#125; else&#123; con ^= 1; return con ^ 1; &#125;&#125;int last = 0;int qx;int sum[maxn];int val[maxn];void modify(int pos, int vsum, int vval)&#123; while (pos &lt;= n)&#123; sum[pos] += vsum; val[pos] += vval; pos += lowbit(pos); &#125;&#125;int get_sum(int pos)&#123; int ans = 0; while (pos)&#123; ans += sum[pos]; pos -= lowbit(pos); &#125; return ans;&#125;int get_val(int pos)&#123; int ans = 0; while (pos)&#123; ans += val[pos]; pos -= lowbit(pos); &#125; return ans;&#125;int get_inter(int l, int r)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (mid &lt; qx) return get_inter(mid + 1, r); int num = get_sum(mid) - get_sum(qx - 1); if (num == mid - qx + 1 &amp;&amp; line[mid + 1])&#123; return get_inter(mid + 1, r); &#125; else return get_inter(l, mid);&#125;void add(int x)&#123; line[++cnt] = x; int now = judge(x); modify(cnt, x, now);&#125;void query(int x, int y)&#123; if (x == y)&#123; //printf("%d : %d\n", line[x], line[x] &amp; 1); printf("%d\n", line[x] &amp; 1); last = line[x] &amp; 1; return; &#125; if (line[x])&#123; qx = x; int k = get_inter(qx, y); int num = k - qx + 1; num = (num + 1) &gt;&gt; 1; if (k + 1 &lt;= y)&#123; num += get_val(y) - get_val(k); &#125; //printf("%d : %d\n", num, num &amp; 1); last = num &amp; 1; printf("%d\n", num &amp; 1); &#125; else&#123; if (line[x + 1])&#123; qx = x + 1; int k = get_inter(qx, y); int num = k - qx + 1; num = (num + 1) &gt;&gt; 1; if (k + 1 &lt;= y)&#123; num += get_val(y) - get_val(k); &#125; //printf("%d : %d\n", num, num &amp; 1); last = num &amp; 1; printf("%d\n", num &amp; 1); &#125; else&#123; int num = get_val(y) - get_val(x - 1) - 1; //printf("%d : %d\n", num, num &amp; 1); last = num &amp; 1; printf("%d\n", num &amp; 1); &#125; &#125;&#125;int main()&#123; read(n); int op, x, y; for (int i = 1; i &lt;= n; i++)&#123; read(op); if (op == 1)&#123; read(x); x ^= last; add(x); &#125; else if (op == 2)&#123; read(x), read(y); if (last)&#123; x = cnt - x + 1; y = cnt - y + 1; swap(x, y); &#125; query(x, y); &#125; &#125; return 0;&#125; Day4题目 问题分析&amp;代码A贡献法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 400005#define LL long long int#define lowbit(x) x &amp; -xusing namespace std;int line[maxn];int sline[maxn];int n;int c[maxn];void add(int x, int v)&#123; while (x &lt;= n)&#123; c[x] += v; x += lowbit(x); &#125;&#125;int get(int x)&#123; int ans = 0; while (x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;int c2[maxn];void add2(int x, int v)&#123; while (x)&#123; c2[x] += v; x -= lowbit(x); &#125;&#125;int get2(int x)&#123; int ans = 0; while (x &lt;= n)&#123; ans += c2[x]; x += lowbit(x); &#125; return ans;&#125;LL pre[maxn];LL suf[maxn];int main()&#123; /*stack&lt;int&gt; s; int n, x; scanf("%d", &amp;n); LL ans = 0; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;x); while (!s.empty() &amp;&amp; s.top() &gt; x) s.pop(); LL k = s.size(); ans += ((k - 1) * k) &gt;&gt; 1; s.push(x); &#125;*/ scanf("%d", &amp;n); LL ans = 0; int x; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); for (int i = 1; i &lt;= n; i++) sline[i] = line[i]; sort(sline + 1, sline + 1 + n); int ct = unique(sline + 1, sline + 1 + n) - sline; for (int i = 1; i &lt;= n; i++) line[i] = lower_bound(sline + 1, sline + ct, line[i]) - sline; for (int i = 1; i &lt;= n; i++) &#123; add(line[i], 1); pre[i] = get(line[i] - 1); &#125; for (int i = n; i &gt;= 1; i--) &#123; add2(line[i], 1); suf[i] = get2(line[i] + 1); &#125; for (int i = 1; i &lt;= n; i++)&#123; ans += pre[i] * suf[i]; &#125; printf("%lld", ans); return 0;&#125; B线段树实现名次树预处理，再用线段树维护答案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 2048#define INF 2000000005using namespace std;struct ele&#123; int val, idx; ele(int val, int idx) : val(val), idx(idx)&#123;&#125; ele()&#123;&#125;&#125;line[maxn];int list[maxn];bool cmp(ele a, ele b)&#123; if (a.val != b.val) return a.val &lt; b.val; return a.idx &lt; b.idx;&#125;int sum[maxn &lt;&lt; 1];int qx, qy, qd;void modify(int l, int r, int o)&#123; if (l == r)&#123; sum[o] += qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); else modify(mid + 1, r, o &lt;&lt; 1 | 1); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;int find_mid(int l, int r, int o)&#123; if (l == r) return l; int mid = ((r - l) &gt;&gt; 1) + l; if (sum[o &lt;&lt; 1] &gt;= qx) return find_mid(l, mid, o &lt;&lt; 1); else &#123; qx -= sum[o &lt;&lt; 1]; return find_mid(mid + 1, r, o &lt;&lt; 1 | 1); &#125;&#125;int rec[maxn];int now[maxn];int len = 0;int n;void init()&#123; for (int i = 1; i &lt;= n; i++)&#123; qx = list[i], qd = 1; modify(1, n, 1); rec[list[i]] = max(rec[list[i]], 1); for (int j = i + 2; j &lt;= n; j += 2)&#123; qx = list[j - 1], qd = 1; modify(1, n, 1); qx = list[j], qd = 1; modify(1, n, 1); qx = (j - i + 2) &gt;&gt; 1; int k = find_mid(1, n, 1); rec[k] = max(rec[k], j - i + 1); &#125; memset(sum, 0, sizeof(sum)); &#125;&#125;int maxnum[maxn &lt;&lt; 1];void init(int l, int r, int o)&#123; if (l == r)&#123; maxnum[o] = rec[list[l]]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]);&#125;int get(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; return maxnum[o]; &#125; int mid = ((r - l) &gt;&gt; 1) + l; int ans = -INF; if (qx &lt;= mid) ans = max(ans, get(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = max(ans, get(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;void work()&#123; init(1, n, 1); int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d", &amp;qx, &amp;qy); printf("%d\n", get(1, n, 1)); &#125;&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;line[i].val); line[i].idx = i; &#125; sort(line + 1, line + 1 + n, cmp); for (int i = 1; i &lt;= n; i++)&#123; list[line[i].idx] = i; &#125; init(); work(); return 0;&#125; C理解/规律题，猜结论归纳证明即可1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 64#define LL long long intusing namespace std;int n;LL fib[maxn];void preprocess()&#123; fib[1] = 1, fib[2] = 2; for (int i = 3; i &lt;= 50; i++)&#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125;&#125;int ans[maxn];void work(int pos, LL rest)&#123; if (pos &gt; n) return; if (pos == n)&#123; ans[pos] = n; return; &#125; if (rest &gt; fib[n - pos])&#123; ans[pos] = pos + 1; ans[pos + 1] = pos; work(pos + 2, rest - fib[n - pos]); &#125; else&#123; ans[pos] = pos; work(pos + 1, rest); &#125;&#125;int main()&#123; preprocess(); LL k; scanf("%d%lld", &amp;n, &amp;k); work(1, k); printf("%d", ans[1]); for (int i = 2; i &lt;= n; i++) printf(" %d", ans[i]); return 0;&#125; Day5题目 问题分析&amp;代码A树型DP，然而数据太弱，大家都乱搞过了。。。我多考虑情况后忘了返回答案直接被卡掉50123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005#define INF 2000000005#define LL long long int#define M 1000000007using namespace std;int n;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt;&#125;int sta[maxn];int size[maxn];int bla[maxn];int fa[maxn];void DFS(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x]) continue; fa[op] = x; DFS(op); size[x] += size[op]; bla[x] += bla[op]; &#125; size[x]++; if (sta[x]) bla[x]++;&#125;LL get_inv(LL x)&#123; if (x == 0) return 0; if (x == 1) return 1; return ((-M / x * get_inv(M % x) % M) + M) % M;&#125;LL dp[maxn][2];bool vis[maxn][2];LL DP(int x, int op2)&#123; if (!op2 &amp;&amp; bla[x] == 1) return dp[x][op2] = 1; if (vis[x][op2]) return dp[x][op2]; vis[x][op2] = 1; LL&amp; ans = dp[x][op2]; ans = 1; int k = 0; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x] || !bla[op]) continue; else if (!sta[op]) &#123; if ((DP(op, 0) + DP(op, 1)) % M == 0) k++; else ans = ans * ((DP(op, 0) + DP(op, 1)) % M) % M; &#125; else &#123; if (DP(op, 0) % M == 0) k++; else ans = ans * DP(op, 0) % M; &#125; &#125; if (!sta[x] &amp;&amp; !op2)&#123; if (k &gt;= 2) return ans = 0; LL ans1 = 0; if (k == 1)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x] || !bla[op]) continue; else if (!sta[op]) if ((DP(op, 0) + DP(op, 1)) % M == 0) return ans = ans * DP(op, 0) % M; else if (DP(op, 0) % M == 0) return ans = 0; &#125; &#125; else&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x] || !bla[op]) continue; else if (!sta[op]) ans1 = (ans1 + ans * get_inv((DP(op, 0) + DP(op, 1)) % M) % M * DP(op, 0) % M) % M; else ans1 = (ans1 + ans) % M; &#125; return ans = ans1; &#125; &#125; else if (k &gt; 0) return ans = 0; return ans;&#125;int main()&#123; scanf("%d", &amp;n); int x; for (int i = 1; i &lt;= n - 1; i++)&#123; scanf("%d", &amp;x); Add_Edge(i, x); Add_Edge(x, i); &#125; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;sta[i]); DFS(0); printf("%lld", DP(0, 0)); return 0;&#125; 要注意上文求逆元时对于零的判断（有可能答案模完后为0），这就是我多考虑的情况，然而。。。 B平摊分析线段树，直接维护最大值，最小值，一样就更新答案并返回，否则暴力继续向下找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 131072using namespace std;int set[maxn &lt;&lt; 1];int maxnum[maxn &lt;&lt; 1];int minnum[maxn &lt;&lt; 1];int qx, qy, qd;int line[maxn];int n;void pushup(int l, int r, int o)&#123; if (l == r) return; maxnum[o] = max(maxnum[o &lt;&lt; 1], maxnum[o &lt;&lt; 1 | 1]); minnum[o] = min(minnum[o &lt;&lt; 1], minnum[o &lt;&lt; 1 | 1]);&#125;void pushdown(int l, int r, int o)&#123; if (set[o] != -1 &amp;&amp; l != r)&#123; set[o &lt;&lt; 1] = set[o]; maxnum[o &lt;&lt; 1] = set[o]; minnum[o &lt;&lt; 1] = set[o]; set[o &lt;&lt; 1 | 1] = set[o]; maxnum[o &lt;&lt; 1 | 1] = set[o]; minnum[o &lt;&lt; 1 | 1] = set[o]; set[o] = -1; &#125;&#125;void init(int l, int r, int o)&#123; set[o] = -1; if (l == r)&#123; maxnum[o] = minnum[o] = line[l]; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get(int l, int r, int o)&#123; pushdown(l, r, o); int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; if (maxnum[o] == minnum[o])&#123; if (maxnum[o] == qd) return r - l + 1; else return 0; &#125; else return get(l, mid, o &lt;&lt; 1) + get(mid + 1, r, o &lt;&lt; 1 | 1); &#125; int ans = 0; if (qx &lt;= mid) ans += get(l, mid, o &lt;&lt; 1); if (qy &gt; mid) ans += get(mid + 1, r, o &lt;&lt; 1 | 1); return ans;&#125;void modify(int l, int r, int o)&#123; pushdown(l, r, o); if (qx &lt;= l &amp;&amp; r &lt;= qy)&#123; set[o] = qd; maxnum[o] = minnum[o] = qd; return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) modify(l, mid, o &lt;&lt; 1); if (qy &gt; mid) modify(mid + 1, r, o &lt;&lt; 1 | 1); pushup(l, r, o);&#125;int get_point(int l, int r, int o)&#123; pushdown(l, r, o); if (l == r) return maxnum[o]; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) return get_point(l, mid, o &lt;&lt; 1); else return get_point(mid + 1, r, o &lt;&lt; 1 | 1);&#125;int main()&#123; int m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;line[i]); &#125; init(1, n, 1); int q, x, y; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++)&#123; scanf("%d%d", &amp;x, &amp;y); qx = x; int k = get_point(1, n, 1); qx = x + 1, qy = y, qd = k; int now = get(1, n, 1); printf("%d\n", now); qx = x + 1, qy = y, qd = k; modify(1, n, 1); &#125; return 0;&#125; 然而考场写线段树套平衡树直接GG。。。 C乱搞能A系列，数据真是太弱了。。。然而正解写挂爆零，下面给出乱搞做法，就不说怎么做的了。。。正解每次从左向右更新函数最大值所对应的区间，只有可能在交点处出现交接，所以暴力求交点最大值然后向右继续寻找即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define LL long long int#define INF 2000000000000000005ll#define maxn 1000005using namespace std;int n, q;struct save&#123; LL a, b, c; save(LL a, LL b, LL c) : a(a), b(b), c(c)&#123;&#125; save()&#123;&#125;&#125;s1[maxn], s2[maxn], s3[maxn];bool cmp1(save a, save b)&#123; return (a.a == b.a) ? ((a.b == b.b) ? a.c &lt; b.c : a.b &lt; b.b) : a.a &lt; b.a;&#125;bool cmp2(save a, save b)&#123; return (a.b == b.b) ? ((a.a == b.a) ? a.c &lt; b.c : a.a &lt; b.a) : a.b &lt; b.b;&#125;bool cmp3(save a, save b)&#123; return (a.c == b.c) ? ((a.a == b.a) ? a.b &lt; b.b : a.a &lt; b.a) : a.c &lt; b.c;&#125;template&lt;class T&gt; void read(T&amp; x)&#123; bool f = 1;char ch = getchar(); while (!isdigit(ch) &amp;&amp; ch != '-') ch = getchar(); if (ch == '-') f = 0, ch = getchar();x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar(); if (!f) x = -x;&#125;void init()&#123; sort(s1 + 1, s1 + 1 + n, cmp1); sort(s2 + 1, s2 + 1 + n, cmp2); sort(s3 + 1, s3 + 1 + n, cmp3);&#125;LL cal(LL u, save i)&#123; return i.a * u * u + i.b * u + i.c;&#125;void query(LL u)&#123; LL maxnum = -INF; for (int i = max(1, n - 30); i &lt;= n; i++)&#123; maxnum = max(maxnum, cal(u, s1[i])); if (u &gt; 0) maxnum = max(maxnum, cal(u, s2[i])); else maxnum = max(maxnum, cal(u, s2[n - i + 1])); maxnum = max(maxnum, cal(u, s3[i])); &#125; printf("%lld\n", maxnum);&#125;int main()&#123; read(n), read(q); for (int i = 1; i &lt;= n; i++)&#123; read(s1[i].a), read(s1[i].b), read(s1[i].c); s2[i] = s3[i] = s1[i]; &#125; init(); LL u; for (int i = 1; i &lt;= q; i++)&#123; read(u); query(u); &#125; return 0;&#125; Day6题目 题目分析&amp;代码AKruskal思想，对边排序然后并查集维护，依次更新即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005using namespace std;int n, m, k;struct query&#123; int id, x, w, ans; query(int id, int x, int w) : id(id), x(x), w(w)&#123;ans = 0;&#125; query()&#123;ans = 0;&#125;&#125;q[maxn];struct edge&#123; int x, y, w; edge(int x, int y, int w) : x(x), y(y), w(w)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int ufs[maxn];int size[maxn];int find_root(int x)&#123; return ufs[x] = (ufs[x] == x) ? x : find_root(ufs[x]);&#125;void work()&#123; for (int i = 1; i &lt;= n; i++) ufs[i] = i, size[i] = 1; int now; int cur = 1; for (int i = 1; i &lt;= k; i++)&#123; now = q[i].w; while (cur &lt;= m &amp;&amp; e[cur].w &lt;= now)&#123; int x = find_root(e[cur].x); int y = find_root(e[cur].y); if (x != y)&#123; if (size[x] &gt; size[y]) swap(x, y); ufs[x] = y; size[y] += size[x]; &#125; cur++; &#125; q[i].ans = size[find_root(q[i].x)]; &#125;&#125;bool cmp1(edge a, edge b)&#123; return a.w &lt; b.w;&#125;bool cmp2(query a, query b)&#123; return a.w &lt; b.w;&#125;bool cmp3(query a, query b)&#123; return a.id &lt; b.id;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); int x, y, w; for (int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;w); e[i] = edge(x, y, w); &#125; sort(e + 1, e + 1 + m, cmp1); for (int i = 1; i &lt;= k; i++)&#123; scanf("%d%d", &amp;x, &amp;w); q[i] = query(i, x, w); &#125; sort(q + 1, q + 1 + k, cmp2); work(); sort(q + 1, q + 1 + k, cmp3); for (int i = 1; i &lt;= k; i++) printf("%d\n", q[i].ans); return 0;&#125; B暴力能A系列。。。数据真是太弱了，正解就是模拟，但是需要用数据结构维护一下，支持删除任意一个元素与插入，所以我们使用双平衡树，两棵树内容相同，一个以距离破产的时间为第一关键字，位置为第二关键字排序，另一个以位置为第一关键字排序（昨天晚上发明的东西，感觉非常强大，这样就可以在第一个平衡树里面以位置为键值删除元素了） 同时注意三目运算符的运算顺序为从右向左，且它的优先级小于所有算术运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;#define INF 2000000005#define maxm 105#define maxn 1000005using namespace std;struct ele&#123; int h, v, t, id; ele(int h, int v, int t, int id) : h(h), v(v), t(t), id(id)&#123;&#125; ele()&#123;&#125;&#125;;struct cmp1&#123; bool operator () (ele a, ele b)&#123; int ka, kb; if (a.h &lt;= 0) ka = a.t; else ka = (a.v &gt; 0) ? a.t + (a.h - 1) / a.v + 1 : INF; if (b.h &lt;= 0) kb = b.t; else kb = (b.v &gt; 0) ? b.t + (b.h - 1) / b.v + 1 : INF; if (ka == kb) return a.id &lt; b.id; return ka &lt; kb; &#125;&#125;;struct cmp2&#123; bool operator () (ele a, ele b)&#123; return a.id &lt; b.id; &#125;&#125;;set&lt;ele, cmp1&gt; s1;set&lt;ele, cmp1&gt; :: iterator it1;set&lt;ele, cmp2&gt; s2;set&lt;ele, cmp2&gt; :: iterator it2;int f[maxm][maxm];int line[maxn];int l[maxn];int r[maxn];int n, m;void work()&#123; for (int i = 1; i &lt; n; i++)&#123; it1 = s1.begin(); int op1 = it1 -&gt; id; r[l[op1]] = r[op1]; l[r[op1]] = l[op1]; int now; if (it1 -&gt; h &lt;= 0) now = it1 -&gt; t; else if (it1 -&gt; v == 0) break; else now = it1 -&gt; t + (it1 -&gt; h - 1) / it1 -&gt; v + 1; if (l[op1] &gt;= 1)&#123; it2 = s2.lower_bound(ele(0, 0, 0, l[op1])); int op2 = l[op1]; ele op = *it2; op.h -= it2 -&gt; v * (now - it2 -&gt; t); op.v = ((l[op2] == 0) ? 0 : f[line[l[op2]]][line[op2]]) + ((r[op2] == n + 1) ? 0 : f[line[r[op2]]][line[op2]]); op.t = now; s1.erase(*it2); s2.erase(it2); s1.insert(op); s2.insert(op); &#125; if (r[op1] &lt;= n)&#123; it2 = s2.lower_bound(ele(0, 0, 0, r[op1])); int op2 = r[op1]; ele op = *it2; op.h -= it2 -&gt; v * (now - it2 -&gt; t); op.v = ((l[op2] == 0) ? 0 : f[line[l[op2]]][line[op2]]) + ((r[op2] == n + 1) ? 0 : f[line[r[op2]]][line[op2]]); op.t = now; s1.erase(*it2); s2.erase(it2); s1.insert(op); s2.insert(op); &#125; s2.erase(*it1); s1.erase(it1); &#125; printf("%d", line[s1.begin() -&gt; id]);&#125;template&lt;class T&gt;void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); if (ch == '-') f = 0, ch = getchar(); x = 0; while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); if (!f) x = -x;&#125;int main()&#123; read(m), read(n); for (int i = 1; i &lt;= m; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; read(f[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; read(line[i]); l[i] = i - 1; r[i] = i + 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; int now = ((l[i] == 0) ? 0 : f[line[l[i]]][line[i]]) + ((r[i] == n + 1) ? 0 : f[line[r[i]]][line[i]]); s1.insert(ele(1, now, 0, i)); s2.insert(ele(1, now, 0, i)); &#125; work(); return 0;&#125; C暴力能A系列。。。感觉今天比赛就是暴力比赛。。。数据真是太弱了，正解是FFT，两边算完以后FFT一下，如果仔细想了应该挺好理解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#define pi 3.141592653589793#define maxn 3005#define LL long long intusing namespace std;typedef struct complex&#123; double r, i; complex(double r, double i) : r(r), i(i)&#123;&#125; complex()&#123;&#125;&#125;com;com operator + (com a, com b)&#123; return com(a.r + b.r, a.i + b.i);&#125;com operator - (com a, com b)&#123; return com(a.r - b.r, a.i - b.i);&#125;com operator * (com a, com b)&#123; return com(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);&#125;com operator / (com a, int k)&#123; return com(a.r / k, a.i / k);&#125;com ex(double x)&#123; return com(cos(x), sin(x));&#125;int rev[maxn];void init(int bit)&#123; for (int i = 1; i &lt; (1 &lt;&lt; bit); i++)&#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1)); &#125;&#125;void FFT(com* a, int n, int dft)&#123; for (int i = 0; i &lt; n; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int step = 1; step &lt; n; step &lt;&lt;= 1)&#123; com wn = ex(pi * dft / step); for (int j = 0; j &lt; n; j += step &lt;&lt; 1)&#123; com wnk = com(1, 0); for (int i = j; i &lt; j + step; i++)&#123; com x = a[i]; com y = a[i + step] * wnk; a[i] = x + y; a[i + step] = x - y; wnk = wnk * wn; &#125; &#125; &#125; if (dft == -1) for (int i = 0; i &lt; n; i++) a[i] = a[i] / n;&#125;int n, q;int line[maxn];int save[maxn];com a[maxn];com b[maxn];void recover()&#123; for (int i = 0; i &lt; maxn; i++) a[i] = b[i] = com(0, 0);&#125;int rec[maxn][maxn];void init()&#123; for (int i = 1; i &lt;= n; i++)&#123; if (line[i] &gt; n) continue; recover(); int l1 = 0; for (int j = i; j &gt;= 1; j--)&#123; if (line[j] &gt;= line[i] &amp;&amp; i != j) l1++; a[l1].r++; &#125; int l2 = 0; for (int j = i; j &lt;= n; j++)&#123; if (line[j] &gt; line[i]) l2++; b[l2].r++; &#125; int len = l1 + l2 + 2; int s = 0; while (len)&#123; s++; len &gt;&gt;= 1; &#125; len = (1 &lt;&lt; s); init(s); FFT(a, len, 1); FFT(b, len, 1); for (int j = 0; j &lt; len; j++) a[j] = a[j] * b[j]; FFT(a, len, -1); for (int j = 0; j &lt; len; j++) rec[line[i]][j + 1] += (int) (a[j].r + 0.5); &#125;&#125;template&lt;class T&gt; void read(T&amp; x)&#123; char ch = getchar(); bool f = 1; while (ch != '-' &amp;&amp; !isdigit(ch)) ch = getchar(); x = 0; if (ch == '-') f = 0, ch = getchar(); while (isdigit(ch))&#123; x = 10 * x + ch - '0'; ch = getchar(); &#125; if (!f) x = -x;&#125;int main()&#123; read(n), read(q); for (int i = 1; i &lt;= n; i++) read(line[i]); init(); int x, k; read(k), read(x); printf("%d", rec[x][k]); for (int i = 2; i &lt;= q; i++)&#123; read(k), read(x); printf("\n%d", rec[x][k]); &#125; return 0;&#125; Day7题目 题目分析&amp;代码A构造题，从大到小搞就可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 2000005#define LL long long intusing namespace std;int n;int ans[maxn];int s[10];LL rest;void print(int x)&#123; int ct = 0; while (x)&#123; s[ct++] = x % 10; x /= 10; &#125; for (int i = ct - 1; i &gt;= 0; i--)&#123; putchar('0' + s[i]); &#125;&#125;void get_ans()&#123; int r = 1; ans[0] = n; int cnt = 1; for (int l = n - 1; l &gt;= r; l--)&#123; while (r &lt; l &amp;&amp; l - r &lt;= rest) ans[cnt] = r, rest -= l - r, cnt++, r++; if (r == l &amp;&amp; rest != 0)&#123; printf("-1"); return; &#125; ans[cnt++] = l; &#125; print(ans[0]); for (int i = 1; i &lt; cnt; i++)&#123; putchar(' '); print(ans[i]); &#125;&#125;int main()&#123; scanf("%d%lld", &amp;n, &amp;rest); if (n == 1 || n == 2)&#123; printf("-1"); return 0; &#125; get_ans(); return 0;&#125; B贡献法+元素定序，可以使用双关键字或左等右不等方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 2000005#define LL long long int#define M 1000000007#define lowbit(x) x &amp; -xusing namespace std;struct num&#123; LL val, idx; num(LL val, LL idx) : val(val), idx(idx)&#123;&#125; num()&#123;&#125; bool operator &lt; (const num b) const &#123; return (val == b.val) ? (idx &lt; b.idx) : (val &lt; b.val); &#125;&#125;sline[maxn];LL n, k, line[maxn];LL ifac[105];LL get_inv(LL x)&#123; if (x == 1) return 1; return (-(M / x) * get_inv(M % x) % M + M) % M;&#125;void init()&#123; ifac[0] = 1; for (LL i = 1; i &lt; 105; i++)&#123; ifac[i] = ifac[i - 1] * get_inv(i) % M; &#125;&#125;LL cal(LL n, LL m)&#123; if (m &lt; n) return 0; LL ans = 1; for (LL i = m; i &gt; m - n; i--)&#123; ans = ans * i % M; &#125; return ans * ifac[n] % M;&#125;LL pre[maxn];LL suf[maxn];/*-------------- Pre-Fenwick Tree -----------------------*/LL c[maxn];void add(LL x, LL v)&#123; while (x &lt;= n)&#123; c[x] += v; x += lowbit(x); &#125;&#125;LL get(LL x)&#123; LL ans = 0; while (x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;/*-------------- Pre-Fenwick Tree -----------------------*/LL ihas[maxn];void work()&#123; init(); for (LL i = 1; i &lt;= n; i++)&#123; add(line[i], 1); pre[i] = get(line[i] - 1); &#125; memset(c, 0, sizeof(c)); for (LL i = n; i &gt;= 1; i--)&#123; add(line[i], 1); suf[i] = get(line[i] - 1); &#125; LL ans = 0; for (LL i = 1; i &lt;= n; i++)&#123; ans = (ans + cal(k - 1, pre[i] + suf[i]) * (LL)ihas[line[i]] % M) % M; &#125; printf("%lld", ans);&#125;int main()&#123; scanf("%lld%lld", &amp;n, &amp;k); for (LL i = 1; i &lt;= n; i++)&#123; scanf("%lld", &amp;line[i]); sline[i] = num(line[i], i); &#125; sort(sline + 1, sline + 1 + n); for (LL i = 1; i &lt;= n; i++)&#123; LL k = lower_bound(sline + 1, sline + 1 + n, num(line[i], i)) - sline; ihas[k] = line[i]; line[i] = k; &#125; work(); return 0;&#125; C二叉搜索树性质：跑中序遍历，转化为经典问题的变式，详情见代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 1000005#define INF 2000000005using namespace std;struct num&#123; int val, idx; num(int val, int idx) : val(val), idx(idx)&#123;&#125; num()&#123;&#125; bool operator &lt; (const num b) const &#123; return (val == b.val) ? (idx &lt; b.idx) : (val &lt; b.val); &#125;&#125;sline[maxn];int n;int ch[maxn][2];int val[maxn];int line[maxn];int cnt = 0;void traval(int x)&#123; if (ch[x][0]) traval(ch[x][0]); line[++cnt] = val[x]; if (ch[x][1]) traval(ch[x][1]);&#125;int f[maxn];void init()&#123; traval(1); for (int i = 1; i &lt;= n; i++) line[i] -= i; for (int i = 1; i &lt;= n; i++) sline[i] = num(line[i], i); sort(sline + 1, sline + 1 + n); for (int i = 1; i &lt;= n; i++) line[i] = lower_bound(sline + 1, sline + 1 + n, num(line[i], i)) - sline; for (int i = 1; i &lt;= n; i++) f[i] = INF;&#125;void work()&#123; init(); int ans = 0; for (int i = 1; i &lt;= n; i++)&#123; int k = lower_bound(f, f + n + 1, line[i]) - f; k--; ans = max(ans, k + 1); f[k + 1] = min(f[k + 1], line[i]); &#125; printf("%d", n - ans);&#125;int main()&#123; scanf("%d", &amp;n); int fa, d; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;val[i]); &#125; for (int i = 2; i &lt;= n; i++)&#123; scanf("%d%d", &amp;fa, &amp;d); ch[fa][d] = i; &#125; work(); return 0;&#125; Day8题目 题目分析&amp;代码A直接DP，分类讨论情况即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 1000005using namespace std;int line[maxn];int dp[maxn][2][2];bool vis[maxn][2][2];int n;int DP(int pos, int op, int op2)&#123; if (pos == 0) return 0; if (vis[pos][op][op2]) return dp[pos][op][op2]; vis[pos][op][op2] = 1; int&amp; ans = dp[pos][op][op2]; if (op2)&#123; if (pos - 1 &gt;= 1 &amp;&amp; line[pos - 1] &gt;= line[pos])&#123; return ans = DP(pos - 1, 1, 0) + 1; &#125; else return ans = DP(pos - 1, 0, 0) + 1; &#125; else&#123; if (pos - 1 &gt;= 1 &amp;&amp; line[pos - 1] &gt;= line[pos])&#123; if (op) return ans = 1; if ((pos + 1) &lt;= n &amp;&amp; line[pos + 1] &lt;= line[pos - 1] + 1)&#123; int modify = line[pos] - 1; if (pos - 2 &gt;= 1 &amp;&amp; line[pos - 2] &gt;= modify) return ans = 2; else return ans = DP(pos - 2, 1, 0) + 2; &#125; else return ans = DP(pos - 1, 1, 0) + 1; &#125; else return ans = DP(pos - 1, op, 0) + 1; &#125;&#125;inline void readin(int&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;void work()&#123; int maxnum = 0; for (int i = 1; i &lt;= n; i++)&#123; maxnum = max(maxnum, DP(i, 0, 1)); &#125; printf("%d", maxnum);&#125;int main()&#123; readin(n); for (int i = 1; i &lt;= n; i++) readin(line[i]); work(); return 0;&#125; B规律题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 500005using namespace std;int n;int line[maxn];int idx[maxn];inline void readin(int&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;inline void putout(int x)&#123; putchar(' '); putchar('0' + x);&#125;struct inter&#123; int l, r, ty; inter(int l, int r, int ty) : l(l), r(r), ty(ty)&#123;&#125; inter()&#123;&#125;&#125;save[maxn];int cnt = 0;int ans[maxn];void work()&#123; line[0] = line[1]; line[n + 1] = line[n]; for (int i = 0; i &lt;= n + 1; i++)&#123; if (line[i] == line[i + 1])&#123; int l = i, r = i + 1; int op = line[i]; i++; while (i + 1 &lt;= n + 1 &amp;&amp; line[i + 1] == op) r++, i++; save[++cnt] = inter(l, r, op); &#125; &#125; int cur = 1; int num = 0; for (int i = 1; i &lt;= cnt; i++)&#123; for (int j = save[i].l; j &lt;= save[i].r; j++) ans[j] = save[i].ty; if (save[i].l &gt; cur + 1)&#123; if (i &gt;= 2)&#123; if (save[i - 1].ty &amp;&amp; save[i].ty) &#123; int con = (save[i].l - cur - 1 + 1) &gt;&gt; 1; num = max(num, con); for (int j = cur + 1; j &lt; save[i].l; j++) ans[j] = 1; &#125; else if (save[i - 1].ty)&#123; int con = (save[i].l - cur - 1) &gt;&gt; 1; num = max(num, con); for (int j = cur + 1; j &lt;= cur + con; j++) ans[j] = 1; &#125; else if (save[i].ty)&#123; int con = (save[i].l - cur - 1) &gt;&gt; 1; num = max(num, con); for (int j = save[i].l - 1; j &gt;= save[i].l - con; j--) ans[j] = 1; &#125; else &#123; int con = (save[i].l - cur - 1 + 1) &gt;&gt; 1; num = max(num, con); for (int j = cur + 1; j &lt; save[i].l; j++) ans[j] = 0; &#125; &#125; &#125; cur = save[i].r; &#125; printf("%d\n%d", num, ans[1]); for (int i = 2; i &lt;= n; i++) putout(ans[i]);&#125;int main()&#123; readin(n); for (int i = 1; i &lt;= n; i++) readin(line[i]); work(); return 0;&#125; C倍增法LCA查找，讨论各种情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maxn 300005using namespace std;inline void readin(int&amp; x)&#123; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); x = 0; while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;struct edge&#123; int next, to; edge(int next, int to) : next(next), to(to)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to)&#123; e[++cnt] = edge(h[fr], to); h[fr] = cnt; e[++cnt] = edge(h[to], fr); h[to] = cnt;&#125;int fa[maxn][20];int d[maxn];int size[maxn];int n; void DFS(int x)&#123; for (int i = h[x]; i; i = e[i].next)&#123; int op = e[i].to; if (op == fa[x][0]) continue; d[op] = d[x] + 1; fa[op][0] = x; for (int i = 1; i &lt; 20; i++)&#123; fa[op][i] = fa[fa[op][i - 1]][i - 1]; &#125; DFS(op); size[x] += size[op]; &#125; size[x]++;&#125;void init()&#123; d[1] = 1; DFS(1); fa[1][0] = 1;&#125;void work(int x, int y)&#123; if (x == y)&#123; printf("%d\n", n); return; &#125; int lca; if (d[x] &lt; d[y]) swap(x, y); int k = d[x] - d[y]; int con = 0; int temx = x; int temy = y; while (k)&#123; if (k &amp; 1) x = fa[x][con]; k &gt;&gt;= 1; con++; &#125; if (x == y) lca = x; else&#123; int now = 19; while (true)&#123; while (now &gt;= 0 &amp;&amp; fa[x][now] == fa[y][now]) now--; if (now == -1)&#123; lca = fa[x][0]; break; &#125; else&#123; x = fa[x][now]; y = fa[y][now]; &#125; now = 19; &#125; &#125; int dis = (d[temx] + d[temy]) - (d[lca] &lt;&lt; 1); if (dis &amp; 1) &#123; printf("0\n"); return; &#125; if (d[temx] - d[lca] == d[temy] - d[lca])&#123; int rem = size[x] + size[y]; printf("%d\n", n - rem); return; &#125; x = temx, y = temy; if (d[x] - d[lca] &lt; (dis &gt;&gt; 1)) swap(x, y); dis &gt;&gt;= 1; dis--; con = 0; while (dis)&#123; if (dis &amp; 1) x = fa[x][con]; dis &gt;&gt;= 1; con++; &#125; int rem = size[x]; printf("%d\n", size[fa[x][0]] - rem);&#125;int main()&#123; readin(n); int x, y, m; for (int i = 1; i &lt; n; i++)&#123; readin(x), readin(y); Add_Edge(x, y); &#125; init(); readin(m); for (int i = 1; i &lt;= m; i++)&#123; readin(x), readin(y); work(x, y); &#125; return 0;&#125; 后记这就是这几天的测试AC代码，感觉自己确实还是存在一些知识的欠缺和问题，希望能够通过这次集训有所进步吧]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>多校联训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东北师大附中多校联训总结]]></title>
    <url>%2F2017%2F08%2F14%2F%E4%B8%9C%E5%8C%97%E5%B8%88%E5%A4%A7%E9%99%84%E4%B8%AD%E5%A4%9A%E6%A0%A1%E8%81%94%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言因为我太弱，所以在这段时间里去东北师大附中参加了一个八天的联训。。。下面就抒(kou)发(hu)一下这次联训的相关感想，记点流水账 总结感觉这次联训还是十分地有意义的，学到了不少的东西（明明没去的时候还那么鄙视来着），其中最有价值的就是模拟参赛时获取的许多比赛经验与策略方法，我认为这是我个人最大的提升 但是讲的东西其实也不是那么简单，总之来说就是参差不齐吧，感觉好像不太像是NOIP这个层级的内容，所以应该就是用来在NOIP时扩展思路的，同时也为接下来的省选和国赛打基础，相关的训练内容会在另一篇文章中进行发布，近期也会写许多的算法类文章，因为发现自己真的是太弱了。。。所以很有必要对一些知识点进行一些明确的归纳与总结 首先置顶一个考试策略体系： 二十分钟原则：即每道题目如果二十分钟想不出来，无论想到哪里都要换一道题，不要在一道题上搞太久（当然，这是对于NOIP来说，对于其他比赛就要适当调整思考时间） 检查题目原则：如果把所有题都写（A）完（K）了，不要安然卧于榻上，应该先仔细检查，静态查错， 如果时间足够进行对拍，大数据小数据都应该包含，防止意外爆零 暴力先行原则：这个我贯彻的其实不是很好（所以有一天死的很惨），主要适用于难度高的比赛，如果评估自己很难短时内想到正解，就要打尽可能多的暴力，不要考试快结束再这样做 心态：考试时要放松心态，给自己一定的心理暗示，屏蔽外界干扰因素，像平常练习一样考试，这是非常重要的 思考：思考题目时要抓住主要问题，分析问题特征，以此寻找问题的突破口 这就是我这几天的一个重要成果，还有更多的考试经验，放在每天的总结之中 下面开始进行总结： Day0报到日，刚来的时候找宾馆找了好久。。。自驾游就是闹心终于安家落户以后，就到东北师大附中报到，然后回宾馆打了一场百度之星的资格赛就睡觉了 Day1听说今天有入营测试，不知道大家都是什么水平。。。 比赛经过发题挺早的，提前十分钟就放上去了，先是看第一题，然后好像挺难的样子，推$O(1)$的公式推了半天，然后突然看到数据范围。。。就直接$O(n\log n)$水过了，于是看第二题。基本就是一个简单的DP，但是我用树状数组优化了一下，跑了$O(n\log n)$，然而正解是$O(n)$的，各种情况讨论还不如我这样写。。。好像前两题挺快搞过了，然后就一直想第三题，发现第三题好像很难的样子，从树剖想到点分好像都没什么思路，于是写了一个巨长的树剖暴力交上去了，搞到了$20$分 于是今天似乎就是$220$了？最后看结果，第一题居然被卡掉了$30$，最后$190$，调了许久，终于被GGN大佬的一句话点醒：数组开小了一位。巧的是他也是这个问题，然后我们一起被卡了$30$。。。 总结 不要把简单题想得太难，题面一定要看全（包括数据范围，提示什么的） 数组一定要开够空间，空间紧的时候一定要进行细致精密的内存占用计算，否则就会很惨。。。（其实今天只是被卡掉$30$还真是很幸运） ST表需要预处理2的幂，还需要预处理每个数对2取对数后向下取整的结果，否则很容易超时 后记讲课忘了带录音笔了，jcy大佬讲的太快有点没跟上，还好最后想明白了 考完以后老师劝同学们仔细选择层次，突然一种要被劝退的预感。。。 下午就是ljss大佬讲线代加各种变换，虽然以前都大致看过，但到后来还是听得一脸GG。。。留坑待补 Day2比赛经过发题又是挺早的，于是开始搞第一题，第一反应就是用KMP乱搞，正解其实也是，但是不知为什么，考场上好像KMP的一些性质有些忘了，于是脑抽硬上后缀数组，结果后缀数组板子居然忘了，于是现场发明基数排序求后缀数组算法，处理完后各种情况讨论，虽然测了许多点都过了，但还是一副很虚的样子，就滚去看第二题了，联想到NEYC集训时的一个网络流模型，但好像不是非常对，而且时间复杂度也不允许。。。想了一会丢了一个$O(n^2)$DP暴力跑了。。。第三题好像是一道数学题，推完公式过了两个样例中的一个，检查了挺长时间看起来没什么问题就弃疗了 最后看成绩，也就是$120$,最后一题大家统一爆零了好开心～ 总结 仔细思考题目，根据考试类别机智的判断题目方法，不要简单题用高大上的算法搞，容易写挂。。。当然如果实在想不到简单做法也一定要把想到的算法写出来 合理分配考试时间，迅速检查计算数学公式 在无法预处理逆元的时候应该使用快速幂方法来求，而不是线性预处理时使用的方法（常数问题） Day3好像这天AK了。。。 比赛经过上来看第一题，发现第一题好像不太会，觉得自己图论好弱，想到一定的时间后就去看第二题，然后用递归思考的方法搞掉了这道题（每次求出最大值的位置），然后看第三题发现更加不可做，于是就滚回去搞第一题，画了几个图，猜了一下结论，然后就写上了。于是现在集中搞第三题，一开始也没什么思路，后来想还是应该搞清楚与非的运算方法，把01表写了一下，然后又写了几个序列，就发现了结论。。。数据结构搞搞就出来了，考试结束前还把第二题Judge了一下，感觉是没什么问题了 于是就AK了。。。 总结 合理分配考试时间 从多个角度思考问题 Day4好像又AK了。。（假 比赛经过好像把一二题都跳了。。。然后先把第三题搞了出来，后来第一题贡献法水过，第二题数据范围允许暴力预处理，然后对了几个拍，却忘了交代码。。。内心冷静沉着的把前两道题交上了，后来第三题被卡空格，加上以后也过了，总之还是挺可惜，被卡掉了$100$分 总结好像没什么可以总结的。。。AK并不是一件好事 Day5前两天果然是把RP都用光了。。。哦对了好像自从今天开始每天都有人AK 比赛经过看了一会题，很快就发现今天的题目好像很难的样子，第一题打了一个神奇的树型DP，后来加了一些考虑的情况，结果最常用的情况忘记返回答案了，第二题暴力上线段树套平衡树直接T，第三题WA爆零 于是今天就是$50$分，%%%AK大佬，于是今天就是死得非常惨啊，讲题前直接把前两题玩过了，第二题使用了线段树加平摊分析的方法，真是没想到居然会用到这种东西。。。 总结 及时检查答案，不要为了做题牺牲检查的时间 情况讨论要详尽，并且要特别注意情况之间出现的处理差异，因为这些差异有可能是对的，但也有些是忘记写了什么东西造成的 不能老是想着打正解。。。正解很虚时（比如样例都过不了时）要写暴力 Day6今天本来也是要挂的来着。。。 比赛经过首先搞掉第一题，用$Kruskal$的方法，然后第二题一脸mengbi，题都看不懂，于是一直乱搞第三题，本来想到了一个FFT的做法，却因为“这不是NOIP模拟赛么，怎么会有这些东西”就一直思考简单的做法，发明了一个什么二维单调栈，怎么调都不对，考试快结束时发现复杂度是暴力的，否则就会WA，于是浪费了大量的时间，决定打暴力时，发现第三题暴力不是很好打，于是做出了今天最机智的决定：打第二题暴力，然后在考试时间剩20分钟时开始写，居然打完了，一副对的样子 然后去看成绩，100+90+0=190 。。。居然排得还挺高，但还是%%%AK大佬zgz 所以有的时候，暴力也是十分重要的。。。一个纯模拟的暴力没加任何优化居然跑了$90$??? 总结 严格遵守二十分钟原则 虽然是NOIP模拟赛，但在实在没有简单的思路时也一定要把一定对的东西写上，不要为了一个存在性未知的简单算法浪费太多的时间（适当想一想还是可以的） 暴力一定要写，说不定就A了呢？ 清空数组时一定要认真考虑，宁可多清空一些，也不要清空得不彻底，否则很容易导致问题 三目运算符的运算顺序是从右向左 三目运算符的优先级小于算术运算符，这一点十分重要 Day7题目又变得简单了。。。 比赛经过第一题构造题，持续思考20多分钟搞出来了，第二题贡献法瞬间水过，第三题想了挺长的时间，后来想到遍历搜索树，然后转化为经典问题水过了 于是就AK了。。。好像挺好多人都AK了??? Day8最后一天了，感觉还是挺好的（雾 比赛经过第一题随便DP一下，讨论各种情况，第二题找规律水过，第三题暴力LCA加DFS乱搞，并且各种情况讨论 最后不知为何被卡掉$5$分，在有倍增求LCA的程序中深度数组要从1开始??? 所以是$295$，一副很弱的样子，好像又有许多人AK了 总结 本地测试时的数据要尽可能多的涵盖情况，而且一定要包含极限情况与边界情况，这样的测试用例才是有价值的 Day8.5联训终音下午开始颁奖了，我这么弱居然是rank2??? 然后领了一个游戏键盘就回家了。。。（其实是机械键盘，感觉适合用来编程，不知为什么就被强说成是用来打游戏的了），现在正在用，手感的确是挺好的（雾 全文后记终于记完流水账了，好累啊。。。感觉自己还是好弱，要学的东西真的很多，今年应该是十分关键的一年呢，去年各种乱搞感觉都不是那么正式啊，不知道最后结果会是如何，希望能够是good end吧]]></content>
      <tags>
        <tag>参赛总结</tag>
        <tag>感悟</tag>
        <tag>NOIP模拟赛</tag>
        <tag>多校联训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD&LCM相关问题讲解]]></title>
    <url>%2F2017%2F08%2F04%2FGCD-LCM%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言概括：《莫比乌斯反演总结》进阶篇 不得不说这篇文章可能会是至今为止所有文章中最长的一篇，主要内容是借51nod上的与gcd&amp;lcm有关的题目进行的一个总结，由于我喜欢把许多东西整合进一篇文章，所以。。。 讲解重新调整了一下顺序，由浅入深，深入浅出，为了简化文章，不再安排题目版面，需要提交者可自行查找51nod内对应题目 基本就是题目的题解，但是循序渐进，反映思维过程 由于我比较无聊，把代码都写了一遍，有多种方法的，就把所有我想到的方法也都写成了代码，所以文章篇幅不小。。。 还有，本文属于《莫比乌斯反演总结》的进阶篇，故下面的一些题目只给出公式最终形式，不会的可以自补《莫比乌斯反演总结》 顺带着会把杜教筛原理重新带一遍，引入新的思路 先预告一下之后的两篇讲解《杜教筛应用进阶》，《洲阁筛讲解》 洲阁筛以后呢？可能又是应用，然后再说一说叶筛（叶氏筛法） 前置技能： 基础数论知识 莫比乌斯反演 Dirichlet卷积 杜教筛 分块法 Problem 1.1 : 最大公约数输入2个正整数A，B，求A与B的最大公约数$(1&lt;= A,B &lt;= 10^9)$ 题目分析前置技能 代码12345678910111213141516#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long intusing namespace std;LL gcd(LL a, LL b)&#123; return (!b) ? a : gcd(b, a % b);&#125;int main()&#123; /*freopen("gcd.in", "r", stdin); freopen("gcd.out", "w", stdout);*/ LL a, b; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", gcd(a, b)); return 0;&#125; Problem 1.2 : 最小公倍数输入2个正整数A，B，求A与B的最小公倍数。$(1&lt;= A,B &lt;= 10^9)$ 题目分析前置技能 代码12345678910111213141516#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long intusing namespace std;LL gcd(LL a, LL b)&#123; return (!b) ? a : gcd(b, a % b);&#125;int main()&#123; /*freopen("lcm.in", "r", stdin); freopen("lcm.out", "w", stdout);*/ LL a, b; scanf("%lld%lld", &amp;a, &amp;b); printf("%lld", a * b / gcd(a, b)); return 0;&#125; Problem 2.1 最大公约数之和给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 61,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15$(n &lt;= 10^9)$ 题目分析经典莫比乌斯反演&amp;$Dirichlet$卷积应用，最终公式：\sum_{d \mid n}\frac{n}{d} * \varphi(d) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 100005#define LL long long intusing namespace std;int cnt;int p[maxn];bool vis[maxn];void init()&#123; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++] = i; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;int cal_phi(int x)&#123; int con = (int) sqrt(x); int ans = 1; for (int i = 2; i &lt;= con; i++)&#123; if (!vis[i] &amp;&amp; x % i == 0)&#123; ans *= i - 1; x /= i; while (x % i == 0)&#123; ans *= i; x /= i; &#125; &#125; &#125; if (x != 1) ans *= x - 1; return ans;&#125;void work(int n)&#123; int con = (int)sqrt(n); LL ans = 0; for (int i = 1; i &lt; con; i++)&#123; if (n % i == 0)&#123; ans += (LL)cal_phi(i) * n / i; ans += (LL)cal_phi(n / i) * i; &#125; &#125; if (con * con == n)&#123; ans += (LL)cal_phi(con) * con; &#125; else if (n % con == 0)&#123; ans += (LL)cal_phi(con) * n / con; ans += (LL)cal_phi(n / con) * con; &#125; printf("%lld", ans);&#125;int main()&#123; /*freopen("sum.in", "r", stdin); freopen("sum.out", "w", stdout);*/ init(); int n; scanf("%d", &amp;n); work(n); return 0;&#125; Problem 2.2 最小公倍数之和给出一个n，求1-n这n个数，同n的最小公倍数的和。例如：n = 6，1,2,3,4,5,6 同6的最小公倍数分别为6,6,6,12,30,6，加在一起 = 66。由于结果很大，输出Mod 1000000007的结果$(n \leq 10^9)$多组数据，数据组数$\leq 50000$ 题目分析经典莫比乌斯反演&amp;$Dirichlet$卷积应用，最终公式：n+{n\over 2}\sum_{d|n,d≠n} \varphi(d)*d,其实精确地讲是最大公约数和的方法类比，用$\varphi$的意义来进行公式的推导运算 然而经尝试，上面的并不能过。。。，因为它要分解过多次质因数，用于求$\varphi$，那么，我们如何减少计算$\varphi$的花费呢？ 所以我们开始使用一种新的技巧：质因数分析我们展开上面公式中的每一个$\varphi$函数，就得到了这样的东西：\sum_{d|n,d≠n} \varphi(d)*d=\prod_{i=1}^B\sum_{j=0}^{a[i]} \varphi(p[i]^j)* p[i]^j 然后我们再使用一个技巧：和式化积式就能把所有的和式归到一起，直接用积式来进行表示，就是这个样子：\prod_{i=1}^B 1+\sum_{j=1}^{a[i]}(p[i]-1)p[i]^{j-1}* p[i]^j 然后整理一下可以得到：\prod_{i=1}^B 1+{p[i]^{2*a[i]+1}-p[i]\over {p[i]+1}}再暴力分解质因数计算，就可以了 然而肯定还有人觉得奇怪，不对啊，我也是这样写了，为什么就没有过呢？那是因为，本题实际上还有一个技巧：平方根规约（其实就是卡常数啦） 那就是，我们在分解质因数的时候，不是使用了$\sqrt{n}$来进行分解的吗？但是，随着$n$的减少，我们可以随时更新这个$\sqrt{n}$，这也是我以前没有发现的，这样，代码效率能提升许多，但实际上要是想卡的话也是随手卡的 代码先附上第一个版本，未使用质因数分析时的代码，TLE：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#define maxn 40005#define M 1000000007#define LL long long intusing namespace std;int p[maxn];bool vis[maxn];int cnt;int phi[maxn];void init()&#123; phi[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; phi[i * p[j]] = phi[i] * (p[j] - 1); if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125;&#125;map&lt;int, int&gt; save;int cal_phi(int x)&#123; if (x &lt; maxn) return phi[x]; if (save.count(x)) return save[x]; int t = x; int con = (int) sqrt(x); int ans = 1; for (int i = 2; i &lt;= con; i++)&#123; if (!vis[i] &amp;&amp; x % i == 0)&#123; ans *= i - 1; x /= i; while (x % i == 0)&#123; ans *= i; x /= i; &#125; &#125; &#125; if (x != 1) ans *= x - 1; return save[t] = ans;&#125;void work(int n)&#123; LL ans = 0; int con = (int) sqrt(n); for (int i = 1; i &lt; con; i++)&#123; if (n % i == 0)&#123; ans = (ans + (LL) n * i % M * cal_phi(i) % M) % M; ans = (ans + (LL) n * (n / i) % M * cal_phi(n / i) % M) % M; &#125; &#125; if (con * con == n)&#123; ans = (ans + (LL) n * con % M * cal_phi(con) % M) % M; &#125; else if (n % con == 0)&#123; ans = (ans + (LL) n * con % M * cal_phi(con) % M) % M; ans = (ans + (LL) n * (n / con) % M * cal_phi(n / con) % M) % M; &#125; ans = (M + ans - n) % M; ans = ans * ((M + 1) &gt;&gt; 1) % M; ans = (ans + n) % M; printf("%lld\n", ans);&#125;int main()&#123; /*freopen("sum2.in", "r", stdin); freopen("sum2.out", "w", stdout);*/ init(); int T, n; scanf("%d", &amp;T); while (T--)&#123; scanf("%d", &amp;n); work(n); &#125; return 0;&#125; 然后是AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 100005#define M 1000000007#define LL long long intusing namespace std;int p[maxn];int cnt;bool vis[maxn];void init()&#123; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i]) p[cnt++] = i; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125;void work(int n)&#123; LL ans = 1; LL now = 1; int t = n; int con = (int) sqrt(n); for (int i = 2; i &lt;= con; i++)&#123; if (!vis[i] &amp;&amp; n % i == 0)&#123; while (n % i == 0)&#123; now *= i; n /= i; &#125; now *= now; now = (now - 1) / (i + 1); now *= i; ans = ans * (now + 1) % M; now = 1; con = (int) sqrt(n); &#125; &#125; if (n != 1) ans = ans * (((LL)n * n - n + 1) % M) % M; ans = (ans + 1) * t % M; ans = ans * ((M + 1) &gt;&gt; 1) % M; printf("%lld\n", ans);&#125;int main()&#123; /*freopen("sum2.in", "r", stdin); freopen("sum2.out", "w", stdout);*/ init(); int T, n; scanf("%d", &amp;T); while (T--)&#123; scanf("%d", &amp;n); work(n); &#125; return 0;&#125; 为什么大家做这题都这么纠结？本弱交了两次就过了。。。 Problem 3.1 最大公约数之和 V2给出一个数N，输出小于等于N的所有数，两两之间的最大公约数之和$(2 &lt;= N &lt;= 5000000)$ 相当于计算这段程序（程序中的gcd(i,j)表示i与j的最大公约数）：123456G=0;for(i=1;i&lt;N;i++) for(j=i+1;j&lt;=N;j++) &#123; G+=gcd(i,j); &#125; 令$T$表示后面用作输入测试的数的数量，有$1 &lt;= T &lt;= 50000$ 题目分析这道题看似要复杂一些，实际上就是莫比乌斯反演的裸题，但如果你真的只是用莫比乌斯反演的话。。。算了先给出最终公式吧：\sum_{T=1}^{MIN(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T} \right \rfloor \left(id*\mu\right)(T)（不会的自补《莫比乌斯反演总结》）好的，然而你交上去发现会TLE。。。其实很明显，复杂度不对 那么，我们还得优化一些，由于本题有$n=m$的性质（不懂吗？那你题做的太少了。。。），所以我们可以继续使用$\varphi$来乱搞，得到如下的式子：\sum{i=1}^{n}\varphi * id其实非常简单啦，然后你就对它$Dirichlet$一下子就好了 然而我比较无聊，觉得这样还不够快，于是写了一个线性筛的。。。确实是比上面的要快许(yi)多(dian) 代码第一份，莫比乌斯反演的，TLE12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 5000005#define LL long long intusing namespace std;bool vis[maxn];int cnt;int p[maxn];int mu[maxn];LL F[maxn];void init()&#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (p[j] * i &gt;= maxn) break; vis[p[j] * i] = 1; mu[p[j] * i] = mu[i] * (-1); if (i % p[j] == 0)&#123; mu[i * p[j]] = 0; break; &#125; &#125; &#125; for (int i = 1; i &lt; maxn; i++)&#123; for (int j = 1; i * j &lt; maxn; j++)&#123; F[i * j] += i * mu[j]; &#125; &#125; for (int i = 1; i &lt; maxn; i++) F[i] += F[i - 1];&#125;void cal(int n)&#123; LL ans = 0; for (int i = 1; i &lt;= n; i++)&#123; int next = n / (n / i); ans += (F[next] - F[i - 1]) * (n / i) * (n / i); i = next; &#125; ans -= (LL) n * (n + 1) &gt;&gt; 1; ans &gt;&gt;= 1; printf("%lld\n", ans);&#125;int main()&#123; /*freopen("gcd2.in", "r", stdin); freopen("gcd2.out", "w", stdout);*/ init(); int T, a; scanf("%d", &amp;T); while (T--)&#123; scanf("%d", &amp;a); cal(a); &#125; return 0;&#125; 第二份，$Dirichlet$卷积的AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 5000005#define LL long long intusing namespace std;bool vis[maxn];int cnt;int p[maxn];LL phi[maxn];LL pre[maxn];void init()&#123; phi[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (p[j] * i &gt;= maxn) break; vis[p[j] * i] = 1; phi[i * p[j]] = phi[i] * (p[j] - 1); if (i % p[j] == 0)&#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125; for (int i = 1; i &lt; maxn; i++)&#123; for (int j = 1; i * j &lt; maxn; j++)&#123; pre[i * j] += phi[i] * j; &#125; &#125; for (int i = 1; i &lt; maxn; i++) pre[i] += pre[i - 1]; for (int i = 1; i &lt; maxn; i++) pre[i] -= (LL)i * (i + 1) &gt;&gt; 1;&#125;int main()&#123; /*freopen("gcd2.in", "r", stdin); freopen("gcd2.out", "w", stdout);*/ init(); int T; scanf("%d", &amp;T); LL n; while (T--)&#123; scanf("%lld", &amp;n); printf("%lld\n", pre[n]); &#125; return 0;&#125; 第三份，线性筛，AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 5000005#define LL long long intusing namespace std;bool vis[maxn];int cnt;int p[maxn];int num[maxn];LL F[maxn];void init()&#123; num[1] = 1; F[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; num[i] = 1; F[i] = (i &lt;&lt; 1) - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= maxn) break; vis[i * p[j]] = 1; num[i * p[j]] = i; F[i * p[j]] = F[i] * ((p[j] &lt;&lt; 1) - 1); if (i % p[j] == 0)&#123; num[i * p[j]] = num[i]; F[i * p[j]] = F[i] * p[j] + F[num[i]] * (i / num[i]) * (p[j] - 1); break; &#125; &#125; &#125; for (int i = 1; i &lt; maxn; i++) F[i] += F[i - 1]; for (int i = 1; i &lt; maxn; i++) F[i] -= (LL)i * (i + 1) &gt;&gt; 1;&#125;int main()&#123; /*freopen("gcd2.in", "r", stdin); freopen("gcd2.out", "w", stdout);*/ init(); int T; scanf("%d", &amp;T); LL n; while (T--)&#123; scanf("%lld", &amp;n); printf("%lld\n", F[n]); &#125; return 0;&#125; Problem 4.1 最大公约数之和 V3给出一个数N，输出小于等于N的所有数，两两之间的最大公约数之和$(2 &lt;= N &lt;= 10^10)$ 相当于计算这段程序（程序中的gcd(i,j)表示i与j的最大公约数）：由于结果很大，输出Mod 1000000007的结果。123456G=0;for(i=1;i&lt;N;i++) for(j=1;j&lt;=N;j++) &#123; G = (G + gcd(i,j)) % 1000000007; &#125; 单组数据 题目分析显然这么大的数肯定是要用到一些黑科技啦，有个十分强大算法，名叫杜教筛，可以在$O(n^{\frac{2}{3}})$的复杂度内求出$\sum_{i = 1} ^ {n} F(i)$（其中$F$是一些比较特殊的函数，下文会说到），即$F$的前缀和 是不是很强大呀？ 用在本题里面，是优化什么部位呢？那就是中间分块法的时候的函数和区间，用在这里，可以证明本题能够在$O(n^{\frac{5}{6}})$的复杂度内解决，然而这个是用微积分证明的，实际很难跑满 所以本题就可以这样过了，具体如何杜教筛，可以参考《杜教筛原理详解》或下文讲解（那篇写的不是非常好） 其实这题有两种写法，一个是莫比乌斯反演的，另一个是继续利用$\varphi$乱搞的（51nod的题全都是$n=m$的。。。) 最终公式：莫比乌斯反演：\sum_{T=1}^{MIN(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T} \right \rfloor \left(id*\mu\right)(T)$\varphi$乱搞：\sum{i=1}^{n}i * S(\left\lfloor\frac{n}{i}\right\rfloor)上述公式均需与$\varphi$杜教筛公式：S(n) = \frac{n * (n + 1)} - \sum_{i = 2}^{n} S(\left\lfloor\frac{n}{i}\right\rfloor)搭配食用 代码第一份，利用$\varphi$直接乱搞，AC：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt;#define maxn 5000005#define M 1000000007#define LL long long intusing namespace std;int p[maxn];bool vis[maxn];int cnt;int bound;int phi[maxn];void init()&#123; phi[1] = 1; for (int i = 2; i &lt; bound; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= bound) break; vis[i * p[j]] = 1; phi[i * p[j]] = phi[i] * (p[j] - 1); if (i % p[j] == 0)&#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125; for (int i = 1; i &lt; bound; i++) phi[i] = (phi[i] + phi[i - 1]) % M;&#125;map&lt;LL, LL&gt; save;LL dyh(LL x)&#123; if (x &lt; bound) return phi[x]; if (save.count(x)) return save[x]; LL ans = (x &amp; 1) ? (x % M) * (((x + 1) &gt;&gt; 1) % M) : ((x &gt;&gt; 1) % M) * ((x + 1) % M); ans %= M; for (LL i = 2; i &lt;= x; i++)&#123; LL next = x / (x / i); ans = (M + ans - dyh(x / i) * ((next - i + 1) % M) % M) % M; i = next; &#125; return save[x] = ans;&#125;void work(LL n)&#123; LL ans = 0; for (LL i = 1; i &lt;= n; i++)&#123; LL next = n / (n / i); ans = (ans + dyh(n / i) * ((next - i + 1) % M) % M * ((next + i) % M) % M * ((M + 1) &gt;&gt; 1) % M) % M; i = next; &#125; LL rec = (n &amp; 1) ? (n % M) * (((n + 1) &gt;&gt; 1) % M) : ((n &gt;&gt; 1) % M) * ((n + 1) % M); rec %= M; ans = (M + ans - rec) % M; ans = ans * 2 % M; ans = (ans + rec) % M; printf("%lld", ans);&#125;int main()&#123; /*freopen("gcd3.in", "r", stdin); freopen("gcd3.out", "w", stdout);*/ LL n; scanf("%lld", &amp;n); bound = (int)pow(n, 2.0 / 3) + 1; init(); work(n); return 0;&#125; 第二份，使用莫比乌斯反演，AC：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#define LL long long int #define maxn 5000005#define M 1000000007using namespace std;int p[maxn];bool vis[maxn];int cnt;int bound;int phi[maxn];void init()&#123; phi[1] = 1; for (int i = 2; i &lt; bound; i++)&#123; if (!vis[i])&#123; p[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * p[j] &gt;= bound) break; vis[i * p[j]] = 1; phi[i * p[j]] = phi[i] * (p[j] - 1); if (i % p[j] == 0)&#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125; for (int i = 1; i &lt; bound; i++) phi[i] = (phi[i - 1] + phi[i]) % M;&#125;map&lt;LL, LL&gt; save;LL dyh(LL x)&#123; if (x &lt; bound) return phi[x]; if (save.count(x)) return save[x]; LL ans = x % M * ((x + 1) % M) % M * ((M + 1) &gt;&gt; 1) % M; for (LL i = 2; i &lt;= x; i++)&#123;///////////////Serious Mistake!!! LL next = x / (x / i); ans = (M + ans - dyh(x / i) * ((next - i + 1) % M) % M) % M; i = next; &#125; return save[x] = ans;&#125;void work(LL n)&#123; LL ans = 0; for (LL i = 1; i &lt;= n; i++)&#123; LL next = n / (n / i); ans = (ans + (n / i) % M * ((n / i) % M) % M * (M + (dyh(next) - dyh(i - 1)) % M) % M) % M; i = next; &#125; /*LL rec = n % M * ((n + 1) % M) % M * ((M + 1) &gt;&gt; 1) % M; ans = (M + ans - rec) % M; ans = ans * 2 % M; ans = (ans + rec) % M;*/ printf("%lld", ans);&#125;int main()&#123; /*freopen("gcd3.in", "r", stdin); freopen("gcd3.out" ,"w", stdout);*/ LL n; scanf("%lld", &amp;n); bound = (int) pow(n, 2.0 / 3) + 1; init(); work(n); return 0;&#125; 第三份，不是我写的，花了60个盾买的最快代码，感觉就是各种取模转加减。。。然而看起来挺短的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#define Rep(x,a,b) for (int x=a;x&lt;=(int)b;x++)#define Drp(x,a,b) for (int x=a;x&gt;=(int)b;x--)#define Cross(x,a) for (int x=Hd[a];~x;x=Nx[x])#define ll long long#define INF (1&lt;&lt;29)#define PII pair&lt;int,int&gt;#define PDD pair&lt;double,double&gt;#define mk(a,b) make_pair(a,b)#define fr first#define sc secondusing namespace std;inline ll Rd()&#123; ll x=0;int ch=getchar(),f=1; while (!isdigit(ch)&amp;&amp;(ch!='-')&amp;&amp;(ch!=EOF)) ch=getchar(); if (ch=='-')&#123;f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();&#125; return x*f;&#125;inline void Rt(ll x)&#123; if (x&lt;0) putchar('-'),x=-x; if (x&gt;=10) Rt(x/10),putchar(x%10+'0'); else putchar(x+'0');&#125;const int N=5000000;int Mn[N+5],Phi[N+5],Prm[400000],Cnt;int Ans[2160],Vs[2160];#define P 1000000007int Sum(ll x)&#123; return (x%P)*((x+1)%P)%P*500000004%P;&#125;int Calc(ll Ori,ll Div)&#123; ll n=Ori/Div; if (n&lt;=N) return Phi[n]; if (Vs[Div]) return Ans[Div]; Vs[Div]=1;Ans[Div]=Sum(n); for (int i=1;(ll)i*i&lt;=n;i++)&#123; if (i&gt;1&amp;&amp;i!=n/i) Ans[Div]-=Calc(Ori,Div*i),Ans[Div]+=Ans[Div]&lt;0?P:0; Ans[Div]-=(n/i-n/(i+1))*Phi[i]%P,Ans[Div]+=Ans[Div]&lt;0?P:0; &#125; return Ans[Div];&#125;int main()&#123; Phi[1]=1; Rep(i,2,N)&#123; if (!Mn[i]) Prm[Mn[i]=++Cnt]=i,Phi[i]=i-1; Rep(j,1,Cnt)&#123; int k=Prm[j]*i; if (k&gt;N) break; Mn[k]=j; if (j==Mn[i])&#123;Phi[k]=Phi[i]*Prm[j];break;&#125; else Phi[k]=Phi[i]*(Prm[j]-1); &#125; &#125; Rep(i,2,N) Phi[i]+=Phi[i-1],Phi[i]-=Phi[i]&gt;=P?P:0; ll n=Rd(); int Ans=0; for (int i=1;(ll)i*i&lt;=n;i++)&#123; if (i!=n/i) Ans+=(ll)i*Calc(n,i)%P,Ans-=Ans&gt;=P?P:0; Ans+=(ll)(Sum(n/i)+P-Sum(n/(i+1)))%P*Phi[i]%P,Ans-=Ans&gt;=P?P:0; &#125; Ans=Ans*2%P+P-Sum(n),Ans-=Ans&gt;=P?P:0; Rt(Ans);&#125; 总结总结一下，大致处理这种问题，就是使用莫比乌斯反演+$Dirichlet$卷积或是使用$\varphi$乱搞法，具体怎么乱搞，上面展示的已经很清楚了，不太懂的话可以参考《莫比乌斯反演总结》 再列举一下学到的技巧： 质因子分析 和式化积式 平方根规约 取模转加减 然后下面顺便重讲一下杜教筛 re:杜教筛讲解杜教筛是dyh大神从$Project Euler$引入的高速函数前缀和求法（其实和筛没什么关系？），现已经在OI界普及，成为数论中必不可少的算法之一 学习要点有二： 找到一个易于求出前缀和的函数与待求函数做$Dirichlet$卷积，同时要求所得函数也易于求出前缀和 理解复杂度的证明方法 基本就是这样，仔细想想$\varphi$与$\mu$的杜教筛法，下面举一个更难的例子：求$\sum_{i=1}^n\varphi(i)*i$ 我们只要将它与$id$进行$Dirichlet$卷积就可以，我们做如下推导： 下面记录一下杜教筛复杂度的证明方法：]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四边形不等式详解]]></title>
    <url>%2F2017%2F08%2F02%2F%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言最近学习了一下四边形不等式优化的原理，感觉挺有用的，下面对其进行小结 讲解首先附上《四边形不等式》讲解材料： 然后说一下学习重点： （重点）理解并尝试证明在w函数满足四边形不等式时，m函数也满足四边形不等式 （重点）理解并尝试证明在m函数满足四边形不等式后，它的最优决策满足单调性（即决策单调性） 理解在决策单调性被满足后，复杂度的优化原理 大致证明可以使用上述优化策略的过程大致就是这样，我们需要遵循上述过程来进行严谨的验证 本讲解最后还给出了一道例题，同时给出了决策单调性的较为完整的证明过程，可以用于借鉴 还有一个细节，就是如何证明不同的二叉搜索树的个数？这个与Catalan数有关，可能近期会原创一篇关于Catalan数的总结，作为休闲娱乐之用（因为它比较简单嘛。。。）]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>四边形不等式</tag>
        <tag>单调性优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[炫酷反演魔术]]></title>
    <url>%2F2017%2F08%2F01%2F%E7%82%AB%E9%85%B7%E5%8F%8D%E6%BC%94%E9%AD%94%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[引言最近补了一下以前反演的坑，写个博客记录一下大致内容以及细节问题，便于日后复习 讲解首先赠送vfk反演课件 在vfk的课件里，主要讲了如下几种反演： 二项式反演 莫比乌斯反演 子集反演 离散傅里叶变换 下面会分别进行介绍及推导，但在向下进行时，首先补充一些概念，使下面的过程更为容易理解 反演与线性代数这是什么呢？考察一个十分一般的反演： \begin{equation} f(n) = \sum_{k = 1}^{n} a_{n, k} g(k) \end{equation}我们用现有的知识，能采用的只有高斯消元一种方法，而vfk仍然对其进行了“推导”： 对于每一个 $m$ 我们求出当 $f(m) = 1$ 而其它的 $f$ 都是 $0$ 的情况下的 $g$ 就行了，用 $\mu(n, m)$ 来表示这个解 然后，他使用$\mu(n, m)$这个东西，得到了： \begin{equation} g(n) = \sum_{k = 1}^{n} \mu(n, k) f(k) \end{equation}很显然这样做是没什么实际意义的是吧，但是这也告诉我们，我们学习的反演，是对一些特殊情况，总结规律，进而得到的一些优美结论，而求出来的那些系数，就是这里面所提到的$\mu(n, m)$ 至于为什么要用$\mu$来表示解，大家可以把这看作和莫比乌斯函数的类比，暗示莫比乌斯函数的实质 而如果我们把系数看作矩阵，那么我们求反演的过程就相当于是在求逆矩阵，这也是为什么在下面每个反演的推导中，vfk都是先“说了一句废话”，然后就推导出了结论，他说的那句废话，就相当于是把原矩阵乘上了一个单位矩阵，然后，用我们已经知道的系数矩阵与其逆代换这个单位矩阵，然后代换掉系数矩阵与原矩阵的乘积，就是反演后的样子，下面用推导步骤详细说明这里的含义（用$F$代表函数$f$的矩阵，大小为$1×n$，用$G$代表函数$g$的矩阵，大小为$1×n$，用$A$代表系数矩阵，大小为$n×n$，$I$表示单位矩阵，大小为$n×n$）： \begin{array}{rcl} \mbox{首先有}&F & =& GA\\ \mbox{又知}& G & =& G × I\\ &G × I &=& G × A × A^{-1}\\ & &=& F × A^{-1}\\ \mbox{故}& G &=& F × A^{-1} \end{array}这形象地反映了vfk的推导过程，理解起来会好一些，之后也会把每个式子对应到上面的矩阵运算中 下面分别对两个常见反演进行讲解： 二项式反演形式 \begin{eqnarray} f(n) =\sum_{k = 0}^{n} \binom{n}{k} g(k)\\ g(n) = \sum_{k = 0}^{n} (-1)^{n - k} \binom{n}{k} f(k) \end{eqnarray}推导首先说一句废话($G = G * I$): \begin{equation} g(n) = \sum_{m = 0}^{n} [n - m = 0] \binom{n}{m} g(m) \end{equation}回忆我们刚才发现的性质($I = A * A^{-1}$): \begin{equation} \sum_{k = 0}^{n}{(-1)^k\binom{n}{k}} = [n = 0] \end{equation}代进去($G = G * I = G × A × A^{-1}$): \begin{equation} g(n) = \sum_{m = 0}^{n} \sum_{k = 0}^{n - m} (-1)^k \binom{n - m}{k} \binom{n}{m} g(m) \end{equation}注意 $\binom{n - m}{k} \binom{n}{m}$ 意思是在 $n$ 个里面两个子集一个大小为 $m$ 另一个大小为 $k$，所以和 $\binom{n}{k} \binom{n - k}{m}$ 其实是等价的 \begin{eqnarray} g(n) =\sum_{m = 0}^{n} \sum_{k = 0}^{n - m} (-1)^k \binom{n - m}{k} \binom{n}{m} g(m) \\ = \sum_{m = 0}^{n} \sum_{k = 0}^{n - m} (-1)^k \binom{n}{k} \binom{n - k}{m} g(m) \end{eqnarray}交换两个求和符号: \begin{equation} g(n) = \sum_{k = 0}^{n} (-1)^k \binom{n}{k} \sum_{m = 0}^{n - k} \binom{n - k}{m} g(m) \end{equation}注意最右边的那个小朋友！其实就是 $f$！($F = GA$)变成: \begin{equation} g(n) = \sum_{k = 0}^{n} (-1)^k \binom{n}{k} f(n - k) \end{equation}把下标换得漂亮点: \begin{equation} g(n) = \sum_{k = 0}^{n} (-1)^{n - k} \binom{n}{k} f(k) \end{equation}所以我们就得到了酱紫的东西:（妈呀其实就是容斥） \begin{eqnarray} f(n) = \sum_{k = 0}^{n} \binom{n}{k} g(k)\\ g(n) = \sum_{k = 0}^{n} (-1)^{n - k} \binom{n}{k} f(k) \end{eqnarray}莫比乌斯反演形式A \begin{eqnarray} f(n) = \sum_{d \mid n} g(d)\\ g(n) = \sum_{d \mid n} \mu(\frac{n}{d}) f(d) \end{eqnarray}形式B \begin{eqnarray} f(n) = \sum_{n \mid d} g(d)\\ g(n) = \sum_{n \mid d} \mu(\frac{d}{n}) f(d) \end{eqnarray}推导可以知道 $ \mu(\prod_p p^\alpha) = \prod_p [\alpha = 1](-1) $ （为啥是这个式子以后再侃 = =）($I = A * A^{-1}$): 接下来说一句废话($G = G * I$): \begin{equation} g(n) = \sum_{m \mid n} [\frac{n}{m} = 1]g(m) \end{equation}代进去！($G = G * I = G × A × A^{-1}$) \begin{equation} g(n) = \sum_{m \mid n} \sum_{d \mid \frac{n}{m}} \mu(d) g(m) \end{equation}注意 $d \mid \frac{n}{m}$ 其实就是 $md \mid n$，所以跟 $m \mid \frac{n}{d}$ 等价。似曾相识，对不？交换两个求和符号： \begin{equation} g(n) = \sum_{d \mid n} \mu(d) \sum_{m \mid \frac{n}{d}} g(m) \end{equation}$f$ 君好久不见($F = GA$) \begin{equation} g(n) = \sum_{d \mid n} \mu(d) f(\frac{n}{d}) \end{equation}把下标换得漂亮点： \begin{equation} g(n) = \sum_{d \mid n} \mu(\frac{n}{d}) f(d) \end{equation}所以我们就得到了酱紫的东西：（妈呀其实这也是容斥） \begin{eqnarray} f(n) = \sum_{d \mid n} g(d)\\ g(n) = \sum_{d \mid n} \mu(\frac{n}{d}) f(d) \end{eqnarray}基本上举了这两个例子，用于说明vfk的操作实际上是矩阵运算，免得很多人不知道vfk在干嘛。。。 子集反演形式A \begin{eqnarray} f(S) = \sum_{T \subseteq S} g(T)\\ g(S) = \sum_{T \subseteq S} (-1)^{\lvert S \rvert - \lvert T \rvert} f(T) \end{eqnarray}形式B \begin{eqnarray} f(S) = \sum_{S \subseteq T} g(T)\\ g(S) = \sum_{S \subseteq T} (-1)^{\lvert T \rvert - \lvert S \rvert} f(T) \end{eqnarray}形式C（多重子集反演）定义 $\mu(S)$，$S$ 包含重复元素则为 $0$，否则为 $(-1)^{\lvert S \rvert}$ \begin{eqnarray} f(S) = \sum_{T \subseteq S} g(T)\\ g(S) = \sum_{T \subseteq S} \mu(S - T) f(T) \end{eqnarray}推导 \begin{equation} \sum_{r \subseteq p} (-1)^{\lvert r \rvert} = [p = 0] \end{equation}这里的 $\lvert r \rvert$ 表示集合的大小然后像以前一样做： \begin{eqnarray} g(p) = \sum_{q \subseteq p} [p - q = 0] g(q) \\ = \sum_{q \subseteq p} \sum_{r \subseteq p - q} (-1)^{\lvert r \rvert} g(q) \\ = \sum_{r \subseteq p} (-1)^{\lvert r \rvert} \sum_{q \subseteq p - r} g(q) \\ = \sum_{r \subseteq p} (-1)^{\lvert r \rvert} f(p - r) \\ = \sum_{r \subseteq p} (-1)^{\lvert p \rvert - \lvert r \rvert} f(r) \end{eqnarray}所以我们就得到了酱紫的东西：（妈呀就是裸容斥） \begin{eqnarray} f(S) = \sum_{T \subseteq S} g(T)\\ g(S) = \sum_{T \subseteq S} (-1)^{\lvert S \rvert - \lvert T \rvert} f(T) \end{eqnarray}子集反演很重要，因为通过它，你可以在本质的层面上理解莫比乌斯反演的真正内涵，所有的整数都可以看做集合，而多重子集反演则可以很好地解释莫比乌斯函数的必要性，而子集反演和二项式反演也有密不可分的联系（其实这三个反演的本质完全相同，都是同一种反演） 离散傅里叶变换形式 \begin{eqnarray} f_m = \sum_{k = 0}^{n - 1} \epsilon^{mk} g_k\\ g_m = \frac{1}{n} \sum_{k = 0}^{n - 1} \epsilon^{-mk} f_k \end{eqnarray}推导说实话并没有看懂vfk的推导。。。 注意到： \begin{eqnarray} [(p + q) \bmod n = r] \\ = [(p + q - r) \bmod n = 0] \\ = \frac{1}{n}\sum_{k = 0}^{n - 1} \epsilon^{(p + q - r)k} \\ = \frac{1}{n}\sum_{k = 0}^{n - 1} \epsilon^{-rk} \epsilon^{pk} \epsilon^{qk} \end{eqnarray}这三部分几乎是独立的！ \begin{eqnarray} c_r = \sum_{p, q} [(p + q) \bmod n = r] a_p b_q \\ = \sum_{p, q} \frac{1}{n} \sum_{k = 0}^{n - 1} \epsilon^{-rk} \epsilon^{pk} \epsilon^{qk} a_p b_q \\ = \frac{1}{n} \sum_{k = 0}^{n - 1} \epsilon^{-rk} \sum_{p, q} \epsilon^{pk} a_p \epsilon^{qk} b_q \\ = \frac{1}{n} \sum_{k = 0}^{n - 1} \epsilon^{-rk} \sum_{p} \epsilon^{pk} a_p \sum_{q} \epsilon^{qk} b_q \\ \end{eqnarray}抓到你了！反演君！所以我们就得到了酱紫的东西： \begin{eqnarray} f_m = \sum_{k = 0}^{n - 1} \epsilon^{mk} g_k\\ g_m = \frac{1}{n} \sum_{k = 0}^{n - 1} \epsilon^{-mk} f_k \end{eqnarray}利用分治和单位根的小性质，这两个都是可以快速求的 例题UOJ Round #5 C令 $p = 998244353$（$7 \times 17 \times 2^{23} + 1$，一个质数）。给你整数 $n, c, d$。现在有整数 $x_1, \dots, x_n$ 和 $b_1, \dots, b_n$ 满足 $0 \leq x_1, \dots, x_n, b_1, \dots, b_n &lt; p$，且对于 $1 \leq i \leq n$ 满足： \begin{equation} \sum_{j = 1}^{n} \gcd(i, j)^c \cdot lcm(i, j)^d \cdot x_j \equiv b_i \pmod{p} \end{equation}有 $q$ 个询问，每次给出 $b_1, \dots, b_n$，请你解出 $x_1, \dots, x_n$ 的值。$n \leq 10^5$, $nq \leq 3 \times 10^5$ 经典问题有两个长度为 $2^n$ 的数列 $a_0, \dots, a_{2^n-1}$，$b_0, \dots, b_{2^n-1}$。求数列 $c$，其中 \begin{equation} c_r = \sum_{p, q} [p \mbox{ or } q = r] a_p b_q \end{equation}$n \leq 20$ 经典问题有两个长度为 $n$ 的数列 $a_0, \dots, a_{n-1}$，$b_0, \dots, b_{n-1}$。求数列 $c$，其中 \begin{equation} c_r = \sum_{p, q} [(p + q) \bmod n = r] a_p b_q \end{equation}$n$ 是 $2$ 的整数次幂，$n \leq 2^{20}$。 经典问题有两个长度为 $2^n$ 的数列 $a_0, \dots, a_{2^n-1}$，$b_0, \dots, b_{2^n-1}$。求数列 $c$，其中 \begin{equation} c_r = \sum_{p, q} [p \mbox{ and } q = r] a_p b_q \end{equation}$n \leq 20$ 经典问题有两个长度为 $2^n$ 的数列：$a_0, \dots, a_{2^n-1}$ 和 $b_0, \dots, b_{2^n-1}$。求数列 $c$，其中 \begin{equation} c_r = \sum_{p \subseteq r} a_p b_{r - p} \end{equation}要求 $O(n^2 2^n)$ 优秀代码莫比乌斯反演12345for (int i = 1; i = n; i++) g[i] = f[i];for (int i = 1; i = n; i++) for (int j = i + i; j = n; j += i) g[j] -= g[i]; 子集反演1234for (int i = 0; i &lt; n; i++) for (int s = 0; s &lt; (1 &lt;&lt; n); s++) if (s &gt;&gt; i &amp; 1) f[s] += f[s ^ 1 &lt;&lt; i]; 无脑反着写：1234for (int i = 0; i &lt; n; i++) for (int s = 0; s &lt; (1 &lt;&lt; n); s++) if (s &gt;&gt; i &amp; 1) f[s] -= f[s ^ 1 &lt;&lt; i]; 感觉东西不少，提炼的也差不多了，那么就先这样子吧]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>线性代数</tag>
        <tag>反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列&单调栈总结]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言最近刷了一波JCY大神的课件，打算认真练习一发单调队列/单调栈，于是有了这篇总结，同时作为之后学习单调优化DP的基础 单调队列/单调栈概念介绍由于个人认为这两者基本没什么区别，所以放在一起进行讲解 单调队列就是一个队列，里面的元素具有单调性，所以就可以在里面进行各种操作，比如在里面进行二分啊什么的，但是如果只能二分那其实也没有什么学习的必要性，更加重点的作用就是它能够同时维护多个区间的信息，具体原因下文会有所讲述而单调栈很显然就是一个栈，它里面的元素也是具有单调性的，但是每次只能从一个方向进出 首先说一下个人的理解，单调队列和单调栈其实没有什么本质区别，首先单调栈，看上去它是一个内部元素有序化的这么一个数据结构，但如果深入挖掘栈内各个元素的本质，就会发现，实际上栈内每个元素都代表着一个区间，这个区间中的极值就是这个元素的值（极值可以是最大值或最小值，这个看你如何进行维护） 为什么这么说呢？我们可以看一下这个图：这时我们已经处理了两个大括号之间的所有数据，然后，我们把单调栈里的每一项都用一种颜色进行标记，同时标出它们在原序列上对应的区间，如下图：我们会发现，每个元素在它自己的区间内，都是最大值，这就是单调栈的实质，通过许多单个元素同时维护“许多区间” 为什么这么说呢，大家可以把当前单调栈中维护的区间看作这样子： 首先，我们不是标记出了每个颜色的范围吗，把这个每个颜色中的元素的在原序列中的下标视为左端点，现在更新到的原序列中的位置视为右端点，那么这个栈里面就总共维护着已经更新的原序列中的元素的个数这么多个区间，我们每次都会使右端点向右移动一个单位，这样总共就会维护到 $\frac{n ∗ (n + 1)}{2}$ 个区间，对应原序列的全部子区间，这种理解，我个人称作 区间化理解 所以，单调栈往往可以解决具有如下特征的问题： 涉及最值 询问全部区间的情况（个数为$O(n^2)$)显然，单调栈的特性在于第二点，它能同时维护许多区间，所以就可以把原本暴力$O(n^2)$才能解决问题的算法优化到了$O(n)$，其实这是一个极为优秀的优化 我们可以在每次加入元素的同时，直接把答案进行批量累加（即再维护一个当前栈内所有区间的贡献和，每次把答案加上这个总贡献），这样就能够非常高效的维护与所有区间有关的信息，我把这种方法称为整体化处理，这种方法有时虽然可以被替代，但更多时候它能简化出栈时更新答案的复杂性，因为整体化处理是随时更新答案的 或者是在每次弹出元素的时候，对答案进行更新，这样可以保证相对于单个区间来说的答案最优性（相当于极大化区间贡献） 而单调队列就相当于，我们移动了元素的起始位置，像是一个滑动的窗口，在左端点向右移动时，我们永远地舍弃掉了那些掉出窗口的元素，这样做的目的会在下文的讲解中体现 下面举几个例题，来简单介绍一下它的具体用法与应用范围 例题讲解51nod 1102 面积最大的矩形基准时间限制：1 秒空间限制：131072 KB分值：20难度：3级算法题 有一个正整数的数组，化为直方图，求此直方图包含的最大矩形面积。例如 $2,1,5,6,2,3$，对应的直方图如下： 面积最大的矩形为$5,6$组成的宽度为$2$的矩形，面积为$10$。 Input$第1行：1个数N，表示数组的长度(0 &lt;= N &lt;= 50000)$$第2 - N + 1行：数组元素A[i]。(1 &lt;= A[i] &lt;= 10^9)$ Output输出最大的矩形面积 Input示例12345676215623 Output示例110 题目分析求最大矩形面积，这是单调栈的一个常见应用，考虑到当高度下降的时候，被卡住的那些矩形就永远只能被卡在那里了，所以这时它们就应该出栈，于是我们就知道应该维护一个单调上升的单调栈，细节可见代码 维护方法：我们对于每个进栈的元素定义结构体，里面有两个成员变量，分别代表它入栈的位置和它自己的高度（用于比较的键值），出栈时用当前的位置与它入栈的位置的距离减一作为矩形一边，高度作为另一边计算面积并更新答案 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 50005#define LL long long intusing namespace std;LL line[maxn];int n;struct rec&#123; LL val, idx; rec(LL val, LL idx) : val(val), idx(idx)&#123;&#125; rec()&#123;&#125;&#125;;stack&lt;rec&gt; save;LL ans = 0;void work()&#123; for (int i = 1; i &lt;= n; i++)&#123; rec op; int l = i; while(!save.empty() &amp;&amp; (save.top()).val &gt; line[i])&#123; op = save.top(); ans = max(ans, (i - op.idx) * op.val); l = op.idx; save.pop(); &#125; save.push(rec(line[i], l)); &#125; while (!save.empty())&#123; rec op = save.top(); ans = max(ans, (n - op.idx + 1) * op.val); save.pop(); &#125; printf("%lld", ans);&#125;int main()&#123; /*freopen("rec.in", "r", stdin); freopen("rec.out", "w", stdout);*/ scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;line[i]); work(); return 0;&#125; 51nod 1158 全是1的最大子矩阵基准时间限制：1 秒空间限制：131072 KB分值：80难度：5级算法题 给出1个$M*N$的矩阵$M_1$，里面的元素只有0或1，找出$M_1$的一个子矩阵$M_2$，$M_2$中的元素只有1，并且$M_2$的面积是最大的。输出$M_2$的面积。 Input$第1行:2个数m,n中间用空格分隔(2 &lt;= m,n &lt;= 500)$$第2 - N + 1行：每行m个数，中间用空格分隔，均为0或1。$ Output$输出最大全是1的子矩阵的面积。$ Input示例12343 31 1 01 1 10 1 1 Output示例14 题目分析上一题的二维加强版，直接对每一行套用上一题方法即可 维护方法：同上一题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 505using namespace std;int n, m;int geo[maxn][maxn];int low[maxn][maxn];int up[maxn][maxn];int line[maxn];void init()&#123; for (int j = 0; j &lt; m; j++)&#123; low[n - 1][j] = (geo[n - 1][j]) ? 1 : 0; for (int i = n - 2; i &gt;= 0; i--)&#123; low[i][j] = (geo[i][j]) ? low[i + 1][j] + 1 : 0; &#125; &#125;&#125;struct mat&#123; int val, idx; mat(int val, int idx) : val(val), idx(idx)&#123;&#125; mat()&#123;&#125;&#125;;int cal(int row)&#123; int ans = 0; stack&lt;mat&gt; save; for (int i = 0; i &lt; m; i++) line[i] = low[row][i]; save.push(mat(line[0], 0)); for (int i = 1; i &lt; m; i++)&#123; mat op = save.top(); int l = i; while (!save.empty() &amp;&amp; op.val &gt;= line[i])&#123; l = op.idx; ans = max(ans, (i - l) * op.val); save.pop(); if (save.empty()) break; op = save.top(); &#125; save.push(mat(line[i], l)); ans = max(ans, (i - l + 1) * line[i]); &#125; /*--------------------*/ while (!save.empty())&#123; mat op = save.top(); ans = max(ans, (m - op.idx) * op.val); save.pop(); if (save.empty()) break; &#125; /*--------------------*/ return ans;&#125;void work()&#123; int ans = 0; for (int i = 0; i &lt; n; i++) ans = max(ans, cal(i)); printf("%d", ans);&#125;int main()&#123; /*freopen("mat.in", "r", stdin); freopen("mat.out", "w" ,stdout);*/ scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;geo[i][j]); init(); work(); return 0;&#125; 51nod 1215 数组的宽度题目来源： Javaman基准时间限制：1 秒空间限制：131072 KB分值： 80难度：5级算法题 N个整数组成的数组，定义子数组$a[i]..a[j]$的宽度为：$max(a[i]..a[j]) - min(a[i]..a[j])$，求所有子数组的宽度和。 Input$第1行：1个数N，表示数组的长度。(1 &lt;= N &lt;= 50000)$$第2 - N + 1行：每行1个数，表示数组中的元素(1 &lt;= A[i] &lt;= 50000)$ Output输出所有子数组的宽度和。 Input示例123456512345 Output示例120 题目分析发现最大值与最小值可以分开维护，这样就简单了许多，我们可以通过单调栈快速求出所有区间的极值之和，具体方法需要我上面的对于单调栈的区间化理解，细节见代码 维护方法，由于对称性，仅讲解最大值的求法：对每个入栈的元素定义结构体，内含两个成员变量，其中一个代表在区间化理解的意义下，这个元素所代表的区间的左端点，另一个变量代表它本身的值（键值），出栈时，由于它一定小于把它挤出去的那个元素，于是需要把它自己的左端点传给那个新来的元素，然后自己出栈，对于答案，我们采用整体化处理，用一个全局变量维护当前栈内元素所代表的所有区间的最大值的和，每次把一个元素入栈以后，我们需要把出栈的那些元素对这个全局变量的贡献减掉，然后加上刚入栈的那个元素的贡献，然后直接加入最终答案即可 p.s. 其实也不一定用到整体化处理，我们考察区间化理解的意义后，可以直接在每个元素出栈时再用它们的贡献更新答案，所以这不算是整体化处理的典型用法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 50005#define LL long long intusing namespace std;LL line[maxn];int n;struct inter&#123; int val, l, r; inter(int val, int l, int r) : val(val), l(l), r(r)&#123;&#125; inter()&#123;&#125;&#125;;LL get_max()&#123; LL ans = 0, now = 0; stack&lt;inter&gt; save; save.push(inter(line[1], 1, 1)); ans = now = line[1]; for (int i = 2; i &lt;= n; i++)&#123; int l = i; inter op = save.top(); while (!save.empty() &amp;&amp; op.val &lt;= line[i])&#123; now -= (LL)(op.r - op.l + 1) * op.val; l = op.l; save.pop(); if (save.empty()) break; op = save.top(); &#125; save.push(inter(line[i], l, i)); now += (i - l + 1) * line[i]; ans += now; &#125; return ans;&#125;LL get_min()&#123; LL ans = 0, now = 0; stack&lt;inter&gt; save; save.push(inter(line[1], 1, 1)); ans = now = line[1]; for (int i = 2; i &lt;= n; i++)&#123; int l = i; inter op = save.top(); while (!save.empty() &amp;&amp; op.val &gt;= line[i])&#123; now -= (LL)(op.r - op.l + 1) * op.val; l = op.l; save.pop(); if (save.empty()) break; op = save.top(); &#125; save.push(inter(line[i], l, i)); now += (i - l + 1) * line[i]; ans += now; &#125; return ans;&#125;int main()&#123; /*freopen("width.in", "r", stdin); freopen("width.out", "w", stdout);*/ scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;line[i]); printf("%lld", get_max() - get_min()); return 0;&#125; 51nod 1272 最大距离题目来源： Codility基准时间限制：1 秒空间限制：131072 KB分值： 20难度：3级算法题 给出一个长度为$N$的整数数组$A$，对于每一个数组元素，如果他后面存在大于等于该元素的数，则这两个数可以组成一对。每个元素和自己也可以组成一对。例如：${5, 3, 6, 3, 4, 2}$，可以组成$11$对，如下（数字为下标）：$(0,0), (0, 2), (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (3, 3), (3, 4), (4, 4), (5, 5)$。其中$(1, 4)$是距离最大的一对，距离为3。 Input$第1行：1个数N，表示数组的长度(2 &lt;= N &lt;= 50000)。$$第2 - N + 1行：每行1个数，对应数组元素A_i(1 &lt;= A_i &lt;= 10^9)。$ Output输出最大距离。 Input示例12345676536342 Output示例13 题目分析这道题算是比较经典的单调栈内二分的题目，这就是单调栈的一种比较简单的操作，其实这题我是搞了一段时间的，主要是想有没有$O(n)$的算法，然而最后还是没能想出来。。。 维护方法：本题采用了一种不同的维护方式，即不保留刚入栈元素的方式，每次对于刚入栈的元素，如果它小于栈顶元素，我们把它直接入栈，否则，我们不将它入栈，而是在原栈中二分寻找答案，并更新最终答案，容易知道这样做是正确的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 50005using namespace std;struct num&#123; int val, idx; num(int val, int idx) : val(val), idx(idx)&#123;&#125; num()&#123;&#125; bool operator &lt; (const num b) const&#123; return val &gt; b.val; &#125;&#125;save[maxn];int head;int line[maxn];int n;inline void push(num x)&#123; save[head++] = x;&#125;inline void pop(num x)&#123; head--;&#125;inline num top()&#123; return save[head - 1];&#125;void work()&#123; int ans = 1; push(num(line[1], 1)); for (int i = 2; i &lt;= n; i++)&#123; num op = top(); if (line[i] &lt; op.val) push(num(line[i], i)); else &#123; num* op2 = lower_bound(save, save + head, num(line[i], i)); ans = max(ans, i - op2 -&gt; idx); &#125; &#125; printf("%d", ans);&#125;int main()&#123; /*freopen("maxlen.in", "r", stdin); freopen("maxlen.out", "w", stdout);*/ scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); work(); return 0;&#125; 51nod 1962 区间计数基准时间限制：1.5 秒空间限制：262144 KB分值： 80难度：5级算法题 两个数列 ${A_n} ， {B_n}$ ，请求出$Ans$, $Ans$定义如下： Ans=\sum_{i = 1}^{n}\sum_{j = i}^{n}[max\{A_i,A_{i+1},...,A_j\}=max\{B_i,B_{i+1},...,B_j\}]注：[ ]内表达式为真，则为1，否则为0. $1≤N≤3.5×10^5$$1≤A_i,B_i≤N $ 样例解释：7个区间分别为：$（1,4），（1,5），（2,4），（2,5），（3,3），（3,5），（4,5）$ Input$第一行一个整数N$$第二行N个整数A_i$$第三行N个整数B_i$ Output一行，一个整数$Ans$ Input示例12351 4 2 3 43 2 2 4 1 Output示例17 题目分析其实我是先做的这道题，然后再看的其他题。。。这题就是，我们同样使用区间化理解，先分别为两个序列维护两个栈，然后对栈内每个数记录一个区间，每次我们就是要求两个栈内的相同的数所对应的区间的交，我们每次插入元素，就把所有的交的和累加进答案，这就是我说的整体化处理 维护方法：对每个元素记录一个区间，和它本身的值，对值相同的元素我们求交，并把交的长度加入整体维护的全局变量中，出栈入栈分别删除或增加，每次当前位置更新完毕后，我们直接把答案加入最终答案即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 400005#define LL long long intusing namespace std;struct inter&#123; int l, r; inter(int l, int r) : l(l), r(r)&#123;&#125; inter()&#123;&#125;&#125;;int get_insect(inter a, inter b)&#123; if (a.l &gt; b.l) swap(a, b); if (a.r &lt; b.l) return 0; return min(a.r, b.r) - b.l + 1;&#125;stack&lt;int&gt; savea, saveb;int linea[maxn], lineb[maxn];inter reca[maxn], recb[maxn];LL ans, now;int n;void work()&#123; for (int i = 1; i &lt;= n; i++) reca[i] = recb[i] = inter(0, 0); savea.push(linea[1]); reca[linea[1]] = inter(1, 1); saveb.push(lineb[1]); recb[lineb[1]] = inter(1, 1); now = ans = get_insect(recb[lineb[1]], reca[lineb[1]]); for (int i = 2; i &lt;= n; i++)&#123; int op; inter ka = inter(i, i); while (!savea.empty() &amp;&amp; (op = savea.top()) &lt;= linea[i])&#123; now -= get_insect(reca[op], recb[op]); ka.l = reca[op].l; reca[op] = inter(0, 0); savea.pop(); &#125; savea.push(linea[i]); inter kb = inter(i, i); while (!saveb.empty() &amp;&amp; (op = saveb.top()) &lt;= lineb[i])&#123; now -= get_insect(reca[op], recb[op]); kb.l = recb[op].l; recb[op] = inter(0, 0); saveb.pop(); &#125; saveb.push(lineb[i]); reca[linea[i]] = ka; recb[lineb[i]] = kb; if (linea[i] == lineb[i])&#123; now += get_insect(ka, kb); &#125; else&#123; now += get_insect(reca[linea[i]], recb[linea[i]]); now += get_insect(reca[lineb[i]], recb[lineb[i]]); &#125; ans += now; &#125; printf("%lld", ans);&#125;int main()&#123; /*freopen("inter.in", "r", stdin); freopen("inter.out" ,"w", stdout);*/ scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;linea[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;lineb[i]); work(); return 0;&#125; 51nod 1153 选择子序列题目来源： Codility基准时间限制：1 秒空间限制：131072 KB分值： 40难度：4级算法题 长度为$N的整数数组A$，所有的数均不相同，假设下标从$0$开始。找到一个最长的数组B，B数组的长度为K，数值范围是$0 - N - 1$，记录的是A数组的下标。 满足$A[B[0]] &gt; A[B[1]] &gt; A[B[2]] &gt;…A[B[K]]$，并且对任意连续的两项$B[i]及B[i + 1]$，满足$min(B[i]，B[i + 1]) &lt; j &lt; max(B[i]，B[i + 1])$ 均有$A[j] &lt; A[B[i + 1]] $，求最大的K。 例如：$9, 10, 2, -1, 3, -5, 0, -3, 1, 12, 5, 8, -2, 6, 4$。可以选出：$12, 10, 3, 1, 0, -3。$对应的下标为$：9, 1, 4, 8, 6, 7$（就是B数组），输出$6$。 Input$第1行：一个数N，表示A数组的长度。（1 &lt;= N &lt;= 50000)$$第2 - N + 1行：每行1个数对应A数组的元素Ai（0 &lt; Ai &lt; 10^9)$ Output$输出B数组最长的长度K。$ Input示例12345678910111213141516159102-13-50-311258-264 Output示例16 题目分析我们很容易发现本题的贪心策略，每次选当前区间中最大的数，然后在分出的左右两个小区间中重复上述过程，找到最长的那个序列就可以了，正常的想法就是维护线段树，然后$O(n\log n)$解决，但是我觉得，既然是在做单调栈，为什么不在$O(n)$内解决呢？于是我就想到了单调栈的做法 维护方法：对每个元素维护一个结构体，内含两个成员变量，分别为当前求出的DP值和元素本身的值，我们每次在pop出一个元素后，我们用这个元素的最长长度加一，更新新的栈顶元素的最长长度，同时对于每次进栈的那个元素，用所有被它挤出去的那些元素的最长长度加一来更新它的最长长度，最后在每次操作时都用元素的最长长度更新答案，并且把所有元素都出栈检查即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define maxn 50005using namespace std;struct num&#123; int val, ans; num(int val, int ans) : val(val), ans(ans)&#123;&#125; num()&#123;&#125;&#125;;int line[maxn];int n;void work()&#123; int tot = 0; stack&lt;num&gt; save; save.push(num(line[1], 1)); tot = 1; for (int i = 2; i &lt;= n; i++)&#123; num op = save.top(); int ans = 0; while (!save.empty() &amp;&amp; op.val &lt;= line[i])&#123; ans = max(ans, op.ans); save.pop(); if (!save.empty())&#123; num op2 = save.top(); save.pop(); op2.ans = max(op2.ans, op.ans + 1); save.push(op2); &#125; else break; op = save.top(); &#125; save.push(num(line[i], ans + 1)); tot = max(tot, ans + 1); &#125; while (!save.empty())&#123; num op = save.top(); tot = max(tot, op.ans); save.pop(); if (!save.empty())&#123; num op2 = save.top(); save.pop(); op2.ans = max(op2.ans, op.ans + 1); save.push(op2); &#125; else break; &#125; printf("%d", tot);&#125;int main()&#123; /*freopen("sub.in", "r", stdin); freopen("sub.out", "w", stdout);*/ scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;line[i]); work(); return 0;&#125; 51nod 1275 连续子段的差异题目来源： Codility基准时间限制：1 秒空间限制：131072 KB分值： 80难度：5级算法题 给出一个包括N个元素的整数数组A，包括A本身在内，共有 $\frac{n * (n + 1)}{2}$个非空子段。例如：1 3 2的子段为{1} {3} {2} {1 3} {3 2} {1 3 2}。在这些子段中，如果最大值同最小值的差异不超过K，则认为这是一个合格的子段。给出数组A和K，求有多少符合条件的子段。例如：3 5 7 6 3，K = 2，符合条件的子段包括：{3} {5} {7} {6} {3} {3 5} {5 7} {7 6} {5 7 6}，共9个。 Input$第1行：2个数N, K（1 &lt;= N &lt;= 50000, 0 &lt;= K &lt;= 10^9)$$第2 - N + 1行：每行1个数，对应数组的元素A_i(0 &lt;= A[i] &lt;= 10^9)$ Output输出符合条件的子段数量。 Input示例1234565 235762 Output示例19 题目分析这就是一个需要用到单调队列的题目了，同时根据本题的特性，本题还需要使用尺取法，我们先维护两个队列，一个维护最大值，另一个维护最小值，我们每次同时向两个队列中加入元素并更新，然后直到两个队列最大和最小的元素之差超过$K$，然后我们统计数量并向右移动队列的左端点（同时移动两个队列的），再重复上述尺取过程，这样就可以解决问题了，这种问题的解决，需要基于同时性处理，即同时入队一个元素，同时出队一个元素 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 100005using namespace std;deque&lt;int&gt; inc;deque&lt;int&gt; dec;int line[maxn];int n, k;int main()&#123; /*freopen("diff.in", "r", stdin); freopen("diff.out", "w", stdout);*/ scanf("%d%d", &amp;n, &amp;k); int cur = 0; int ans = 0; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;line[i]); for (int i = 0; i &lt; n; i++)&#123; while(cur &lt; n)&#123; while (!dec.empty() &amp;&amp; line[dec.back()] &lt;= line[cur]) dec.pop_back(); dec.push_back(cur); while (!inc.empty() &amp;&amp; line[inc.back()] &gt;= line[cur]) inc.pop_back(); inc.push_back(cur); if (line[dec.front()] - line[inc.front()] &lt;= k) cur++; else break; &#125; ans += (cur - i); if (inc.front() == i) inc.pop_front(); if (dec.front() == i) dec.pop_front(); &#125; printf("%d", ans); return 0;&#125; 总结模型 单调栈 上升栈 求最大矩形面积 求最小值的整体和 求包含末元素的最长上升子序列长度 下降栈 求最大值的整体和 求包含末元素的最长下降子序列长度 栈内二分 不保留维护，分情况更新 区间化理解 把元素区间化，用区间交解决问题 整体化处理 常用于多个栈的相关联信息维护 单调队列 二分答案 尺取法 滑动窗口式问题 感觉题还是做得少。。。没什么内容 所以大致就是这样，单调栈/单调队列其实还是很好理解的，我们熟悉了几种常见的操作以后，就能够感受到单调栈/单调队列这种数据结构的强大之处，也能对它们有更深刻的理解]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗分导论]]></title>
    <url>%2F2017%2F07%2F25%2F%E9%AA%97%E5%88%86%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[引言闲时看看，大有裨益 讲解]]></content>
      <tags>
        <tag>骗分导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 LNWC 讲解]]></title>
    <url>%2F2017%2F07%2F24%2F2016-LNWC-%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言这里存放一下2016 LNWC的讲课课件，用于以后的知识复习 大纲如下： Day1 树 ryz Day2 数据结构 eleven Day3 网络流 ryz Day4 数据结构 eleven Day5 1-字符串 &amp; 2-数论 ryz Day6 动态规划 eleven 其中，ryz为茹逸中，eleven为李诗懿 讲解Day1 Day2 Day3 Day4 Day5-1 Day5-2 Day6]]></content>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
        <tag>网络流</tag>
        <tag>字符串</tag>
        <tag>数论</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊算法详解]]></title>
    <url>%2F2017%2F07%2F24%2F%E7%89%B9%E6%AE%8A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言这里存放一下JCY大神的讲课课件，用于特殊算法的复习 讲解]]></content>
      <tags>
        <tag>莫队算法</tag>
        <tag>分块法</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构详解]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言这里存放一下JCY大神的讲课课件，用于数据结构的复习 讲解]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础算法与技巧]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[引言这里存放一下FZW大神的讲课课件，用于基础算法的复习 讲解]]></content>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础数论讲解]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言这里存放一下FZW大神的讲课课件，用于基础数论的复习 讲解]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6062. 「2017 山东一轮集训 Day2」Pair]]></title>
    <url>%2F2017%2F07%2F20%2F6062-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day2%E3%80%8DPair%2F</url>
    <content type="text"><![CDATA[引言题解： $Libre$ $Online$ $Judge$ # $6062$. 「2017 山东一轮集训 Day2」Pair LOJ 6062. 「2017 山东一轮集训 Day2」Pair内存限制：256 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述给出一个长度为 $n$ 的数列 ${ a_i }$ 和一个长度为 $ m$ 的数列 ${ b_i }$，求 ${ a_i }$ 有多少个长度为 $m$ 的连续子数列能与 ${ b_i }$ 匹配。 两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和不小于 $h$。 输入格式第一行三个数字 $n, m, h$。第二行有 $m$ 个数字 $b_1, b_2, \ldots , b_m$。第三行有 $n$ 个数字 $a_1, a_2, \ldots, a_n$。 输出格式输出一个数字，${ a_i }$ 有多少个长度为 $ m $ 的连续子数列能与 ${ b_i }$ 匹配。 样例样例输入 11235 2 105 31 8 5 5 7 样例输出 112 样例输入 21232 2 62 33 4 样例输出 211 样例输入 31234 2 105 59 3 8 9 样例输出 311 数据范围与提示对于 $10\%$ 的数据，$1 \leq m \leq n \leq 10$；对于 $40\%$ 的数据，$1 \leq m \leq n \leq 1000$；对于 $100\%$ 的数据，$1 \leq m \leq n \leq 150000 $；对于 $100\%$ 的数据，$1 \leq a_i, b_i, h \leq 10 ^ 9 $​​。 题目分析首先我们发现条件 $a + b &gt; h$，非常不好看，于是我们把它转化一下，变成 $a &gt; h - b$，这样就会好很多 然后，我们透彻地理解题意，可以知道，如果我们把当前与$b$相对应的$a$中的元素与$b$中的元素拿出来，排好序，那么当且仅当任何一个后缀的元素中属于$a$的元素个数大于等于$b$中的元素个数，那么$b$可以匹配 其实这还是很好理解的，然后，我们就可以使用线段树维护每个后缀中属于$a$和属于$b$的元素个数之差的最小值（包含正负），只要这个值大于等于零，那么可以匹配 细节见代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 300005using namespace std;int sum[maxn &lt;&lt; 1];int minnum[maxn &lt;&lt; 1];int qx, qy, qd;void insert(int l, int r, int o)&#123; if (l == r)&#123; sum[o] += qd; minnum[o] += qd; return ; &#125; int mid = ((r - l) &gt;&gt; 1) + l; if (qx &lt;= mid) insert(l, mid, o &lt;&lt; 1); else insert(mid + 1, r, o &lt;&lt; 1 | 1); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; minnum[o] = min(minnum[o &lt;&lt; 1], sum[o &lt;&lt; 1] + minnum[o &lt;&lt; 1 | 1]);&#125;int a[maxn];int b[maxn];int c[maxn];int n, m, h;int main()&#123; freopen("pair.in", "r", stdin); freopen("pair.out", "w", stdout); scanf("%d%d%d", &amp;n, &amp;m, &amp;h); for (int i = 1; i &lt;= m; i++) scanf("%d", &amp;b[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= m; i++) b[i] = h - b[i]; for (int i = 1; i &lt;= m; i++) c[i] = b[i]; for (int i = 1; i &lt;= n; i++) c[i + m] = a[i]; sort(c + 1, c + 1 + n + m); int k = unique(c + 1, c + 1 + n + m) - c; for (int i = 1; i &lt;= m; i++) b[i] = lower_bound(c + 1, c + 1 + k, b[i]) - c; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(c + 1, c + 1 + k, a[i]) - c; for (int i = 1; i &lt;= m; i++)&#123; qx = b[i], qd = 1; insert(1, k, 1); qx = a[i], qd = -1; insert(1, k, 1); &#125; int ans = 0; ans += (minnum[1] &gt;= 0); for (int i = m + 1; i &lt;= n; i++)&#123; qx = a[i - m] , qd = 1; insert(1, k, 1);///////correct: n -&gt; k qx = a[i], qd = -1; insert(1, k, 1);///////correct: n -&gt; k ans += (minnum[1] &gt;= 0); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>离散化</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#516. 「LibreOJ β Round #2」DP 一般看规律]]></title>
    <url>%2F2017%2F07%2F20%2F516-%E3%80%8CLibreOJ-%CE%B2-Round-2%E3%80%8DDP-%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $516$. 「LibreOJ β Round #2」DP 一般看规律 LOJ 516. 「LibreOJ β Round #2」DP 一般看规律内存限制：512 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述给定一个长度为 $n$ 的序列 $a$，一共有 $m$ 个操作。每次操作的内容为：给定 $x,y$，序列中所有 $x$ 会变成 $y$。 同时我们有一份代码：12345678int ans = 2147483647;for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[i] == a[j]) ans = std::min(ans, j - i); &#125;&#125;std::cout &lt;&lt; ans &lt;&lt; std::endl; 请在每次修改后输出代码运行的结果。 输入格式第一行两个数，表示 $n,m$。第二行 $n$ 个数，表示 $a_1,a_2,\cdots, a_n$​​。然后 $m$ 行每行两个数 $x$ 和 $y$，表示序列中所有 $x$ 会变成 $y$。 输出格式对于每次修改，输出答案。 样例样例输入1234567891011125 102 7 6 3 86 17 11 35 61 79 51 107 67 53 9 样例输出123456789102147483647111111111 数据范围与提示$1\le n , m \le 100000$ 每个出现的数字绝对值在 int 范围内。 题目分析在这篇文章的开头，我写了一句话：“有层次的思考不可或缺”，什么意思呢，就是在我们思考每一道题的时候，最好不要使用过于跳跃的思维，而是要从最初始的想法一步一步进行思考改进，最终得到正确算法 尽管有的时候，灵感来源于一瞬间，但是，这种比较稳定的思维方法还是要有所接受，多听一听各地的讲课，就会发现，一道难题，大佬们讲它的时候，往往都是先给出最简单的暴力方法，然后观察信息的冗余或浪费，或是进行各种联想，逐渐改进得到最后的正解 上面是对一种思维方法的阐述，与本题无关 下面说一说这道题，我们先透彻地理解一下题意，然后发现操作只有合并，而没有分裂，这启发我们向并查集/启发式合并的方向上思考，然后寻找下标差的最小值，我们可以联想到平衡树里面的前驱与后继，所以本题就是启发式合并的平衡树，同时每次插入时寻找前驱后继即可 最后为了方便处理，我们搞一个离散化，就可以了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;#define maxn 300005#define INF 2147483647using namespace std;struct qu&#123; int x, y; qu(int x, int y) : x(x), y(y)&#123;&#125; qu()&#123;&#125;&#125;q[maxn];set&lt;int&gt; save[maxn];int a[maxn];int c[maxn];int tag[maxn];int n, m;void read(int&amp; x)&#123; char ch = getchar(); x = 0; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();&#125;int main()&#123; freopen("dp.in", "r", stdin); freopen("dp.out", "w", stdout); read(n), read(m); int ct = 0; for (int i = 1; i &lt;= n; i++) read(a[i]), c[ct++] = a[i]; for (int i = 0; i &lt; m; i++)&#123; read(q[i].x), read(q[i].y); c[ct++] = q[i].x, c[ct++] = q[i].y; &#125; sort(c, c + ct); ct = unique(c, c + ct) - c; for (int i = 0; i &lt; ct; i++) tag[i] = i; int ans = INF; for (int i = 1; i &lt;= n; i++)&#123; a[i] = lower_bound(c, c + ct, a[i]) - c; save[a[i]].insert(i); auto it = save[a[i]].lower_bound(i); //auto it = lower_bound(save[a[i]].begin(), save[a[i]].end(), i); if (it != save[a[i]].begin()) ans = min(ans, i - *(--it)); it = save[a[i]].upper_bound(i); //it = upper_bound(save[a[i]].begin(), save[a[i]].end(), i); if (it != save[a[i]].end()) ans = min(ans, *it - i); &#125; for (int i = 0; i &lt; m; i++)&#123; q[i].x = lower_bound(c, c + ct, q[i].x) - c, q[i].y = lower_bound(c, c + ct, q[i].y) - c; int x = q[i].x, y = q[i].y; if (x == y)&#123; printf("%d\n", ans); continue; &#125; if (save[tag[x]].size() &gt; save[tag[y]].size()) swap(tag[x], tag[y]); for (auto it = save[tag[x]].begin(); it != save[tag[x]].end(); it++)&#123; save[tag[y]].insert(*it); auto it2 = save[tag[y]].lower_bound(*it); //auto it2 = lower_bound(save[tag[y]].begin(), save[tag[y]].end(), *it); if (it2 != save[tag[y]].begin()) ans = min(ans, *it - *(--it2)); it2 = save[tag[y]].upper_bound(*it); //it2 = upper_bound(save[tag[y]].begin(), save[tag[y]].end(), *it); if (it2 != save[tag[y]].end()) ans = min(ans, *it2 - *it); &#125; save[tag[x]].clear(); printf("%d\n", ans); &#125; return 0;&#125; 代码细节：不要使用$STL$中的$lower_bound/upper_bound$来操作set容器，否则算法会变得十分缓慢，很容易超时，所以，我们要使用set自带的$lower_bound/upper_bound$，具体都体现在上面的代码中 同时注意$tag$数组的必要性，因为它可以调节合并的顺序，否则会导致因启发式合并而带来的合并方向错误]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>启发式合并</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6136. 「2017 山东三轮集训 Day4」Left]]></title>
    <url>%2F2017%2F07%2F11%2F6136-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%89%E8%BD%AE%E9%9B%86%E8%AE%AD-Day4%E3%80%8DLeft%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6136$. 「2017 山东三轮集训 Day4」Left LOJ 6136. 「2017 山东三轮集训 Day4」Left内存限制：512 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述JOHNKRAM 最近在研究排序网络，但他发现他不会制作比较器，于是他用交换器来代替比较器。 一个交换器有两个输入端 $x, y$ 和两个输出端 $x’, y’$​​。如果交换器处于关闭状态，则 $x $ 收到的信号会从 $x’$ 发出，$y$ 收到的信号会从 $y’$ 发出。如果交换器处于开启状态，则 $x$ 收到的信号会从 $y’$​​ 发出。 JOHNKRAM 设计了这样一个递归定义的网络： $1$ 阶网络就是一个交换器。 $n(n &gt; 1)$ 阶网络的第一排是 $2 ^ {n - 1}$​​ 个交换器，接下来是两个 $n - 1$ 阶网络,最后一排也是 $2 ^ {n - 1}$​​ 个交换器。将第一排的输出端和第二排的输入端分别从左到右标号为 $0 \sim 2 ^ n - 1$，第一排的 $i$ 输出端连接到第二排的 i&gt;&gt;1 输入端，其中 &gt;&gt; 指 $n$ 位二进制数的循环右移。类似，将倒数第一排的输入端和倒数第二排的输出端分别从左到右标号为 $0\sim 2 ^ n - 1$，倒数第二排的 $i$ 输出端连接到倒数第一排的 i&lt;&lt;1 输入端，其中 &lt;&lt; 指 $n$ 位二进制数的循环左移。 一个 $3$ 阶的网络如下图所示： JOHNKRAM 通过开关交换器来调整网络。现在他对一个 $n$ 阶网络的 $2 ^ n$​​ 个输入端分别输入了一个数，第 $i(0 &lt; i &lt; 2 ^ n)$ 个输入端输入的是 $i$。然后他给出了一个长度为 $2 ^ n$​​ 的排列 $p$。他希望你给出一种网络的状态，使得第 $i(0 &lt; i &lt; 2 ^ n)$ 个输出端输出的是 $p_i$​​。 输入格式输入文件包含不超过 10 组测试数据。每个测试数据包含两行，第一行一个整数 $n$，表示是一个 $n$ 阶网络。第二行 $2 ^ n$​​ 个整数，表示排列 $p$。输入文件以一个 0 结尾。 输出格式对于每组数据，如果没有合法的解，则输出 $-1$，否则输出 $2n - 1$ 行 $2 ^ n$​​ 位二进制数，表示网络状态。如果一个交换器是开启的，则对应的位置上是 $1$，否则是 $0$。如果有多解，输出字典序最小的。 每个答案后打印一个空行。 样例样例输入1234523 2 1 033 7 4 0 2 6 1 50 样例输出12345678900111100110000011011111101 数据范围与提示对于 $20\%$ 的数据，保证 $n \leq 3$；对于 $100\%$ 的数据，保证 $1 \leq n \leq 13$。 分析其实这道题还是非常好的，正如前文的那句话，”宏观是微观的表现，微观是宏观的本质”，我们考虑对这道题递归和分解，使得我们每次只去分析一个小过程，这样就会简便很多，我们可以观察规律，发现 $n$阶网络最后每两组中的数($k∗ 2,k∗2+1$)一定不在$n-1$阶网络的同一侧 ，这样我们可以对每层$O(2^n)$进行处理，同时使用贪心法 ，如果当前的这个组没被标记（即是否已经决定开或关），就让它关着，然后用自身的状态以及网络特征，尽可能多的更新其他的组，可以证明这样做是完全正确的，把两个排列放在一起（置换），用2-SAT的思路进行连边，同时每两组内的数($k∗2, k∗2+1$)也连边，根据题目性质，只能形成偶环，无论怎么染色都不会矛盾（即无解），所以，我们对每一层都进行这样的处理，同时更新上下的序列，就可以在$O(T∗n∗2^n)$的复杂度内解决本题，而这是完全可以接受的 这道题思路非常巧妙，其实也是要对题目进行深度的理解，理解网络的工作原理与特征，然而代码还是非常恶心。。。细节巨多，最后还是先WA了一次才A的QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 13using namespace std;int up[1 &lt;&lt; maxn];int low[1 &lt;&lt; maxn];int ori[1 &lt;&lt; maxn];int line[1 &lt;&lt; maxn];int ans[(maxn &lt;&lt; 1) - 1][1 &lt;&lt; maxn];bool vis[(maxn &lt;&lt; 1) - 1][1 &lt;&lt; maxn];int temp[1 &lt;&lt; maxn];int judge[1 &lt;&lt; maxn];int n, x, con, con2; //con = n - 1 - (x - 1);void BFS(int j)&#123; int side = line[j ^ 1]; int _j = up[side]; if (vis[con][_j &gt;&gt; 1]) return; vis[con][_j &gt;&gt; 1] = 1; ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ ((line[j] &amp; (1 &lt;&lt; con)) &gt;&gt; con) ^ ((line[j ^ 1] &amp; (1 &lt;&lt; con)) &gt;&gt; con) ^ 1;//WA的原因，原先的写法如下： //ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ (line[j] &amp; 1) ^ (line[j ^ 1] &amp; 1) ^ 1; //中间测试时是这样写的： //ans[con][_j &gt;&gt; 1] = ans[con][up[line[j]] &gt;&gt; 1] ^ (line[j] &amp; (1 &lt;&lt; con)) ^ (line[j ^ 1] &amp; (1 &lt;&lt; con)) ^ 1; BFS(low[ori[_j ^ 1]]);&#125;/*void BFS2(int j)&#123; int side = ori[j ^ 1]; int _j = low[side]; if (vis[con2][_j &gt;&gt; 1]) return; vis[con2][_j &gt;&gt; 1] = 1; ans[con2][_j &gt;&gt; 1] = ans[con2][j &gt;&gt; 1] ^ 1; BFS2(j ^ 1);&#125;*//*int shift_left(int n, int x)&#123; int a = n &amp; ((1 &lt;&lt; x) - 1); int b = n - a; a = (a &lt;&lt; 1) | (a &gt;&gt; (x - 1)) &amp; ((1 &lt;&lt; x) - 1); return a | b;&#125;*/int shift_right(int n, int x)&#123; int a = n &amp; ((1 &lt;&lt; x) - 1); int b = n - a; a = (a &gt;&gt; 1) | (a &lt;&lt; (x - 1)) &amp; ((1 &lt;&lt; x) - 1); return a | b;&#125;void solve()&#123; if (x == 1)&#123; for (int i = 0; i &lt; (1 &lt;&lt; n); i += 2)&#123; ans[con][i &gt;&gt; 1] = 1 ^ (line[i] == ori[i]); &#125; return; &#125; for(int i = 0; i &lt; (1 &lt;&lt; n); i += 1 &lt;&lt; x)&#123; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) low[line[j]] = j; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) up[ori[j]] = j; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (!vis[con][j &gt;&gt; 1])&#123; vis[con][j &gt;&gt; 1] = 1; ans[con][j &gt;&gt; 1] = 0; BFS(low[ori[j]]), BFS(low[ori[j + 1]]); &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (ans[con][j &gt;&gt; 1])&#123; temp[shift_right(j, x)] = ori[j ^ 1]; judge[ori[j ^ 1]] = 0; temp[shift_right(j ^ 1, x)] = ori[j]; judge[ori[j]] = 1; &#125; else&#123; temp[shift_right(j, x)] = ori[j]; judge[ori[j]] = 0; temp[shift_right(j ^ 1, x)] = ori[j ^ 1]; judge[ori[j ^ 1]] = 1; &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) ori[j] = temp[j]; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2) ans[con2][j &gt;&gt; 1] = judge[line[j]]; for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (ans[con2][j &gt;&gt; 1])&#123; temp[shift_right(j, x)] = line[j ^ 1]; temp[shift_right(j ^ 1, x)] = line[j]; &#125; else&#123; temp[shift_right(j, x)] = line[j]; temp[shift_right(j ^ 1, x)] = line[j ^ 1]; &#125; &#125; for (int j = i; j &lt; i + (1 &lt;&lt; x); j++) line[j] = temp[j]; /*for (int j = i; j &lt; i + (1 &lt;&lt; x); j += 2)&#123; if (!vis[con2][j &gt;&gt; 1])&#123; vis[con2][j &gt;&gt; 1] = 1; ans[con2][j &gt;&gt; 1] = 0; BFS2(up[line[j]]), BFS2(up[line[j + 1]]); &#125; &#125; */ &#125; x--; con++; con2--; solve();&#125;int main()&#123; freopen("left.in", "r", stdin); freopen("left.out", "w", stdout); while (scanf("%d", &amp;n) == 1 &amp;&amp; n != 0)&#123; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) scanf("%d", &amp;line[i]); for (int i = 0; i &lt; 1 &lt;&lt; n; i++) ori[i] = i; con = 0; con2 = (n - 1) &lt;&lt; 1; x = n; solve(); for (int i = 0; i &lt; (n &lt;&lt; 1) - 1; i++)&#123; for (int j = 0; j &lt; 1 &lt;&lt; (n - 1); j++)&#123; printf("%d", ans[i][j]); &#125; printf("\n"); &#125; printf("\n"); memset(vis, 0, sizeof(vis)); &#125; return 0;&#125; 还是很考察代码能力的。。。现场发明循环移位。。。]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6075. 「2017 山东一轮集训 Day6」重建]]></title>
    <url>%2F2017%2F07%2F11%2F6075-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day6%E3%80%8D%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6075$. 「2017 山东一轮集训 Day6」重建 LOJ 6075. 「2017 山东一轮集训 Day6」重建内存限制：512 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述给定一个 $n$ 个点 $m$ 条边的带权无向连通图 $G$，以及一个大小为 $k$ 的关键点集合 $A$。有个人要从点 $s$ 走到点 $t$，现在可以对所有边加上一个非负整数 $c$，问最大的 $c$，使得加上 $c$ 后，满足：$s$ 到 $t$ 的最短路长度 $= s$ 到 $t$ 且只能经过 $A$ 中的点的最短路长度。 输入格式第一行一个整数 $T$。代表这个数据点中有 $T$ 个测试数据。对于每个测试数据：第一行包含四个整数 $n, m, s, t$。接下来 $m$ 行，每行三个整数 $u_i, v_i, c_i$​​，代表 $G$ 中有一条 $u_i$​​ 到 $v_i $​​ 的长度为 $c_i$ 的无向边。第 $m + 1$ 行包含一个整数 $k$。接下来一行 $k$ 个整数，代表关键点集合 $A$。保证 $s$ 与 $t$ 都在 $A$ 中。输出格式 对于每个测试数据，输出一行一个整数 $c$，代表最大的合法的加到每条边的权值。假如不存在这样的合法的 $c$，则输出 Impossible，假如这样的 $c$ 可以无穷大，则输出 Infinity。 样例样例输入123456789101112131415161718192021222324252636 8 1 61 2 51 3 12 6 62 3 64 2 33 4 14 5 15 6 151 3 6 5 43 4 1 21 2 61 3 21 2 72 3 321 24 4 1 41 2 11 3 12 4 13 4 131 2 4 样例输出1233InfinityInfinity 数据范围与提示对于 $20\%$ 的数据，$n, m, c_i \leq 100$；对于 $40\%$ 的数据，$n, m \leq 100$；另外有 $20\%$ 的数据，每个测试数据的答案要么为 Infinity，要么为 Impossible；对于 $100\%$ 的数据，满足 $1 \leq n \leq 1000, 1 \leq m \leq 10000, 1 \leq c_i \leq 10 ^ 9, 1 \leq T \leq 3$ 分析现在发现题目都是这样，一开始怎么也想不到，想到后很简单。。。 这道题就是，我们可以考虑分别为两个部分求最短路，同时我们知道结果肯定是一个关于$c$的一次函数，而且，路径经过的边数就是$c$的系数，观察题目数据范围，$n$比较小，这样，我们可以采用$O(n^2)$的方法，枚举经过的边数，这样做的好处就是，我们可以只考虑经过这么多条边的最短路，因为它们的$c$的系数都相同，同时再钦点它就是全局最短路，然后计算合法性以及合法区间，最后取所有右端点的最大值即可 然后我们可以用Bellman-Ford的思想，一步一步走，来计算最短路 主要还是理解题意吧，理解的比较透彻，就没什么问题了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 100005#define LL long long int#define LD long double#define eps 1e-9using namespace std;struct edge&#123; int next, to; LL cost; edge(int next, int to, LL cost) : next(next), to(to), cost(cost)&#123;&#125; edge()&#123;&#125;&#125;e[maxn &lt;&lt; 1];int h[maxn], cnt = 1;void Add_Edge(int fr, int to, LL cost)&#123; e[++cnt] = edge(h[fr], to, cost); h[fr] = cnt; e[++cnt] = edge(h[to], fr, cost); h[to] = cnt;&#125;int n, m, s, t, k;int save[maxn];int ct;LL d1[maxn][2];LL d2[maxn][2];int d = 0;LL INF;void init()&#123; INF = 1; for (int i = 0; i &lt; 18; i++) INF = 10 * INF; for (int i = 1; i &lt;= n; i++) d1[i][0] = d1[i][1] = d2[i][0] = d2[i][1] = INF; d1[s][0] = d1[s][1] = d2[s][0] = d2[s][1] = 0;&#125;void update()&#123; for (int i = 1; i &lt;= n; i++) d1[i][d ^ 1] = INF; for (int i = 1; i &lt;= ct; i++) d2[save[i]][d ^ 1] = INF; for (int i = 1; i &lt;= n; i++)&#123; for (int j = h[i]; j; j = e[j].next)&#123; int op = e[j].to; if (d1[op][d ^ 1] &gt; d1[i][d] + e[j].cost) d1[op][d ^ 1] = d1[i][d] + e[j].cost; &#125; &#125; for (int i = 1; i &lt;= ct; i++)&#123; for (int j = h[save[i]]; j; j = e[j].next)&#123; int op = e[j].to; if (d2[op][d ^ 1] &gt; d2[save[i]][d] + e[j].cost) d2[op][d ^ 1] = d2[save[i]][d] + e[j].cost; &#125; &#125; d ^= 1;&#125;LL inf[maxn][2];void work()&#123; init(); for (int i = 1; i &lt;= n; i++)&#123; update(); inf[i][0] = (d1[t][d] &lt; INF) ? d1[t][d] : -1; inf[i][1] = (d2[t][d] &lt; INF) ? d2[t][d] : -1; &#125; bool f = 0; LD ans = -1; for (int i = 1; i &lt; n; i++)&#123; if (inf[i][0] == -1) continue; if (!f)&#123; if (inf[i][0] == inf[i][1])&#123; printf("Infinity\n"); return; &#125; &#125; f = 1; if (inf[i][1] == -1 || inf[i][0] != inf[i][1]) continue; LD minnum = -INF; LD maxnum = INF; for (int j = 1; j &lt; i; j++)&#123; if (inf[j][0] == -1) continue; maxnum = min(maxnum, (LD)(inf[j][0] - inf[i][1]) / (i - j)); &#125; for (int j = i + 1; j &lt;= n; j++)&#123; if (inf[j][0] == -1) continue; minnum = max(minnum, (LD)(inf[j][0] - inf[i][1]) / (i - j)); &#125; if (minnum - maxnum &gt; eps) continue; ans = max(ans, maxnum); &#125; if (ans + 1 &lt; eps) printf("Impossible\n"); else printf("%lld\n", (LL)ans);&#125;void recover()&#123; ct = 0; cnt = 1; memset(h, 0, sizeof(h));&#125;int main()&#123; freopen("rebuild.in", "r", stdin); freopen("rebuild.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); int x, y; LL z; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%lld", &amp;x, &amp;y, &amp;z); Add_Edge(x, y, z); &#125; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++)&#123; scanf("%d", &amp;x); save[++ct] = x; &#125; work(); recover(); &#125; return 0;&#125; 其实细节还是不少的，我们每次要完全更新距离数组，不能保留上次的信息，具体为什么自己想一想就好了]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Bellman-Ford</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6190. 序列查询]]></title>
    <url>%2F2017%2F07%2F11%2F6190-%E5%BA%8F%E5%88%97%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6190$. 序列查询 LOJ 6190. 序列查询内存限制：256 MiB时间限制：2000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述给出序列 ${a_n}$给出 $m$ 个询问 $[L_i,R_i]$ : 询问 $min{|a_s−a_t|},s,t∈[Li,Ri],s≠t$ 输入格式第一行一个整数 $n$。第二行 $n$ 个整数，表示 $a_i$​​。第三行一个整数 $m$，表示询问个数。之后的 $m$ 行，每行两个正整数，表示 $L_i, R_i$​​。 输出格式共 $m$ 行，表示询问的答案。特别的，如果不存在答案，输出 $2147483647$。 样例样例输入 11234542 2 3 421 22 4 样例输出 11201 数据范围与提示$1\le n\le 10^5,1\le a_i \le 10^9,1\le m \le 3\times 10^5$ 分析显然一道数据结构题，全都是套路。。。然而今天才猛然发现线段树套平衡树空间复杂度为$O(n\log{n})$ 方法很独特，我称之为定序积累法，首先把所有的询问读入，然后按照左端点排序，同时从右向左逐个更新答案，在达到左端点时取出询问，这样总复杂度就是$O(n\log n)$，这要求答案是可以逐个积累的，就像上面说的那样，具体细节可参见代码 同时这次又看见了大佬在线段树内部调用线段树函数的操作，神不可言～ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;ctype.h&gt;#define maxn 300005#define INF 2147483647using namespace std;int line[maxn];int n, m;struct query&#123; int t, l, r, ans; query(int t, int l, int r) : t(t), l(l), r(r)&#123;&#125; query()&#123;&#125;&#125;q[maxn];bool cmp1(query a, query b)&#123; if (a.l != b.l) return a.l &lt; b.l; return a.r &lt; b.r;&#125;bool cmp2(query a, query b)&#123; return a.t &lt; b.t;&#125;void read(int&amp; x)&#123; char ch; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();&#125;set&lt;int&gt; s[maxn &lt;&lt; 2];int ans[maxn &lt;&lt; 2];int qx, qy, qd;void init(int l, int r, int o)&#123; if (l == r)&#123; ans[o] = INF; s[o].insert(line[l]); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; init(l, mid, o &lt;&lt; 1); init(mid + 1, r, o &lt;&lt; 1 | 1); for (int i = l; i &lt;= r; i++) s[o].insert(line[i]); ans[o] = INF;&#125;int get(int l, int r, int o)&#123; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[o]; int mid = ((r - l) &gt;&gt; 1) + l; int ans = INF; if (qx &lt;= mid) ans = min(ans, get(l, mid, o &lt;&lt; 1)); if (qy &gt; mid) ans = min(ans, get(mid + 1, r, o &lt;&lt; 1 | 1)); return ans;&#125;void update(int l, int r, int o, int&amp; now)&#123; if (qx &gt; qy) return; if (l == r)&#123; ans[o] = min(abs(line[l] - qd), ans[o]); now = min(now, ans[o]); return; &#125; int mid = ((r - l) &gt;&gt; 1) + l; set&lt;int&gt; :: iterator k = s[o].lower_bound(qd); if (((k == s[o].end()) || (abs(*k - qd)) &gt;= now) &amp;&amp; ((k == s[o].begin()) || (abs(*(--k) - qd) &gt;= now)))&#123; now = min(now, get(l, r, o)); return; &#125; if (qx &lt;= mid) update(l, mid, o &lt;&lt; 1, now); if (qy &gt; mid) update(mid + 1, r, o &lt;&lt; 1 | 1, now); ans[o] = min(ans[o &lt;&lt; 1], ans[o &lt;&lt; 1 | 1]);&#125;int main()&#123; freopen("query.in", "r", stdin); freopen("query.out", "w", stdout); read(n); for (int i = 1; i &lt;= n; i++) read(line[i]); read(m); for (int i = 0; i &lt; m; i++)&#123; read(q[i].l), read(q[i].r); q[i].t = i; &#125; init(1, n, 1); sort(q, q + m, cmp1); int j = n; for (int i = m - 1; i &gt;= 0; i--)&#123; for(; j &gt;= q[i].l; j--)&#123; int now = INF; qx = j + 1, qy = n, qd = line[j]; update(1, n, 1, now); &#125; qx = q[i].l, qy = q[i].r; q[i].ans = get(1, n, 1); &#125; sort(q, q + m, cmp2); for (int i = 0; i &lt; m; i++) printf("%d\n", q[i].ans); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
        <tag>线段树套平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6161. 「美团 CodeM 初赛 Round A」倒水]]></title>
    <url>%2F2017%2F07%2F11%2F6161-%E3%80%8C%E7%BE%8E%E5%9B%A2-CodeM-%E5%88%9D%E8%B5%9B-Round-A%E3%80%8D%E5%80%92%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6161$. 「美团 CodeM 初赛 Round A」倒水 LOJ 6161. 「美团 CodeM 初赛 Round A」倒水内存限制：32 MiB时间限制：1000 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述有一个大水缸，里面的水温度为 $T$ 单位，体积为 $C$ 升。另有 $n$ 杯水，每杯水有温度 $t_i$ 单位与体积 $c_i$ 升。现在要把大水缸的水倒入 $n$ 杯水中使得 $n$ 杯水的温度相同，请问这是否可能？如果可能，请求出可行的最高的温度，保留 4 位小数。 注意：一杯温度为 $t_1$​​ 单位，体积为 $c_1$​​ 升的水与另一杯温度为 $t_2$ 单位，体积为 $c_2$​​ 升的水混合后温度变为 $\frac{t_1\times c_1+t_2\times c_2}{c_1+c_2}​$​​​​，体积变为 $c_1+c_2$​​。 输入格式第一行一个整数 $n$。 第二行两个整数 $T,C$。 接下来 $n$ 行每行两个整数 $t_i,c_i$​​。 输出格式如果非法，输出 Impossible。 否则第一行输出 Possible，第二行输出一个保留 4 位小数的实数表示答案。 样例样例输入12345310 220 125 130 1 样例输出12Possible20.0000 样例解释往第二杯水中倒 $0.5$ 升水。 往第三杯水中到 $1$ 升水。 三杯水的温度都变成了 $20$。 数据范围与提示$1\le n\le 10^5,0\le t_i,c_i,T\le 10^4,0\le C\le 10^9$ 分析其实很容易看出来是一个二分答案，因为在大水缸中温度很高的时候，要使杯子里的水温度越高，就需要越多的大水缸中的水，这样就可以二分了，同时，当大水缸温度介于最高温度与最低温度之间且最高温度不等于最低温度时无解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 20005#define eps 1e-6#define maxn 100005using namespace std;struct glass&#123; double t, c; glass(double t, double c) : t(t), c(c)&#123;&#125; glass()&#123;&#125;&#125;save[maxn];int dcmp(double a, double b)&#123; if (a - b &gt; eps) return 1; else if (b - a &gt; eps) return -1; return 0;&#125;bool cmp(glass a, glass b)&#123; if (a.t != b.t) return dcmp(a.t, b.t) &lt; 0; return dcmp(a.c, b.c) &lt; 0;&#125;double C, T;int n;bool judge(double x)&#123; double all = 0; for (int i = 0; i &lt; n; i++)&#123; all += save[i].c * (x - save[i].t) / (T - x); &#125; if (dcmp(C, all) &gt;= 0) return true; return false;&#125;double work(double l, double r)&#123; if (r - l &lt; eps) return l; double mid = ((r - l) / 2) + l; if (judge(mid)) return work(mid, r); else return work(l, mid);&#125;int main()&#123; freopen("water.in", "r", stdin); freopen("water.out" ,"w", stdout); scanf("%d", &amp;n); scanf("%lf%lf", &amp;T, &amp;C); for (int i = 0; i &lt; n; i++)&#123; scanf("%lf%lf", &amp;save[i].t, &amp;save[i].c); &#125; sort(save, save + n, cmp); if (dcmp(T, save[0].t) &gt;= 0 &amp;&amp; dcmp(T, save[n - 1].t) &lt;= 0)&#123; for (int i = 0; i &lt; n; i++)&#123; if(dcmp(T, save[i].t) != 0)&#123; printf("Impossible\n"); return 0; &#125; &#125; printf("Possible\n%.4lf", save[0].t); return 0; &#125; if (dcmp(T, save[0].t) &lt; 0)&#123; if (judge(save[0].t))&#123; printf("Possible\n%.4lf", save[0].t); &#125; else printf("Impossible\n"); &#125; else&#123; if (!judge(save[n - 1].t - eps))&#123; printf("Impossible\n"); return 0; &#125; printf("Possible\n%.4lf", work(save[n - 1].t, T)); &#125; return 0;&#125; 忘记全相等的情况了$QAQ$]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#6164. 「美团 CodeM 初赛 Round A」数列互质]]></title>
    <url>%2F2017%2F07%2F11%2F6164-%E3%80%8C%E7%BE%8E%E5%9B%A2-CodeM-%E5%88%9D%E8%B5%9B-Round-A%E3%80%8D%E6%95%B0%E5%88%97%E4%BA%92%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[引言题解：$Libre$ $Online$ $Judge$ # $6164$. 「美团 CodeM 初赛 Round A」数列互质 LOJ 6164. 「美团 CodeM 初赛 Round A」数列互质内存限制：512 MiB时间限制：500 ms标准输入输出题目类型：传统评测方式：文本比较 题目描述给出一个长度为 $n$ 的数列 $a_1 , a_2 , a_3\cdots a_n$以及 $m$ 组询问$(l_i , r_i , k_i)$，求区间 $[ l_i , r_i ]$ 中有多少数在该区间中的出现次数与 $k_i$​​ 互质。 输入格式第一行，两个正整数 $n,m$。 第二行，$n$ 个正整数 $a_i$​​ 描述这个数列。 接下来 $m$ 行，每行三个正整数 $l_i , r_i , k_i$，描述一次询问。 输出格式输出 $m$ 行，即每次询问的答案。 样例样例输入123456710 51 1 1 1 1 2 2 2 2 24 7 24 7 34 8 24 8 33 8 3 样例输出1234502110 数据范围与提示$1\le n,m\le 5\times 10^4$$1\le a_i\le n$$1\le l_i\le r_i\le n$$1\le k_i\le n$ 分析基本就是一个序列莫队，这个怎么想到呢？大概就是发现别的算法大概都不是非常有效，所以想到的吧（逃 但其实我一开始以为莫队会超时，因为在更换$k$的时候我本以为要重新扫一遍当前维护的信息序列，然而正解十分机智，存储了次数的出现次数，这样保证不会超过$O(\sqrt{n})$的复杂度，应该也是逐步思考，然后想到通过这种方法来进行合并优化的吧 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define maxn 3000005using namespace std;struct q&#123; int l, r, k, t, ans; q(int l, int r, int k, int t) : l(l), r(r), k(k), t(t)&#123;&#125; q()&#123;&#125;&#125;sline[maxn];int n, m;int pos[maxn];int size;void init()&#123; for (int i = 0; i &lt; n; i++)&#123; pos[i] = i / size; &#125;&#125;bool cmp(q a, q b)&#123; if (pos[a.l] != pos[b.l]) return pos[a.l] &lt; pos[b.l]; return a.r &lt; b.r;&#125;bool cmp2(q a, q b)&#123; return a.t &lt; b.t;&#125;bool vis[maxn];int line[maxn];int l, r;int save[maxn];int ct;int num[maxn];int cnt[maxn];int gcd(int l, int r)&#123; return (r == 0) ? l : gcd(r, l % r);&#125;void ins(int x)&#123; if (num[cnt[line[x]]]) num[cnt[line[x]]]--; cnt[line[x]]++; save[ct++] = cnt[line[x]]; num[cnt[line[x]]]++;&#125;void del(int x)&#123; if (num[cnt[line[x]]]) num[cnt[line[x]]]--; if(cnt[line[x]]) cnt[line[x]]--; save[ct++] = cnt[line[x]]; num[cnt[line[x]]]++;&#125;int get_ans(int k)&#123; int ans = 0; int temp = 0; for (int i = 0; i &lt; ct; i++)&#123; if (!vis[save[i]] &amp;&amp; num[save[i]])&#123; vis[save[i]] = 1; if (save[i] != 0 &amp;&amp; gcd(k, save[i]) == 1) ans += num[save[i]]; save[temp++] = save[i]; &#125; &#125; ct = temp; for (int i = 0; i &lt; ct; i++) vis[save[i]] = 0; return ans;&#125;int main()&#123; freopen("seq.in", "r", stdin); freopen("seq.out", "w", stdout); scanf("%d%d", &amp;n, &amp;m); size = (int)sqrt(n) + 1; init(); int l, r, k; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;line[i]); &#125; for (int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); sline[i] = q(l - 1, r - 1, k, i); &#125; sort(sline, sline + m, cmp); l = 0, r = -1; for (int i = 0; i &lt; m; i++)&#123; while (r &gt; sline[i].r) del(r--); while (r &lt; sline[i].r) ins(++r); while (l &gt; sline[i].l) ins(--l); while (l &lt; sline[i].l) del(l++); sline[i].ans = get_ans(sline[i].k); &#125; sort(sline, sline + m, cmp2); for (int i = 0; i &lt; m; i++)&#123; printf("%d\n", sline[i].ans); &#125; return 0;&#125; 好久没写莫队各种被坑。。。感觉还是要仔细一些吧，同时要注意$k=1$的情况，需要进行一些特判，否则会带上次数等于零的那些数字，感觉自己还是不够仔细]]></content>
      <tags>
        <tag>序列操作</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dilworth定理]]></title>
    <url>%2F2017%2F07%2F01%2FDilworth%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[引言今天这个定理是我在逛某神犇博客时看到的，是一个以前从未听说过的定理，今天我就来简单介绍一下 Dilworth 定理这是一个应用于偏序集上的定理，应该属于是序理论和组合数学那里面的一些内容，所以我们先来普及一下基础知识 偏序设A是一个非空集，P是A上的一个关系，若关系P是自反的、反对称的、和传递的，则称P是集合A上的偏序关系 即P适合下列条件： 对任意的a∈A,(a,a)∈P;&lt;/br&gt;&lt;/br&gt; 若（a,b)∈P且（b,a)∈P,则a=b;&lt;/br&gt;&lt;/br&gt; 若（a,b)∈P,(b,c)∈P,则（a,c)∈P,则称P是A上的一个偏序关系。带偏序关系的集合A称为偏序集或半序集 若P是A上的一个偏序关系，我们用a≤b来表示（a,b)∈P 比方说：(A,≤)是偏序集，A={1,2,3},偏序≤在A上的大于等于关系。则有：≤={,,,,,},则有3≤2,2≤2,2≤1…. 举如下例子说明偏序关系： 实数集上的小于等于关系是一个偏序关系&lt;/br&gt;&lt;/br&gt; 设S是集合，P（S）是S的所有子集构成的集合，定义P（S）中两个元素A≤B当且仅当A是B的子集，即A包含于B，则P（S）在这个关系下成为偏序集&lt;/br&gt;&lt;/br&gt; 设N是正整数集，定义m≤n当且仅当m能整除n，不难验证这是一个偏序关系。注意它不同于N上的自然序关系 偏序集偏序是在集合X上的二元关系≤(这只是个抽象符号，不是“小于或等于”)，它满足自反性、反对称性和传递性。即，对于X中的任意元素a,b和c，有: 自反性：a≤a&lt;/br&gt;&lt;/br&gt; 反对称性：如果a≤b且b≤a，则有a=b&lt;/br&gt;&lt;/br&gt; 传递性：如果a≤b且b≤c，则a≤c &lt;/br&gt;&lt;/br&gt; 带有偏序关系的集合称为偏序集 令(X,≤)是一个偏序集，对于集合中的两个元素a、b，如果有a≤b或者b≤a，则称a和b是可比的，否则a和b不可比 例：(A,≤)是偏序集，其中A={1,2,3,4,5}，其中≤是整除关系，那么对任意的x∈p都有1≤x,所以1和1,2,3,4,5都是可比的，但是2不能整除3，且3不能整除2，所以2和3是不可比的 在X中，对于元素a，如果任意元素b，由b≤a得出b=a，则称a为极小元 链和反链一个反链A是X的一个子集，它的任意两个元素都不能进行比较一个链C是X的一个子集，它的任意两个元素都可比 Dilworth Theorem下面是两个重要定理： 定理1 令（X,≤）是一个有限偏序集，并令r是其最大链的大小。则X可以被划分成r个但不能再少的反链其对偶定理称为Dilworth定理： 定理2 令（X,≤）是一个有限偏序集，并令m是反链的最大的大小。则X可以被划分成m个但不能再少的链 证明：设p为最少反链个数 先证明X不能划分成小于r个反链。由于r是最大链C的大小，C中任两个元素都可比，因此C中任两个元素都不能属于同一反链。所以p&gt;=r&lt;/br&gt;&lt;/br&gt; 设X1＝X，A1是X1中的极小元的集合。从X1中删除A1得到X2。注意到对于X2中任意元素a2，必存在X1中的元素a1，使得a1&lt;=a2。令A2是X2中极小元的集合，从X2中删除A2得到X3……最终，会有一个Xk非空而X(k+1)为空。于是A1,A2,…,Ak就是X的反链的划分，同时存在链a1&lt;=a2&lt;=…&lt;=ak，其中ai在Ai内。由于r是最长链大小，因此r&gt;=k。由于X被划分成了k个反链，因此r&gt;=k&gt;=p。因此r=p，定理1得证 Hasse Diagram In order theory, a Hasse diagram (/ˈhæsə/; German: [ˈhasə]) is a type of mathematical diagram used to represent a finite partially ordered set, in the form of a drawing of its transitive reduction. Concretely, for a partially ordered set (S, ≤) one represents each element of S as a vertex in the plane and draws a line segment or curve that goes upward from x to y whenever y covers x (that is, whenever x &lt; y and there is no z such that x &lt; z &lt; y). These curves may cross each other but must not touch any vertices other than their endpoints. Such a diagram, with labeled vertices, uniquely determines its partial order. 大概翻译过来，就是哈赛图是一个有向无环图，它的每条边都是紧密相连的，换句话说它就是一个有向无环图的传递规约——去掉了所有多余的边的图，例如有边A-&gt;B, B-&gt;C,这时如果A-&gt;C也存在，那么它就是一条多余的边 搞清楚了反链和链的定义，就能够很好的从Hasse Diagram中得到理解。链就是从纵向的角度看 Hasse Diagram ,反链是从横向的角度看Hasse Diagram，这一点应该很好理解 例题先列举几道，有时间再做一下： hdu 3335 poj 1065 poj 1548 poj 3636 nyist 255]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>序理论</tag>
        <tag>Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狄利克雷卷积详解]]></title>
    <url>%2F2017%2F06%2F30%2F%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言作为初入莫比乌斯反演的Oier，怎么能不学狄利克雷卷积呢？下面我就来简单地介绍一下： 定义狄利克雷卷积：(f×g)(n)=\sum_{d|n}f(d)∗g(\frac{n}{d})一个例子：$f(x)=2x,g(x)=3x$则$(f×g)(6)=f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)$，往往省略掉$n$ 狄利克雷卷积定义在数论函数上 数论函数： 如果一个函数的定义域为正整数，值域为复数，则称此函数为数论函数常见的数论函数有欧拉函数$φ$和莫比乌斯函数$μ$ 运算律：1. 结合律(f×g)×h=f×(g×h)2. 交换律f×g=g×f3. 加法-狄利克雷卷积分配律f×(g+h)=f×g+f×h4. 单位元单位函数$ϵ$，使得f=ϵ×f=f×ϵ，单位函数的取值：$n=1$时$ϵ(n)=1$，$n$取其他值时$ϵ(n)=0$ 5. 逆元对于任意数论函数$f$，如果$f(1)≠0$，则存在唯一的逆函数$f^{-1}$，使得$f×f^{-1}=ϵ$：对于$n=1$，有：$f^{-1}(1)=\frac{1}{f(1)}$对于$n&gt;1$，有：f^{-1}(1)=\frac{-1}{f(1)}\sum_{d|n,n≠d}f(\frac{n}{d})f^{-1}(d) 狄利克雷卷积是对数论函数的二元运算，产生的结果也显然是一个数论函数，因此满足封闭性。又综合1、4、5，得到： $G(数论函数,×)$是一个群 特殊函数由于 \sum_{d|n} \varphi(d)=n 易得：φ×1=n 回顾莫比乌斯反演：F(n)=\sum_{d|n}f(d) 这句话的意思就是f×1=F 根据莫比乌斯函数的性质或定义：μ×1=ϵ f×1=F×ϵ=F×μ×1故：f=F×μ可以推出莫比乌斯反演定理：f=μ×F 也即日常所见的式子：f(n)=\sum_{d|n}μ(d)F(\frac{n}{d}) 根据狄利克雷卷积的交换律，上面的式子可以改写：f=F×μ故f(n)=\sum_{d|n}μ(\frac{n}{d})F(d) 积性函数数论函数$f$，如果对于所有$a⊥b$有$f(a∗b)=f(a)∗f(b)$，则称$f$为积性函数进一步，如果对于所有$a,b∈Z^+$都有$f(a∗b)=f(a)∗f(b)$，则称$f$为完全积性函数 两个积性函数的狄利克雷卷积也是积性函数 两个例子：欧拉函数$φ$和莫比乌斯函数$μ$ 都可以用线性筛求，快速求因子 可以以$O(n)$的代价预处理$[1,n]$的所有数，然后$O(logn)$ 分解质因子做法：先跑一遍线性筛，以$son[i]$记录把$i$筛掉的最小的质数 分解质因数的时候，不停地$n=n/son[n]$来分解 可以证明复杂度是单次$O(logn)$：每迭代一次，$n$被除以$son[n]$，而$son[n]$最小为$2$，故时间复杂度不超过$O(logn)$ 积性函数前缀和原文里写的好像是什么杜教筛，那个在另一篇文章里再写吧 哈哈，改别人的文章还是很爽的，改一改就是自己的了，那么狄利克雷卷积的讲解就到此位置啦，再见~ ~(≧▽≦)/~啦啦啦]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>狄利克雷卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教筛原理详解]]></title>
    <url>%2F2017%2F06%2F30%2F%E6%9D%9C%E6%95%99%E7%AD%9B%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言刚才简单看了下，正如某位神犇博客上所说的，大千世界，无(sang)奇(xin)不(bing)有(kuang)，居然有比线性筛还要快的算法——杜教筛 orz 主要看了看推导，是用来求$\mu(x)$（莫比乌斯函数）的前缀和的东西（其实是用来求积性函数的前缀和的一种方法） 下面简单地推导一下： 推导首先约定下记号，令f(n)=\sum\_{d|n}\mu(d) 令s(n)=\sum\_{i=1}^n\mu(i) 令g(n)=\sum\_{i=1}^nf(i) 那么显然有g(n)=1（要是你认真学了莫比乌斯反演的话） 然后，我们开始搞，怎么搞呢？我们可以这样： 由于g(n)=\sum_{i=1}^nf(i) 且f(n)=\sum_{d|n}\mu(d) 代入有 g(n)=\sum_{i=1}^{n} \sum_{d|i}\mu(d)则有g(n)=\sum_{i=1}^n\mu(i)*\lfloor{\frac{n}{i}}\rfloor 所以g(n)=\sum_{i=1}^ns(\frac{n}{i}) 这一步需要一些感性理解，然后，我们又知道g(n)=1 所以s(n)=1-\sum_{i=2}^ns(\frac{n}{i}) 然后据说通过什么记忆化+暴力$hash$+积分+预处理可以搞到复杂度$O(n^{\frac{3}{4}})$或者是$O(n^{\frac{2}{3}})$，真是玄学。。。 那么剩下的部分就再用别的文章来介绍啦，今天杜教筛的讲解到此为止（其实就是一堆简(e)单(xin)的数学推导）]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演详解]]></title>
    <url>%2F2017%2F06%2F30%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言终于把莫比乌斯反演搞得一清二楚啦（原来我就是那么一个小地方没搞懂，唉我真是太垃圾了），下面对这一神奇的数论定理予以详细的介绍： 注，由于我们目前研究的都是数论函数，所以默认定义域均为$Z^+$ 首先，我们考虑一类函数$F(x)$与$f(x)$，它们之间有如下的性质： F(n)=\sum_{d|n} f(d)那么，如果现在我们想知道$f(n)$的表达式该怎么办呢？它其实是这样的： f(n)=\sum_{d|n} \mu(d)*F(\frac{n}{d})其中$\mu(d)$是莫比乌斯函数，它的取值定义如下： \mu(d)= \begin{cases} 1,\mbox{if }\mbox{ d = 1}\\ 0,\mbox{if }\mbox{ d 含有平方因子}\\ (-1)^n,\mbox{if } \mbox{ d = }p_1*p_2*\cdots*p_n\\ \end{cases}其中含有平方因子意为存在某一个质因子的平方可以整除$d$ 这样，我们就介绍完莫比乌斯反演公式啦 其实它还有一种形式，这种形式才是十分常用的，我就是不知道这个才墨迹了那么长的时间： 还是对于两个函数$F(x)$与$f(x)$，它们有如下的性质： F(n)=\sum_{n|d} f(d)体会一下区别啊！可别这么翻过去了 那么它们满足： f(n)=\sum_{n|d} \mu(\frac{d}{n})*F(d)这种形式与上述形式十分相近，但这种形式的用处却十分广泛，广泛用于各种信息技术领域以及SB一样的省选题 这样，莫比乌斯反演呢我们就介绍完了，下面讨论一下它的证明，哦对了，还有一个性质没有说，那就是： \sum_{d|n}\mu(d)= \begin{cases} 1,\mbox{if d = 1}\\ 0,\mbox{if d}\not=\mbox{1}\\ \end{cases}这个性质十分重要，证明过程留给读者。提示：使用组合计数原理以及二项式定理。下面就会看到它在证明莫比乌斯反演定理中的重要性： 先证第一种形式： 首先，我们可知：f(n)=\sum_{d|n} \mu(d)*F(\frac{n}{d})然后，我们做一些变换，代入$F(x)$与$f(x)$之间的性质：F(n)=\sum_{d|n} f(d)则有：f(n)=\sum_{d|n} \mu(d)*{\sum_{k|{\frac{n}{d}}}f(k)}然后，下面需要一些感性思维：f(n)=\sum_{k|n} f(k)*{\sum_{d|{\frac{n}{k}}}\mu(d)}然后根据上面的重要性质，可以把第二个级数搞掉，它只有在$k=n$时才为$1$，否则全为零 那么就有右式等于$f(n)$，证毕！ 然后对于第二种形式来说，我们可以类比上述过程进行证明，当做思考题啦~ 那么，莫比乌斯反演到这里就讲完啦，题目会由其他文章提供与详解，再见啦 ~(≧▽≦)/~]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演总结]]></title>
    <url>%2F2017%2F06%2F30%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言首先大家都知道莫比乌斯反演是什么对吧，那么下面直接对一些常用的公式推导技巧进行一些汇总 说实话你把高效的公式推导出来了代码还不会编么，然后不就轻松AC了么 约定首先规定几个常用的数论函数： 莫比乌斯函数μ(x)\mu(x)=\begin{cases} 1,& x=1\\\\ (-1)^{n},& x=\prod_{i=1}^{n}p_i\mbox{ }\mbox{ }\mbox{ (}p_i\mbox{两两不同且为质数)}\\\\ 0,&\exists p^2\mid x \mbox{ 且 }p\mbox{为质数} \end{cases}恒等函数id(x)id(x)\equiv x欧拉函数(x) \varphi(x)=x*\prod_{i=1}^{n}\left(1-\frac{1}{p_i}\right)\mbox{其中 }x=\prod_{i=1}^{n}p_i^{\alpha_i} \mbox{(}p_i \mbox{两两不同且为质数)}单位函数e(x)e(x)=\begin{cases} 1,&x=1 \\\\ 0,&x>1 \end{cases}常用定理先列一发大纲： 质因子定理 调和级数定理 $Dirichlet$卷积运算律定理 $Dirichlet$卷积性质定理 $Dirichlet$卷积复杂度定理 莫比乌斯反演定理 $\varphi$函数定理 质因子定理自己命名，指的是下面这个等式： gcd(i,j)*lcm(i,j)\equiv i*j证明较为容易 调和级数定理即有下面的等式： \sum_{d=1}^{N}\frac{N}{d}=N\log N微积分证明 平方根调和级数定理即有下面的等式： \sum_{d=1}^{N}\sqrt{\frac{N}{d}}=N微积分证明 Dirichlet卷积运算律定理$Dirichlet$卷积满足：交换律，结合律证明较为容易 Dirichlet卷积性质定理两个积性函数的$Dirichlet$卷积仍然是积性函数证明较为容易 Dirichlet卷积复杂度定理我们可以枚举每一个数字并对它的每一个倍数进行统计计算，这样做的复杂度是调和级数，由上述定理，有$Dirichlet$卷积复杂度为$O(\sum_{d=1}^{N}\frac{N}{d}=N\log N)$ 莫比乌斯反演定理有两种形式： A形式F(n)=\sum_{d|n} f(d) \Leftrightarrow f(n)=\sum_{d|n} \mu(d)*F(\frac{n}{d})B形式F(n)=\sum_{n|d} f(d) \Leftrightarrow f(n)=\sum_{n|d} \mu(\frac{d}{n})*F(d)可以通过数学变换或是$Dirichlet$卷积来进行证明 φ函数定理定义$F(x)$ 表示所有小于$x$且与$x$互质的数的和，其中$x&gt;1$，则有： F(x)=\varphi(x)*\frac{x}{2}这个的推导比较简单，留给读者自行思考 数论公式推导技巧先列一发大纲 $\mu$变换 $\mu$提取 $\varphi$变换 积性函数提取 $Dirichlet$卷积 下面一个个地进行说明 μ变换其实这个非常简单啦，但是有的时候容易被人忽略，大概形式就是这样的： [P(x)==k]\Leftrightarrow\sum_{d\mid P(x)/k}\mu(d)这个应该都很容易看懂吧…… 这个公式也许有人不太习惯使用，但实际上当你学会了他以后，你会对莫比乌斯反演有更直观的认识与感受，帮助你快速地进行推导而完全不需要套用莫比乌斯反演定理 μ提取这个往往与上一步是同时进行的，这个提取的含义就是把 $\mu(d)$ 的系数计算出来，以便后续计算，大概是这样的： \sum_{x}\sum_{d\mid P(x)/k}\mu(d)=\sum_{d}\mu(d)*num(d)其中 $num(d)$ 表示 $\mu(d)$ 总共出现的次数 最常用的一个形式是这样的： \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d\mid gcd(i,j)/k}\mu(d)=\sum_{d}\mu(d)*\left\lfloor \frac{n}{d*k}\right\rfloor*\left\lfloor \frac{m}{d*k}\right\rfloor这里即有： num(d)=\left\lfloor \frac{n}{d*k}\right\rfloor*\left\lfloor \frac{m}{d*k}\right\rfloorφ变换基本就是这个式子，令$Sum(x)$表示小于$x$且与$x$互质的数的和，则有： Sum(x)=\frac{x*\varphi(x)}{2}这是因为，如果$i$与$x$互质$(i&lt;x)$，那么易证$x-i$也与$x$互质，这样，我们把他们两两组合，加和，就有了上面的式子，为了计算方便，一般特殊规定$Sum(1)=1$ 积性函数提取有的时候，我们算法的时间复杂度会因为需要枚举变量$k$（或更多），同时在每个$k$（或更多）之中进行一些分块前缀和计算而导致TLE，我们可以使用一些类似于“封装”的技巧，把公式的某一大部分看成一个数论函数（通常要求这个函数满足积性），然后对这个函数进行预处理，从而达到降维的目的 比如，我们看下面的这个式子： \prod_{k=1}^{n}F(k)^{\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d\mid gcd(i,j)/k}\mu(d)}=\prod_{k=1}^{n}F(k)^{\sum_{d}\mu(d)*\left\lfloor \frac{n}{d*k}\right\rfloor*\left\lfloor \frac{m}{d*k}\right\rfloor}这个式子看似无法继续优化，但是如果我们继续进行积性函数提取，我们可以把前半部分进行封装，变成下面的样子： \prod_{T=1}^{n} \left(\prod_{d\mid T}F(d)^{\mu(\frac{T}{d})} \right) ^{\left\lfloor \frac{n}{T}\right\rfloor*\left\lfloor \frac{m}{T}\right\rfloor}此时，我们可以把前半部分提取出来，作为一个新的函数，像下面这样： G(T)=\prod_{d\mid T}F(d)^{\mu(\frac{T}{d})}我们现在的任务就是要预处理出所有的$G(x)$，这样原公式的效率就有了大大的提升 而对于这种函数，如果它们是下面这种形式，就很好处理： F(T)=\sum_{d\mid T}G(d)或是： F(T)=\prod_{d\mid T}G(d)而且求出$G(x)$ 的复杂度为$O(x)$ 的话，那么求出所有的$F(x)$ 的复杂度即为$O(N\log N*O(N))$ 其实这个应该很好理解，我们只要枚举$d$然后对于每一个$d*k$都进行更新即可，这是一个调和级数，即： \sum_{d=1}^{N}\frac{N}{d}=N\log N而在上例中，求出$G(x)$ 的复杂度为$O(1)$ 的，所以预处理复杂度为$O(N\log N)$ 由平方根调和级数定理可知，运行的复杂度由原先的 $ O(Q∗N) $ 优化为了 $ O(N\log N+Q∗\sqrt{N}) $ Dirichlet卷积我们在推导公式的时候，往往可以加入一些处理，使得公式的一部分达到如下的形式： \sum_{i\mid n}F(i)*G(\frac{n}{i})=(F*G)(n)这时，很明显这就是$Dirichlet$卷积的形式，我们可以做如下两个方向的处理： 第一种，我们可以直接预处理这部分函数，复杂度$O(N \log N)$ 第二种，我们可以利用$Dirichlet$卷积的性质：两个积性函数的$Dirichlet$卷积仍然是积性函数，这时我们就可以使用线性筛法进行$O(N)$ 的预处理 交换不变性这个指的是，当一个式子中并列存在许多的$\sum$或是$\prod$的时候，我们可以将它们任意调换顺序，同时转移相互依存的条件，这样我们就可以实现一些想要达到的目的 举个例子： \begin{array}{lcl} \sum_{i = 1} ^ {n} \sum_{j = 1} ^ {m} \sum_{d = 1} ^ {\min(n, m)} [gcd(i,j) = d]\\\\= \sum_{d = 1} ^ {\min(n, m)} \sum_{i = 1} ^ {n} \sum_{j = 1} ^ {m}\mbox{ }[gcd(i,j) = d] \end{array}同时，在指数上的 $\sum_{}^{}$ 可以与外面的 $\prod_{} ^{}$ 进行自由交换，还是用上面提到过的那个例子： \begin{array}{lcl} \prod_{k=1}^{n}F(k)^{\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d\mid gcd(i,j)/k}\mu(d)}\\\\=\prod_{k=1}^{n}F(k)^{\sum_{d}\mu(d)*\left\lfloor \frac{n}{d*k}\right\rfloor*\left\lfloor \frac{m}{d*k}\right\rfloor}\\\\=\prod_{T=1}^{n} \left(\prod_{d\mid T}F(d)^{\mu(\frac{T}{d})} \right) ^{\left\lfloor \frac{n}{T}\right\rfloor*\left\lfloor \frac{m}{T}\right\rfloor} \end{array}这就是一个非常好的提取指数上的 $\sum_{}^{}$ 的例子 数论公式计算技巧Dirichlet卷积计算方法前面多次提到过，就是枚举每一个数字并对它的每一个倍数进行统计计算即可 积性函数线性筛法对于一个积性函数，我们一般可以尝试寻找一种方法，使得它可以在线性筛的过程被“顺便”计算出来，比如对于这个函数： F(x)=\sum_{k\mid x}\mu(k)* k我们可以证明这是一个积性函数，然后我们就可以尝试在线性筛中以$O(N)$复杂度进行计算，否则，我们只能采用类似$Dirichlet$卷积的方法，在$O(N\log N)$的时间中对其计算，在$N\approx 10^7$时很容易超时 具体方法如下（在线性筛意义下给出）： 首先有F[1]=1其次 F(i * prime[j])=\begin{cases} F[i] * (1 - prime[j]),& prime[j] \nmid i \\\\ F[i],& prime[j]\mid i \end{cases}常用公式推导这些就是需要通过多做题来进行总结的啦什么东西不是靠做题……，下面简单地总结几个，以后如果再遇到就继续进行添加 单维分块法计算即需要我们计算如下的式子： \sum_{i=1}^{n}\left\lfloor\frac{n}{i}\right\rfloor这时，我们可以对此进行分类讨论，对于$i&lt;\sqrt{n}$ 的情况与$i&gt;\sqrt{n}$ 的情况分别处理，每次跳动一个值不变的区间，这样，我们可以得到一个$O(\sqrt{n})$ 的算法 双维分块法计算即需要我们计算如下的式子： \sum_{i=1}^{n}\left\lfloor\frac{n}{i}\right\rfloor*\left\lfloor\frac{m}{i}\right\rfloor这时，我们可以继续沿用上面的方法，但不同的是，我们每次跳动的距离需要多考虑一个$m$，这样，我们每次取对于$n$与$m$来说的跳动距离的较小值，然后进行跳动即可，复杂度$O(\sqrt{MAX(n,m)})$ 最大公约数统计就是要求下面这个式子： \sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)下面对此进行推导： \begin{array}{lcl}\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)\\\\ =\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d=1}^{MIN(n,m)}d*[gcd(i,j)=d]\\\\ =\sum_{i=1}^{n} \sum_{j=1}^{m} \sum_{d=1}^{MIN(n,m)}d* \sum_{k\mid gcd(i,j)/d} \mu(k) &\mbox{(}\mu\mbox{变换)}\\\\ =\sum_{d=1}^{MIN(n,m)}d*\sum_{k=1}^{MAX(n,m)} \mu(k)*\left\lfloor\frac{n}{d*k} \right \rfloor \left\lfloor\frac{m}{d*k} \right \rfloor &\mbox{(}\mu\mbox{提取)} \end{array} 一般推到这里就结束了，使用分块计算的方法，能在下面的时间内求出答案： O\left(\sum_{d=1}^{N}\sqrt{\frac{N}{d}}\right) 这个计算完大概是$O(N)$ 的复杂度 但是，我们还可以进一步得到下面的式子： \begin{array}{lcl}\sum_{d=1}^{MIN(n,m)}d*\sum_{k=1}^{MAX(n,m)} \mu(k)*\left\lfloor\frac{n}{d*k} \right \rfloor \left\lfloor\frac{m}{d*k} \right \rfloor\\\\ =\sum_{T=1}^{MIN(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T} \right \rfloor\sum_{d\mid T}d*\mu(\frac{T}{d}) & \mbox{(积性函数提取)} \\\\ =\sum_{T=1}^{MIN(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T} \right \rfloor \left(id*\mu\right)(T)&\mbox{(}Dirichlet\mbox{卷积}\mbox{)}\\\\ =\sum_{T=1}^{MIN(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T} \right \rfloor G(T) \end{array} 这个式子巧妙地使用了$Dirichlet$卷积，而我们知道，只要有$Dirichlet$卷积的出现，复杂度就会是$O(N \log N)$，所以我们可以先以$O(N \log N)$ 的复杂度预处理出所有的$G(x)$，然后直接$O(N)$ 进行计算，这样虽然单次查询效率没有上一个方法高，但却给我们提供了良好的思路，而且，在有许多组询问的时候，我们就只能通过这样的方法来进行问题的解决，所以说，这种方法应该更为高效 最小公倍数统计即需要我们计算如下的式子： \sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)首先根据常用定理，我们知道 lcm(i,j)=\frac{i*j}{gcd(i,j)}所以我们的式子就化为了： \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{gcd(i,j)}下面，我们就对这个式子进行详细的推导，我们发现，此时分母起到很大的作用，对于分母不同的两项，我们很难把他们归到一起，所以我们很自然的想到枚举$gcd$的取值，推导如下： \begin{array}{lcl} \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{gcd(i,j)}\\\\ =\sum_{d = 1} ^ {min(n, m)} \sum_{i = 1}^{n} \sum_{j = 1} ^ {m} \frac{i * j}{d} * [gcd(i,j) = d]\\\\= \sum_{d = 1} ^ {min(n, m)} \sum_{i' = 1}^{n} \sum_{j' = 1} ^ {m} i' * j' * d * [gcd(i',j') = 1]\\\\= \sum_{d = 1} ^ {min(n, m)} \sum_{i' = 1}^{n} \sum_{j' = 1} ^ {m} \sum_{k|gcd(i',j')}i' * j' * d * \mu(k) &\mbox{(}\mu\mbox{变换)} \\\\= \sum_{d = 1} ^ {min(n, m)}d*\sum_{k} \mu(k) * Sum(\left\lfloor\frac{n}{k*d}\right\rfloor,\left\lfloor\frac{m}{k*d}\right\rfloor) * k^2 &\mbox{(}\mu\mbox{提取)} \end{array}其中 \begin{array}{lcl} Sum(a,b) = \frac{a*(a + 1)}{2} * \frac{b*(b + 1)}{2} \end{array}此时，我们发现式子似乎不能再优化，于是我们使用以前的老套路，积性函数提取以及变量归一化，把变量$k,d$进行归一化，可以得到下面的式子： \begin{array}{lcl} \sum_{d = 1} ^ {min(n, m)}d*\sum_{k} \mu(k) * Sum(\left\lfloor\frac{n}{k*d}\right\rfloor,\left\lfloor\frac{m}{k*d}\right\rfloor) * k^2 &\mbox{(}\mu\mbox{提取)}\\\\ =\sum_{T = 1}^{min(n, m)} T*Sum( \left\lfloor\frac{n}{T}\right\rfloor,\left\lfloor\frac{m}{T}\right\rfloor)*\sum_{k|T} \mu(k) * k& \mbox{(变量归一化)}\\\\ = \sum_{T = 1}^{min(n, m)} T*Sum( \left\lfloor\frac{n}{T}\right\rfloor,\left\lfloor\frac{m}{T}\right\rfloor)*F(T)& \mbox{(积性函数提取)}\\\\ \end{array}这里解释一下为什么$F(T)$ 是积性函数，由于$F(T)$ 是两个积性函数的狄利克雷卷积$(F=f 1,其中f=\mu(k)k,显然为积性函数)$，所以，我们知道$F$是一个积性函数 那么，对于积性函数，我们可以怎么做呢？一开始我想使用杜教筛，但后来发现好像不用这么麻烦 不会杜教筛就直说嘛，然后想到了一个常常被忽略的套路：直接使用线性筛 具体做法如下，首先有$F[1]=1$，我们直接在线性筛中计算函数，然后对于两种情况进行分别的计算： F(i * prime[j])=\begin{cases} F[i] * (1 - prime[j]),& prime[j] \nmid i \\\\ F[i],& prime[j]\mid i \end{cases}这样我们就计算出了所有的$F$,然后，我们就可以使用双维分块法这种老套路进行计算了，最后的复杂度为$O(N + Q * \sqrt{N})$ 例题总结[Noi2010]能量采集时间限制: 1 Sec 内存限制: 128 MB 题目描述 栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。 栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。 由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。 能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。 下面给出了一个能量采集的例子，其中n = 5，m = 4，一共有20棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。 在这个例子中，总共产生了36的能量损失。 输入 仅包含一行，为两个整数 n 和 m。 输出 仅包含一个整数，表示总共产生的能量损失。 样例输入 5 4 样例输出 36 提示 【样例输入 2】 3 4 【样例输出 2】 20 【数据规模和约定】 对于 10%的数据：1 ≤ n, m ≤ 10； 对于 50%的数据：1 ≤ n, m ≤ 100； 对于 80%的数据：1 ≤ n, m ≤ 1000； 对于 90%的数据：1 ≤ n, m ≤ 10,000； 对于 100%的数据：1 ≤ n, m ≤ 100,000。 题解 我觉得，上面的套路要是都掌握了，自己推一推应该就行，下面的题都只给出最终公式（如果所需的知识点已经全部介绍过的话） 方法一公式如下： Sum = \sum_{T=1}^{min(n,m)}\left\lfloor\frac{n}{T}\right\rfloor*\left\lfloor\frac{m}{T}\right\rfloor * F(T)\\\\ F(T)=\sum_{k\mid T}\mu(k)* \frac{T}{k}\\\\ Ans = 2*(Sum - m*n ) + m*n代码 实测用时：$28ms$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 100005#define LL long long intusing namespace std;LL prime[maxn], cnt;LL F[maxn];LL mu[maxn];bool vis[maxn];void init()&#123; mu[1] = 1; for (LL i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; prime[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * prime[j] &gt;= maxn) break; vis[i * prime[j]] = 1; mu[i * prime[j]] = mu[i] * (-1); if (i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; &#125; &#125; for (int i = 1; i &lt; maxn; i++)&#123; for (int j = 1; i * j &lt; maxn; j++)&#123; F[i * j] += mu[i] * j; &#125; &#125; for (int i = 1; i &lt; maxn; i++)&#123; F[i] += F[i - 1]; &#125;&#125;void work(LL n, LL m)&#123; LL ans = 0; LL con = min(n, m); for (LL i = 1; i &lt;= con; i++)&#123; LL next = min(n / (n / i), m / (m / i)); ans += (n / i) * (m / i) * (F[next] - F[i - 1]); i = next; &#125; printf("%lld", m * n + ((ans - m * n) &lt;&lt; 1));&#125;int main()&#123; init(); freopen("ene.in", "r", stdin); freopen("ene.out", "w", stdout); LL n, m; scanf("%lld%lld", &amp;n, &amp;m); work(n, m); return 0;&#125; 方法二公式如下： Sum=\sum_{d=1}^{min(n,m)}d*\sum_{k=1}^{min(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor)}\left\lfloor\frac{n}{k*d}\right\rfloor*\left\lfloor\frac{m}{k*d}\right\rfloor * \mu(k)\\\\ Ans = 2*(Sum - m*n ) + m*n代码 实测用时：$44ms$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define maxn 100005#define LL long long intusing namespace std;LL mu[maxn];LL prime[maxn];LL cnt;bool vis[maxn];void init()&#123; mu[1] = 1; for (LL i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; mu[i] = -1; prime[cnt++] = i; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * prime[j] &gt;= maxn) break; vis[i * prime[j]] = 1; mu[i * prime[j]] = mu[i] * (-1); if (i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; &#125; &#125; for (LL i = 1; i &lt; maxn; i++)&#123; mu[i] += mu[i - 1]; &#125;&#125;LL work(LL n, LL m)&#123; LL ans = 0; LL con = min(n, m); for (LL i = 1; i &lt;= con; i++)&#123; LL next = min(n / (n / i), m / (m / i)); ans += (n / i) * (m / i) * (mu[next] - mu[i - 1]); i = next; &#125; return ans;&#125;int main()&#123; init(); freopen("ene.in", "r", stdin); freopen("ene.out", "w", stdout); LL n, m; scanf("%lld%lld", &amp;n, &amp;m); LL ans = 0; for (LL i = 1; i &lt;= min(n, m); i++)&#123; ans += i * work(n / i, m / i); &#125; printf("%lld", m * n + ((ans - m * n) &lt;&lt; 1)); return 0;&#125; YY的GCD时间限制: 5 Sec 内存限制: 512 MB Description神犇YY虐完数论后给傻×kAc出了一题给定N, M,求1&lt;=x&lt;=N, 1&lt;=y&lt;=M且gcd(x, y)为质数的(x, y)有多少对kAc这种傻×必然不会了，于是向你来请教……多组输入 Input第一行一个整数T 表述数据组数接下来T行，每行两个正整数，表示N, M OutputT行，每行一个整数表示第i组数据的结果 Sample Input2 10 10 100 100 Sample Output30 2791 HINTT = 10000 N, M &lt;= 10000000 题解公式如下： Ans = \sum_{T=1}^{min(n,m)}\left\lfloor\frac{n}{T}\right\rfloor*\left\lfloor\frac{m}{T}\right\rfloor * F(T)\\\\ F(T)=\sum_{k\mid T\mbox{且}T/k\mbox{为质数}}\mu(k)\\\\代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long int#define maxn 10000005using namespace std;int prime[maxn];int cnt;bool vis[maxn];int mu[maxn];LL F[maxn];void init()&#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; mu[i] = -1; prime[cnt++] = i; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * prime[j] &gt;= maxn) break; vis[i * prime[j]] = 1; mu[i * prime[j]] = mu[i] * (-1); if (i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; &#125; &#125; for (int i = 0; i &lt; cnt; i++)&#123; for (int j = 1; prime[i] * j &lt; maxn; j++)&#123; F[prime[i] * j] += mu[j]; &#125; &#125; for (int i = 0; i &lt; maxn ;i++)&#123; F[i] += F[i - 1]; &#125;&#125;void work(int n, int m)&#123; LL ans = 0; int con = min(n, m); for (int i = 1; i &lt;= con; i++)&#123; int next = min(n / (n / i), m / (m / i)); ans += (LL)(n / i) * (m / i) * (F[next] - F[i - 1]); i = next; &#125; printf("%lld\n", ans);&#125;int main()&#123; init(); freopen("yy.in", "r", stdin); freopen("yy.out", "w", stdout); int T, n, m; scanf("%d", &amp;T); while (T--)&#123; scanf("%d%d", &amp;n, &amp;m); work(n, m); &#125; return 0;&#125; Spoj5971 LCM Sum时间限制: 3 Sec 内存限制: 256 MB DescriptionGiven n, calculate the sum LCM(1,n) + LCM(2,n) + .. + LCM(n,n), where LCM(i,n) denotes the Least Common Multiple of the integers i and n. InputThe first line contains T the number of test cases. Each of the next T lines contain an integer n. OutputOutput T lines, one for each test case, containing the required sum. Sample Input3 1 2 5 Sample Output1 4 55 HINT1 &lt;= T &lt;= 3000001 &lt;= n &lt;= 1000000 题解本题还算是有点意思，有一个容易让大家忽略的技巧（然而上面也提到了），这里把公式详细地推一下 公式如下： \begin{array}{lcl} Ans=\sum_{i = 1}^{n}lcm(i,n)\\\\ =\sum_{i=1}^{n}\frac{n*i}{gcd(i,n)}\\\\ =n*\sum_{d\mid n}d*\sum_{i=1}^{\frac{n}{d}}i*[gcd(i,\frac{n}{d})=1]\\\\ \end{array}这时非常显然，就是要我们求出所有小于且与$\frac{n}{d}$互质的数的和，根据上面讲的$\varphi变换$，我们有这样的公式： \begin{array}{lcl} n*\sum_{d\mid n}d*\sum_{i=1}^{\frac{n}{d}}i*[gcd(i,\frac{n}{d})=1]\\\\ = n*\sum_{d\mid n}d*\frac{\frac{n}{d}* \varphi(\frac{n}{d})}{2}\\\\ = n*G(n) \end{array}所以，我们只要预处理出所有的$\varphi[i]$，然后直接狄利克雷卷积法预处理后半部分就好了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long int#define maxn 1000005using namespace std;LL fi[maxn];LL g[maxn];LL prime[maxn], cnt;bool vis[maxn];void init()&#123; fi[1] = 1; for (LL i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; prime[cnt++] = i; fi[i] = i - 1; &#125; for (LL j = 0; j &lt; cnt; j++)&#123; if (prime[j] * i &gt;= maxn) break; vis[prime[j] * i] = 1; fi[prime[j] * i] = fi[i] * (prime[j] - 1); if (i % prime[j] == 0)&#123; fi[prime[j] * i] = fi[i] * prime[j]; break; &#125; &#125; &#125; for (LL i = 1; i &lt; maxn; i++) g[i] = 1; for (LL i = 2; i &lt; maxn; i++)&#123; LL add = (i * fi[i]) &gt;&gt; 1; for (LL j = 1; j * i &lt; maxn; j++)&#123; g[i * j] += add; &#125; &#125; for (LL i = 1; i &lt; maxn; i++)&#123; g[i] *= i; &#125;&#125;int main()&#123; init(); freopen("LCM.in", "r", stdin); freopen("LCM.out", "w", stdout); LL T, n; scanf("%lld", &amp;T); while (T--)&#123; scanf("%lld", &amp;n); printf("%lld\n", g[n]); &#125; return 0;&#125; [CQOI2007]余数之和sum时间限制: 1 Sec 内存限制: 256 MB 题目描述给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7 输入输入仅一行，包含两个整数n, k。 输出输出仅一行，即j(n, k)。 样例输入5 3 样例输出7 提示50%的数据满足：1&lt;=n, k&lt;=1000100%的数据满足：1&lt;=n ,k&lt;=10^9 题解本题是一道有趣的题，也许它不需要太多的莫比乌斯反演基础 我们知道，$k \bmod i = k - i*\left\lfloor\frac{k}{i}\right\rfloor$ ，还知道在$i&gt;\sqrt{k}$的时候会有很多的值有重复，总共只有$O(\sqrt{n})$个不同的值，那么我们就可以想到使用这些值相同的特性来优化算法 于是我们可以类比分块法做： 令$i∗t \leqslant k \leq i∗(t+1)$，则$k \bmod i = k - i∗t$，考虑$i+1$时的情况，若$\left\lfloor\frac{k}{i}\right\rfloor=\left\lfloor\frac{k}{i+1}\right\rfloor$，则有$(i+1)∗ t \leqslant k \leq (i+1)∗ (t+1)$，$k \bmod (i+1) = k - (i+1)∗ t$，对比两次取模的式子，发现现在的结果比上一次减少了一个固定的数，那就是$t=\left\lfloor\frac{k}{i}\right\rfloor$,所以，我们在值$t=\left\lfloor\frac{k}{i}\right\rfloor$全相等的一群模数$i$中得到了一个等差数列，这个数列所有项的和是我们能够在$O(1)$时间内计算出来的，那么，我们就是要这样“分块”，每个块里面都是一个等差数列 那么，现在只有一个问题没有解决，那就是，这个等差数列里面会不会出现一些项为负数呢？下面我们来证明一下： 如果出现了负数，那么说明此时的模数$j$满足$k \bmod j = k - j ∗ t &lt; 0$，而由我们先前的证明知道，$k \geqslant j ∗ t$，所以不可能出现数列中有负数这种情况 那么我们就可以水过这道题了 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LL long long intusing namespace std;void work(LL n, LL k)&#123; LL ans = 0; LL con = min(n, k); for (LL i = 1; i &lt;= con; i++)&#123; LL next = k / (k / i); next = min(next, con); LL d = k / i; LL a = k % i; //LL num = a / d; /*if (num &lt; next - i)&#123; ans += (a + a - num * d) * (num + 1) &gt;&gt; 1; a = a - (num + 1) * d + i + num + 1; ans += (a + a - d * (next - i - num)) * (next - i - num) &gt;&gt; 1; &#125; else &#123; num = next - i; ans += (a + a - num * d) * (num + 1) &gt;&gt; 1; &#125;*/ LL num = next - i; ans += (a + a - num * d) * (num + 1) &gt;&gt; 1; i = next; &#125; if (n &gt; k)&#123; ans += (n - k) * k; &#125; printf("%lld", ans);&#125;int main()&#123; freopen("rest.in", "r", stdin); freopen("rest.out", "w", stdout); LL n, k; scanf("%lld %lld", &amp;n, &amp;k); work(n, k); return 0;&#125; jzptab时间限制: 11 Sec 内存限制: 512 MB 题目描述求 $ \sum_{i=1}^{n}\sum_{j=1}^{m} lcm(i,j) $ ，答案模$100000009$输出多组询问 输入一个正整数T表示数据组数接下来T行 每行两个正整数 表示N、M 输出T行 每行一个整数 表示第i组数据的结果 样例输入14 5 样例输出122 提示T &lt;= 10000N, M&lt;=10000000 题解这道题在其他题目的基础上，增加了线性筛积性函数的这个环节，是本题的亮点 但其实本题就是统计最小公倍数，公式如下： \begin{array}{lcl} Ans=\sum_{T = 1}^{min(n, m)} T*Sum( \left\lfloor\frac{n}{T}\right\rfloor,\left\lfloor\frac{m}{T}\right\rfloor)* F(T)\\\\ Sum(a,b) = \frac{a*(a + 1)}{2} * \frac{b*(b + 1)}{2}\\\\ F(T)=\sum_{k|T} \mu(k) * k \end{array}线性筛一发$F[i]$，不会的回到上面自己看去 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define maxn 10000005#define M 100000009#define LL long long intusing namespace std;LL F[maxn];int prime[maxn], cnt;bool vis[maxn];void init()&#123; F[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if (!vis[i])&#123; prime[cnt++] = i; F[i] = (1 - i) % M; &#125; for (int j = 0; j &lt; cnt; j++)&#123; if (i * prime[j] &gt;= maxn) break; F[i * prime[j]] = F[i] * (1 - prime[j]) % M; vis[i * prime[j]] = 1; if (i % prime[j] == 0)&#123; F[i * prime[j]] = F[i]; break; &#125; &#125; &#125; for (int i = 1; i &lt; maxn; i++) F[i] = (i * F[i] % M + F[i - 1]) % M/*, printf("%lld ", F[i])*/;&#125;void work(int n, int m)&#123; LL ans = 0; int con = min(n, m); for (int i = 1; i &lt;= con; i++)&#123; int next = min(n / (n / i), m / (m / i)); ans = (ans + (((LL)(m / i + 1) * (m / i) &gt;&gt; 1) % M) * (((LL)(n / i + 1) * (n / i) &gt;&gt; 1) % M) % M * (F[next] - F[i - 1]) % M) % M; i = next; &#125; printf("%lld\n", (ans + M) % M);&#125;int main()&#123; freopen("jzp.in", "r", stdin); freopen("jzp.out", "w", stdout); init(); int n, m, T; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%d", &amp;n, &amp;m); work(n, m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
</search>
